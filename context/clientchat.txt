
2/5/2026
2/6/2026
Saturday
Mohak
+971 58 590 3850
Brother, match making is the primary functionality for the clob
Yes, it is working, but an error occurs. I‚Äôm fixing that. This was also working previously; I tested it. I know matchmaking is the primary functionality.
4:05 PM
Mohak
+971 58 590 3850
You mentioned other than match making all other functionality is complete. I have explained this before, the primary thing which has to be rock solid is match making which included order fulfilment(partial or full), order cancellation etc, with real transfer of tokens. 
We still haven‚Äôt been able to test all of it yet. UI fixes, additionally features etc we can cover in next milestone but the core functionality needs to be tested. Once you have tested it, let us know and then we will test
7:46 PM

üëç
Monday
@~huz  now check match making and  transfer of tokens
8:14 PM
huz
+91 79903 24401
@AHMED I just created an order (ID starting with order-1770‚Ä¶), but the order isnt visible in Buy Orders
Edited9:06 PM
huz
+91 79903 24401
This message couldn't load. Open the message on your phone to view it. Click here to update.
9:06 PM
The order you created (ID starting with order-1770‚Ä¶) is visible in the Buy Orders section it's aggregated at the 0.10 price level along with other orders at the same price, which is standard exchange behavior (similar to Binance).
To make this clearer, we've added a "My" column to the order book. It shows a numbered badge next to any price level where you have orders, so you can instantly see which rows include your orders and how many.
We also improved the order book refresh timing after placing or canceling an order it now waits for Canton to fully commit the transaction before refreshing, so your new orders appear immediately without needing a manual refresh.
10:27 PM
@~huz, did you check?
1:26 AM
huz
+91 79903 24401
@AHMED I did create few orders and are visible too in sell/buy orders ‚ÄúMY‚Äù section, stuck on how can I match any order. Can you give me a sample input which I can use to request a new order which will result in matchmaking
10:54 AM
@AHMED if you are available, can we connect on a call to check the clob?
8:40 PM
Orders are matching but it seems that the tokens are not being transferred
9:06 PM
huz
+91 79903 24401
@AHMED if you are available, can we connect on a call to check the clob?
Yes sure
9:12 PM
huz
+91 79903 24401
@AHMED I did create few orders and are visible too in sell/buy orders ‚ÄúMY‚Äù section, stuck on how can I match any order. Can you give me a sample input which I can use to request a new order which will result in matchmaking
I‚Äôm Im working on it
9:12 PM
huz
+91 79903 24401
You
Yes sure
Connect now?
9:25 PM
huz
+91 79903 24401
Connect now?
Yes
9:34 PM
Are you sharing the meeting link ?
9:36 PM
huz
+91 79903 24401
Give me few mins
9:40 PM

üëç
Theres a power outage in my area, will ping you if it comes back else lets connect in the morning
10:12 PM
huz
+91 79903 24401
Theres a power outage in my area, will ping you if it comes back else lets connect in the morning
Om
10:13 PM
No problem
10:13 PM
huz
+91 79903 24401
Can connect now or if its too late for you then lets connect tomorrow
Edited10:32 PM
huz
+91 79903 24401
Can connect now or if its too late for you then lets connect tomorrow
Connect now
10:38 PM

üëç
huz
+91 79903 24401
Meet
Real-time meetings by Google. Using your browser, share your video, desktop, and presentations with teammates and customers.
meet.google.com
https://meet.google.com/tin-zgtz-mhy
10:40 PM
You deleted this message
10:43 PM
Wednesday
Mohak
+971 58 590 3850
We have tried testing again today:

-The orders are taking around 30 mins to match.
-Once they match, the balances remain unchanged.
11:57 AM
Not sure if we are on right track here. As it‚Äôs not a small bug anymore, it‚Äôs been more than a week and we still don‚Äôt have basic order match making working.
11:58 AM
If there are any limitations, please let us know asap.
11:58 AM
Also, are we using allocations as discussed before? We can‚Äôt see any transfer of tokens on explorer when the order is matched
3:39 PM
30 min match delay: The matching engine executes in 1-2 seconds on the backend. The delay is because the production WebSocket is pointing to localhost instead of the live server so the UI misses real-time updates. This is a config fix.

Balances unchanged: The UI is showing total balance instead of available balance. Backend locks funds correctly but the frontend isn't reflecting it. Display bug ‚Äî fixing now.
No transfers on explorer: We're updating the settlement flow to use the proper allocation-based transfer mechanism so token movements are visible on the explorer.

No fundamental limitations  core matching works. These are config and display issues. Working on all three fixes now.
Edited3:50 PM
Mohak
+971 58 590 3850
Thanks for the update. Please test it once you have fixed these and let us know
4:02 PM
Today
Mohak
+971 58 590 3850
Hi, when will we be able to test the app?
1:01 PM
Hi, you‚Äôll be able to test the app by tomorrow. I‚Äôll share the link once it‚Äôs ready.
Edited2:17 PM
Hi,

I've been debugging the matching issues and found the root problems:
Issue 1: Balances not updating after trades

When an order matches, we're minting new tokens for the buyer but the seller's original CC/CBTC tokens aren't being burned. This causes the total supply to inflate.
We need to know:

Can we programmatically archive/burn Splice Holdings (CC/CBTC)?
Should we integrate with the Transfer Registry you mentioned (http://65.108.40.104:8088)?
Any other preferred method?

Issue 2: No transfer events showing on explorer
The current approach creates new token contracts instead of transferring existing ones. The problem is Canton's Splice Holdings (CC/CBTC) have restrictions in their Daml templates:

assert (lock == None) on Split
assert (lock == None) ‚Ä¶Read more
9:09 PM
@~Mohak @~huz
9:18 PM
Mohak
+971 58 590 3850
How are you minting new tokens?
9:22 PM
Like how can you mint new CBTC and supply to inflate, we don‚Äôt own CBTC contract
9:23 PM
huz
+91 79903 24401
You
Hi,

I've been debugging the matching issues and found the root problems:
Issue 1: Balances not updating after trades

When an order matches, we're minting new tokens for the buyer but the seller's original CC/CBTC tokens aren't being burned. This causes the total supply to inflate.
We need to know:

Can we programmatically archive/burn Splice Holdings (CC/CBTC)?
Should we integrate with the Transfer Registry you mentioned (http://65.108.40.104:8088)?
Any other preferred method?

Issue 2: No transfer events showing on explorer
The current approach creates new token contracts instead of transferring existing ones. The problem is Canton's Splice Holdings (CC/CBTC) have restrictions in their Daml templates:

assert (lock == None) on Split
assert (lock == None) 
Yes, we need to use transfer registry (specific to instrument) to transfer tokens from one party to another.
9:29 PM

üëç
Mohak
+971 58 590 3850
Like how can you mint new CBTC and supply to inflate, we don‚Äôt own CBTC contract
We're creating custom Holding contracts on our own Daml template with the symbol "CBTC" they're IOUs inside our exchange, not real CBTC. We can't mint actual CBTC since we don't own that contract. We need the correct API to transfer real CC/CBTC between parties during settlement.
9:33 PM
huz
+91 79903 24401
You
We're creating custom Holding contracts on our own Daml template with the symbol "CBTC" they're IOUs inside our exchange, not real CBTC. We can't mint actual CBTC since we don't own that contract. We need the correct API to transfer real CC/CBTC between parties during settlement.
We need to use the splice token Holding interface and not custom templates, unless you are inheriting this interface in your template then its fine...


@~huz 
We have confirmed that http://65.108.40.104:8088 is the Scan frontend UI and not a Transfer Registry REST API. The Scan API at /api/scan/v0/ is functioning correctly for discovery purposes.

Could you please clarify the following:

What is the exact API or choice we should call to transfer CC/CBTC between parties during order settlement?
Should we exercise a DAML choice on Splice Holding contracts directly via the Ledger API on port 31539?
Is there a specific transfer factory or pre-approval flow that we should use?
You will need Scan Api for fetching transfer registry, validator-app also exposes this same scan api via /api/validator/v0/scan-proxy but with some restricited routes. You can use either of them, the route for transfer-registry is https://docs.sync.global/app_dev/token_standard/openapi/transfer_instruction.html. 

For example,
To fetch factoryID and context 
/api/validator/v0/scan-proxy/registry/transfer-instruction/v1/transfer-factory



You can check this script for better undertstanding https://github.com/hyperledger-labs/splice/blob/main/token-standard/cli/src/commands/transfer.ts

Or, you can use wallet-sdk for convenience https://docs.digitalasset.com/integrate/devnet/token-standard/index.html#how-do-i-quickly-perform-a-transfer-between-two-parties




Client Share me This :

Hey @AHMED yes cBTC needs to work. If it doesn‚Äôt, the transaction is incomplete and there‚Äôs no reason any user will deposit their CC if they aren‚Äôt getting cBTC back.


Will integrating usdcx will be easy after you figure out cbtc?

Just to confirm, you are using Allocations in matchmaking to resolve settlements between 2 parties

As CBTC is a Utilties Token (CIP-0056), we need to use the utilities backend url (same as you must have used in accepting CBTC tokens).
Can refer to this doc, https://docs.digitalasset.com/utilities/devnet/how-tos/registry/transfer/transfer.html. Heres the Backend API 
${BACKEND_API}/v0/registrars/${ADMIN_PARTY_ID}/registry/transfer-instruction/v1/transfer-factory (this is for transferring of tokens)
BACKEND_API=‚Äúhttps://api.utilities.digitalasset-dev.com/api/utilities‚Äù (for devnet)
ADMIN_PARTY_ID=‚Äúcbtc-network::12202a83c6f4082217c175e29bc53da5f2703ba2675778ab99217a5a881a949203ff‚Äù


The matchmaking is working and is getting settled instantly, but we are not using Allocations to transfer the assets, the transfer of assets is done by TransferInstruction which should not be the case. 
As we are using internal parties in this app, we can create any transfer from the backend and the flow would work fine, but when we will switch to external parties then we would require a signature from user's private key owning the external party to create a TransferInstruction. Hence, we will need to use Allocations, this way we can set sender, receiver and executor beforehand, this will help us settle (using the executor, which will be us) the allocation when there is matching order also include stop loss order functionality

[1:06 PM, 2/17/2026] +91 79903 24401: Hey @AHMED,
The matchmaking is working and is getting settled instantly, but we are not using Allocations to transfer the assets, the transfer of assets is done by TransferInstruction which should not be the case. 

As we are using internal parties in this app, we can create any transfer from the backend and the flow would work fine, but when we will switch to external parties then we would require a signature from user's private key owning the external party to create a TransferInstruction. Hence, we will need to use Allocations, this way we can set sender, receiver and executor beforehand, this will help us settle (using the executor, which will be us) the allocation when there is matching order
[1:36 PM, 2/17/2026] AHMED: What is your OPERATOR_PARTY_ID? (the exchange operator party that will be the executor)
Are the Allocation API endpoints available on your scan proxy? (/registry/allocation-instruction/v1/...)
Does CBTC support Allocations via the Utilities Backend API?
[1:48 PM, 2/17/2026] Konain Bhai: Hey @AHMED,
The matchmaking is working and is getting settled instantly, but we are not using Allocations to transfer the assets, the transfer of assets is done by TransferInstruction which should not be the case. 

As we are using internal parties in this app, we can create any transfer from the backend and the flow would work fine, but when we will switch to external parties then we would require a signature from user's private key owning the external party to create a TransferInstruction. Hence, we will need to use Allocations, this way we can set sender, receiver and executor beforehand, this will help us settle (using the executor, which will be us) the allocation when there is matching order
Hello @~huz 

We acknowledge that the current implementation uses TransferInstruction instead of Allocations for settlement.

We will address this in Milestone 4, which will include:

1. Replacing TransferInstruction with Allocation-based settlement (executor = exchange operator)
2. Migration from internal parties to external wallet parties
3. Full Allocation flow: create at order placement ‚Üí execute at matching ‚Üí withdraw on cancellation

This will ensure the exchange works correctly with external parties and no user signatures are required at settlement time.

We shall proceed with the 4th milestone now.
[1:52 PM, 2/17/2026] +971 58 590 3850: Hi Zoya, to be honest this was part of milestone 2 (core functionality completion) and I missed that. This should be done in this milestone itself. We need to finish all the functionality in this milestone itself. The next milestone is just stop loss order, end to end testing, security audit, UI finishes and polishing.
[1:53 PM, 2/17/2026] Konain Bhai: The functionality is completed, we need to understand this that the core functionality is working, this is the final part which has to be done while final implementation and deployment
[1:53 PM, 2/17/2026] +971 58 590 3850: I didn‚Äôt realise in the milestone 2 that we weren‚Äôt doing any transfer of tokens, rather just changing the text.
[1:54 PM, 2/17/2026] Konain Bhai: This is not something complicated or anything, right now we are only wasting time on going back and forth on this.
The functionality is completed, we need to understand this that the core functionality is working, this is the final part which has to be done while final implementation and deployment
[1:56 PM, 2/17/2026] Konain Bhai: On the development side, we always get bugs while we add on features, so not until all the features including stop loss and everything is deployed, we won‚Äôt know what other bugs we might face, so for that we would need to deploy all the fatures first and then do the debugging.
On the development side, we always get bugs while we add on features, so not until all the features including stop loss and everything is deployed, we won‚Äôt know what other bugs we might face, so for that we would need to deploy all the fatures first and then do the debugging.
[1:58 PM, 2/17/2026] Konain Bhai: 0:36
Exactly, but while we will be deploying the stopp loss feature, it will disrupt this functionality as well.
[1:59 PM, 2/17/2026] Konain Bhai: So we need to proceed with the deployment of all the remaining feature plus this so that we can finally initiate the proper flow
[1:59 PM, 2/17/2026] +971 58 590 3850: Why would it disrupt the functionality? The stop loss is just an automated match making on a specific condition. The transfer of tokens using allocation remains the same there
[2:01 PM, 2/17/2026] +971 58 590 3850: The transfer of tokens in the proper way was supposed to be completed in milestone 2, as that‚Äôs the basic but most important functionality of a clob after match making engine. If it‚Äôs even not completed yet, how will we feel confident that it will be done in milestone?
[2:01 PM, 2/17/2026] +971 58 590 3850: We were told multiple times that it‚Äôs already done. Only during our testing we find out each time that it isn‚Äôt.
[2:06 PM, 2/17/2026] Konain Bhai: I am not sure how to elaborate and explain the issues we might face but right now for us the best resolution is that we implement all the deployment at once which includes 4th milestone too. We are doing that today and then we‚Äôll proceed to the bug fixing part.


[4:42 PM, 2/20/2026] +91 79903 24401: @AHMED, we are using internal parties in the app, we need to shift to external parties.
Internal parties are created from the same namespace keys and hence can be controlled by the validator. External parties are created by private keys outside the validator, ensuring that the user has all the control, every transaction submitted will require signature from this private key which ensure that the transaction was submitted with the authorithy of the owning user
[4:45 PM, 2/20/2026] +91 79903 24401: Please ensure the created party have ‚ÄúConfirmation‚Äù permission
[5:04 PM, 2/20/2026] AHMED: Please ensure the created party have ‚ÄúConfirmation‚Äù permission
Ok
[5:04 PM, 2/20/2026] AHMED: Also share your wallet id
?
[5:15 PM, 2/20/2026] +91 79903 24401: external-wallet-user-cadd0aa928c2a0cf::122087fa379c37332a753379c58e18d397e39cb82c68c15e4af7134be46561974292
[6:29 PM, 2/20/2026] AHMED: @~huz The issue is that the orderbook can't see them due to the 200-element limit on the 273cbc package.
[7:08 PM, 2/20/2026] AHMED: Hey @~huz ,
The orderbook issue is fixed. The problem was a Canton API query limit when there are 200+ Order contracts (including old filled ones), the API blocks the response. I've added user-specific queries that bypass this limit, so your orders will now show up correctly in the orderbook. Please refresh and check.

Also just a heads up  on Canton, every order stays as an active contract on the ledger even after it's FILLED or CANCELLED. Right now there are 200+ old Order contracts sitting there. Would be good to archive the old filled/cancelled ones when you get a chance, just to keep things clean.
[7:09 PM, 2/20/2026] +971 58 590 3850: Are these with external party id now?
[10:21 PM, 2/20/2026] +91 79903 24401: Hey @~huz ,
The orderbook issue is fixed. The problem was a Canton API query limit when there are 200+ Order contracts (including old filled ones), the API blocks the response. I've added user-specific queries that bypass this limit, so your orders will now show up correctly in the orderbook. Please refresh and check.

Also just a heads up  on Canton, every order stays as an active contract on the ledger even after it's FILLED or CANCELLED. Right now there are 200+ old Order contracts sitting there. Would be good to archive the old filled/cancelled ones when you get a chance, just to keep things clean.
@AHMED In production the 200 limit will reach very soon, we need to use ledger-api or web sockets to get stream of data. Also we need to optimise the daml choices in such a way that only useful contracts are in active set and rest are archived‚Ä¶
[10:42 PM, 2/20/2026] AHMED: Are these with external party id now?
Yes
[10:46 PM, 2/20/2026] AHMED: @AHMED In production the 200 limit will reach very soon, we need to use ledger-api or web sockets to get stream of data. Also we need to optimise the daml choices in such a way that only useful contracts are in active set and rest are archived‚Ä¶
Ok
[10:46 PM, 2/20/2026] AHMED: I have switch from internal to external party
[10:47 PM, 2/20/2026] AHMED: Just few changes remain I'm working then I'll push my changes


[5:03 PM, 2/25/2026] AHMED: Hey, we're stuck on one thing right now. The Canton participant node (65.108.40.104) keeps dropping its connection to the global domain synchronizer. When it disconnects, no write operations go through orders can't settle, tokens can't transfer. Everything else is ready matching engine, allocations, external parties, order book all working. We just need a stable connection on the participant. Can you check if something is up with the server or restart the Canton participant process?
[5:04 PM, 2/25/2026] AHMED: @~Mohak @~huz
[5:05 PM, 2/25/2026] +91 79903 24401: Hey, we're stuck on one thing right now. The Canton participant node (65.108.40.104) keeps dropping its connection to the global domain synchronizer. When it disconnects, no write operations go through orders can't settle, tokens can't transfer. Everything else is ready matching engine, allocations, external parties, order book all working. We just need a stable connection on the participant. Can you check if something is up with the server or restart the Canton participant process?
Let me try restarting the participant node
[5:09 PM, 2/25/2026] AHMED: Let me try restarting the participant node
Thanks.
Yes, please restart the participant node. Once it's back up, we‚Äôll test and confirm everything is working.
[5:14 PM, 2/25/2026] +91 79903 24401: Please check now
[5:14 PM, 2/25/2026] AHMED: Please check now
I'll check


@42121079853221 the participant logs are filled with submit commands generating from your partyId 



```
{"@timestamp":"2026-02-25T16:01:21.805Z","message":"Request com.daml.ledger.api.v2.CommandService/SubmitAndWaitForTransaction by inprocess-grpc-5001: failed with NOT_FOUND/CONTRACT_NOT_FOUND(11,1b53657f): Contract could not be found with id 00b0c2587f37a0387f9a0d8be9b1bd8de97bf6d2cd30c7a1f5db44fa7e14ec3375ca121220bbdfa3c57b792ca8181d71d4889936b09f52dc6f514b04c26882f54c50824257","logger_name":"c.d.c.n.g.ApiRequestLogger:participant=participant","thread_name":"canton-env-ec-79","level":"INFO","span-id":"ab3bc99ddce522a8","span-parent-id":"400f127839bf1c5c","trace-id":"a1cb78df399174b26a927d2324863717","span-name":"logger"}
{"@timestamp":"2026-02-25T16:01:21.979Z","message":"Phase 1 started: Submitting 1 command(s) for interpretation on behalf of 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa379c....","logger_name":"c.d.c.p.a.s.c.CommandSubmissionServiceImpl:participant=participant","thread_name":"canton-env-ec-795","level":"INFO","span-id":"3a9928e5dc03e385","span-parent-id":"f176f68142c7f5c1","trace-id":"35dbea24a85c6741e470d33739fe7232","span-name":"StreamTracker.track"}
{"@timestamp":"2026-02-25T16:01:21.983Z","message":"CONTRACT_NOT_FOUND(11,65a07c89): Contract could not be found with id 00b0c2587f37a0387f9a0d8be9b1bd8de97bf6d2cd30c7a1f5db44fa7e14ec3375ca121220bbdfa3c57b792ca8181d71d4889936b09f52dc6f514b04c26882f54c50824257","logger_name":"c.d.c.p.a.s.c.CommandSubmissionServiceImpl:participant=participant","thread_name":"canton-env-ec-795","level":"INFO","trace-id":"35dbea24a85c6741e470d33739fe7232","location":"RejectionGenerators.scala:100","span-id":"3a9928e5dc03e385","error-code":"CONTRACT_NOT_FOUND(11,65a07c89)","span-parent-id":"f176f68142c7f5c1","participant":"'participant'","commands":"{readAs: ['ext-99495cb33b51::1220c98aeed243fe29dfc7d6fda2917e7423388a8cbf8d4946c98be167035c9a00cb'], deduplicationPeriod: {duration: 'PT30S'}, submittedAt: '2026-02-25T16:01:21.979415Z', submissionId: '65a07c89-5181-4ef6-93fb-3870ad76c530', actAs: ['8100b2db-86cf-40a1-8351-55483c151cdc::122087fa379c37332a753379c58e18d397e39cb82c68c15e4af7134be46561974292'], commandId: 'cmd-exercise-8684cef2-ca0b-4bbc-ab41-d9cfb932829f', userId: '652db10c-71a6-458b-baf3-906418723859', workflowId: }","span-name":"StreamTracker.track"}
```

This contract is archived this might be the reason for your error

[5:05 PM, 2/25/2026] +91 79903 24401: Hey, we're stuck on one thing right now. The Canton participant node (65.108.40.104) keeps dropping its connection to the global domain synchronizer. When it disconnects, no write operations go through orders can't settle, tokens can't transfer. Everything else is ready matching engine, allocations, external parties, order book all working. We just need a stable connection on the participant. Can you check if something is up with the server or restart the Canton participant process?
Let me try restarting the participant node
[5:09 PM, 2/25/2026] AHMED: Let me try restarting the participant node
Thanks.
Yes, please restart the participant node. Once it's back up, we‚Äôll test and confirm everything is working.
[5:14 PM, 2/25/2026] +91 79903 24401: Please check now
[5:14 PM, 2/25/2026] AHMED: Please check now
I'll check
[6:32 PM, 2/25/2026] AHMED: Hey @~huz , the participant is still dropping its synchronizer connection. We placed fresh orders, the matching engine detected the match and created the allocation, but settlement fails because the participant is disconnected again. The error shows both the operator AND the external party as "unknownSubmitters" meaning the participant has no active synchronizer connection at all. Can you check why it keeps disconnecting? We need a stable connection for any write operations to go through.
[9:04 PM, 2/25/2026] +91 79903 24401: @AHMED the participant logs are filled with submit commands generating from your partyId 




{"@timestamp":"2026-02-25T16:01:21.805Z","message":"Request com.daml.ledger.api.v2.CommandService/SubmitAndWaitForTransaction by inprocess-grpc-5001: failed with NOT_FOUND/CONTRACT_NOT_FOUND(11,1b53657f): Contract could not be found with id 00b0c2587f37a0387f9a0d8be9b1bd8de97bf6d2cd30c7a1f5db44fa7e14ec3375ca121220bbdfa3c57b792ca8181d71d4889936b09f52dc6f514b04c26882f54c50824257","logger_name":"c.d.c.n.g.ApiRequestLogger:participant=participant","thread_name":"canton-env-ec-79","level":"INFO","span-id":"ab3bc99ddce522a8","span-parent-id":"400f127839bf1c5c","trace-id":"a1cb78df399174b26a927d2324863717","span-name":"logger"}
{"@timestamp":"2026-02-25T16:01:21.9‚Ä¶
[5:45 AM, 2/26/2026] AHMED: Hey Huz, we‚Äôre stuck on one Canton issue that‚Äôs holding up all our settlements and could really use your help.

Here‚Äôs what‚Äôs happening: when we do an interactive submission for Allocation_ExecuteTransfer, we include both the operator party (8100b2db-86cf-40a1-8351-55483c151cdc::122087fa‚Ä¶) and the external party (ext-edded1b16c64::1220de80‚Ä¶) in actAs, and we provide the external party‚Äôs Ed25519 signature. But Canton keeps rejecting it with this error:

FAILED_TO_EXECUTE_TRANSACTION: The following actAs parties did not provide an external signature: 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa‚Ä¶

What‚Äôs confusing us is why isn‚Äôt the operator party auto-signing here? Its key should be hosted on the participant, and in interactive mode Canton is supposed to au‚Ä¶
[11:35 AM, 2/26/2026] +91 79903 24401: Hey Huz, we‚Äôre stuck on one Canton issue that‚Äôs holding up all our settlements and could really use your help.

Here‚Äôs what‚Äôs happening: when we do an interactive submission for Allocation_ExecuteTransfer, we include both the operator party (8100b2db-86cf-40a1-8351-55483c151cdc::122087fa‚Ä¶) and the external party (ext-edded1b16c64::1220de80‚Ä¶) in actAs, and we provide the external party‚Äôs Ed25519 signature. But Canton keeps rejecting it with this error:

FAILED_TO_EXECUTE_TRANSACTION: The following actAs parties did not provide an external signature: 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa‚Ä¶

What‚Äôs confusing us is why isn‚Äôt the operator party auto-signing here? Its key should be hosted on the participant, and in interactive mode Canton is supposed to au
@AHMED 
As the actAs parameter have 2 different parties it needs to have 2 different signature while submitting the transaction, I havent created a multi-sign tx before so dont have much idea on it , check out requestBody in /v2/interactive-submission/execute route, in partySignatures.signatures we can add multiple signatures (can find similar in ledger-api).

But, we can run the choice Allocation_ExecuteTransfer with just the executor if all the other parties in transferleg have already sign the allocation. Also, just want to know in which scenario we would be needing both parties signature?

[3:02 PM, 2/27/2026] +91 79903 24401: @AHMED 
Are you running a service which is constantly submitting commands to ledger?, as the logs are filled with CONTRACT_NOT_FOUND. Please fix this as its causing a lot of congestion in participant node


{"@timestamp":"2026-02-27T09:59:08.587Z","message":"Phase 1 started: Submitting 1 command(s) for interpretation on behalf of 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa379c....","logger_name":"c.d.c.p.a.s.c.CommandSubmissionServiceImpl:participant=participant","thread_name":"canton-env-ec-218","level":"INFO","span-id":"56e50c23093b8c1f","span-parent-id":"ce24247ac87f6be5","trace-id":"f30c0daef4824064289279ea63a97ab4","span-name":"StreamTracker.track"}
{"@timestamp":"2026-02-27T09:59:08.591Z","message":"CONTRACT_NOT_FOUND(11,29d73675): Contract could not be found with id 005118345ad74a3b1b4596c33a724a4a72f2e4654faf0115fd7ab75c73144dc814ca1212208a30a8c1297f8da60c55e2b9082339da5d1ffffdda36e619ffbdf3520b039520","logger_name":"c.d.c.p.a.s.c.CommandSubmissionServiceImpl:participant=participant","thread_name":"canton-env-ec-221","level":"INFO","trace-id":"f30c0daef4824064289279ea63a97ab4","location":"RejectionGenerators.scala:100","span-id":"56e50c23093b8c1f","error-code":"CONTRACT_NOT_FOUND(11,29d73675)","span-parent-id":"ce24247ac87f6be5","participant":"'participant'","commands":"{readAs: ['ext-c66004aee097::12206e3f47b598ddf574e13ab09896b837a921c0efd7d592fe1bf63339f97283707c'], deduplicationPeriod: {duration: 'PT30S'}, submittedAt: '2026-02-27T09:59:08.587494Z', submissionId: '29d73675-cd18-42f5-931a-670ea37cde20', actAs: ['8100b2db-86cf-40a1-8351-55483c151cdc::122087fa379c37332a753379c58e18d397e39cb82c68c15e4af7134be46561974292'], commandId: 'cmd-exercise-657027a2-f2f2-4b63-a435-3bd1f266dd2a', userId: '652db10c-71a6-458b-baf3-906418723859', workflowId: }","span-name":"StreamTracker.track"}
{"@timestamp":"2026-02-27T09:59:08.591Z","message":"Request com.daml.ledger.api.v2.CommandService/SubmitAndWaitForTransaction by inprocess-grpc-5001: failed with NOT_FOUND/CONTRACT_NOT_FOUND(11,29d73675): Contract could not be found with id 005118345ad74a3b1b4596c33a724a4a72f2e4654faf0115fd7ab75c73144dc814ca1212208a30a8c1297f8da60c55e2b9082339da5d1ffffdda36e619ffbdf3520b039520","logger_name":"c.d.c.n.g.ApiRequestLogger:participant=participant","thread_name":"canton-env-ec-43","level":"INFO","span-id":"7088f4b0f0883f76","span-parent-id":"ce24247ac87f6be5","trace-id":"f30c0daef4824064289279ea63a97ab4","span-name":"logger"}
{"@timestamp":"2026-02-27T09:59:08.776Z","message":"Phase 1 started: Submitting 1 command(s) for interpretation on behalf of 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa379c....","logger_name":"c.d.c.p.a.s.c.CommandSubmissionServiceImpl:participant=participant","thread_name":"canton-env-ec-221","level":"INFO","span-id":"1b960379e38aee5c","span-parent-id":"12adc0239c0e3289","trace-id":"4fdcbcbe322e92355bb8dd45f2156c3b","span-name":"StreamTracker.track"}
{"@timestamp":"2026-02-27T09:59:08.780Z","message":"CONTRACT_NOT_FOUND(11,2c97d0a1): Contract could not be found with id 005118345ad74a3b1b4596c33a724a4a72f2e4654faf0115fd7ab75c73144dc814ca1212208a30a8c1297f8da60c55e2b9082339da5d1ffffdda36e619ffbdf3520b039520","logger_name":"c.d.c.p.a.s.c.CommandSubmissionServiceImpl:participant=participant","thread_name":"canton-env-ec-215","level":"INFO","trace-id":"4fdcbcbe322e92355bb8dd45f2156c3b","location":"RejectionGenerators.scala:100","span-id":"1b960379e38aee5c","error-code":"CONTRACT_NOT_FOUND(11,2c97d0a1)","span-parent-id":"12adc0239c0e3289","participant":"'participant'","commands":"{readAs: ['ext-c66004aee097::12206e3f47b598ddf574e13ab09896b837a921c0efd7d592fe1bf63339f97283707c'], deduplicationPeriod: {duration: 'PT30S'}, submittedAt: '2026-02-27T09:59:08.776332Z', submissionId: '2c97d0a1-8e62-4823-b6a8-7d3c8e9b6dc6', actAs: ['8100b2db-86cf-40a1-8351-55483c151‚Ä¶
[4:22 PM, 2/27/2026] AHMED: @~huz 
we made progress signing keys are now stored and interactive settlement is being attempted. But we're hitting one last issue:
When we do an interactive submission for Allocation_ExecuteTransfer with both the operator (8100b2db-...) and the external party (ext-edded1b16c64::...) in actAs, we provide the external party's Ed25519 signature in partySignatures. The participant should auto-sign for the operator (since it's a hosted party), but we get:

FAILED_TO_EXECUTE_TRANSACTION: The following actAs parties did not provide an external signature: 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa...

The participant is NOT auto-signing for the operator in interactive mode. And when we try executor-only (non-interactive), the DAML DvpLegAllocation c
?
[4:22 PM, 2/27/2026] AHMED: @AHMED 
Are you running a service which is constantly submitting commands to ledger?, as the logs are filled with CONTRACT_NOT_FOUND. Please fix this as its causing a lot of congestion in participant node


{"@timestamp":"2026-02-27T09:59:08.587Z","message":"Phase 1 started: Submitting 1 command(s) for interpretation on behalf of 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa379c....","logger_name":"c.d.c.p.a.s.c.CommandSubmissionServiceImpl:participant=participant","thread_name":"canton-env-ec-218","level":"INFO","span-id":"56e50c23093b8c1f","span-parent-id":"ce24247ac87f6be5","trace-id":"f30c0daef4824064289279ea63a97ab4","span-name":"StreamTracker.track"}
{"@timestamp":"2026-02-27T09:59:08.591Z","message":"CONTRACT_NOT_FOUND(11,29d73675): Contract
I‚Äôll check


[4:22 PM, 2/27/2026] AHMED: I‚Äôll check
[7:15 PM, 2/27/2026] Konain Bhai: @~huz 
we made progress signing keys are now stored and interactive settlement is being attempted. But we're hitting one last issue:
When we do an interactive submission for Allocation_ExecuteTransfer with both the operator (8100b2db-...) and the external party (ext-edded1b16c64::...) in actAs, we provide the external party's Ed25519 signature in partySignatures. The participant should auto-sign for the operator (since it's a hosted party), but we get:

FAILED_TO_EXECUTE_TRANSACTION: The following actAs parties did not provide an external signature: 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa...

The participant is NOT auto-signing for the operator in interactive mode. And when we try executor-only (non-interactive), the DAML DvpLegAllocation c
@~huz Kindly respond to this so that we can proceed
[8:22 PM, 2/27/2026] +91 73530 98307: @~huz 
we made progress signing keys are now stored and interactive settlement is being attempted. But we're hitting one last issue:
When we do an interactive submission for Allocation_ExecuteTransfer with both the operator (8100b2db-...) and the external party (ext-edded1b16c64::...) in actAs, we provide the external party's Ed25519 signature in partySignatures. The participant should auto-sign for the operator (since it's a hosted party), but we get:

FAILED_TO_EXECUTE_TRANSACTION: The following actAs parties did not provide an external signature: 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa...

The participant is NOT auto-signing for the operator in interactive mode. And when we try executor-only (non-interactive), the DAML DvpLegAllocation c
@AHMED

Neither of the two things you're asking for will fix this. coz:

The root cause is a Canton protocol limitation documented here:
https://docs.digitalasset.com/overview/3.3/explanations/canton/external-party.html

Under Limitations it explicitly states:
"External parties, Single submitting party: Only transactions requiring authorization from a single party are supported."

Your DvpLegAllocation contract requires both the operator (internal party) AND the external party to co-authorize Allocation_ExecuteTransfer simultaneously. Canton's protocol does not support this. It doesn't matter how the operator key is hosted or shared.. the protocol will never allow an external party and a local party to co-authorize the same transaction together.

The fix requires a redesign of your DvpLegAllocation contract. The correct Canton pattern for a CLOB settlement flow is:

Step 1, External party authorizes at allocation time (single party transaction)
When the user calls AllocationFactory_Allocate, they embed their consent into the allocation contract itself by signing it as the sole authorizer. Their authorization is captured on-chain at this point.

Step 2: Operator executes alone (single party transaction)
Allocation_ExecuteTransfer is exercised by the operator only. The operator consumes the allocation contract (which already contains the external party's embedded consent from Step 1) and executes. Only operator in actAs participant auto-signs, no interactive submission needed, no external signature required at execution time.

This is the standard Canton Propose-and-Accept / Authorization pattern for multi-party workflows involving external parties. It is also the correct architecture for a CLOB at scale. you cannot require per-settlement external signatures if you want high throughput.

References:
- Canton external party limitations: https://docs.digitalasset.com/overview/3.3/explanations/canton/external-party.html
- Daml Authorization Pattern: https://docs.digitalasset.com/build/3.4/sdlc-howtos/smart-contracts/develop/patterns/authorization.html
- Daml Propose and Accept Pattern: https://docs.digitalasset.com/build/3.4/sdlc-howtos/smart-contracts/develop/patterns/propose-accept.html

The contract redesign needs to happen.
[9:53 PM, 2/27/2026] +91 79903 24401: @~huz 
we made progress signing keys are now stored and interactive settlement is being attempted. But we're hitting one last issue:
When we do an interactive submission for Allocation_ExecuteTransfer with both the operator (8100b2db-...) and the external party (ext-edded1b16c64::...) in actAs, we provide the external party's Ed25519 signature in partySignatures. The participant should auto-sign for the operator (since it's a hosted party), but we get:

FAILED_TO_EXECUTE_TRANSACTION: The following actAs parties did not provide an external signature: 8100b2db-86cf-40a1-8351-55483c151cdc::122087fa...

The participant is NOT auto-signing for the operator in interactive mode. And when we try executor-only (non-interactive), the DAML DvpLegAllocation c
As @~Srishti Suratkalüñêüèª mentioned the participant node will act as CPN and not SPN and for this reason we will need to give signature of every party present in actAs parameter.
[10:00 PM, 2/27/2026] +91 79903 24401: You can create a signature from admin api using TopologyManagerWriteService but we would advise not to use this approach, rather as mentioned by @~Srishti Suratkalüñêüèª please use a design pattern which can exercise Allocation_ExecuteTransfer with all signatories  https://docs.digitalasset.com/build/3.4/sdlc-howtos/smart-contracts/develop/patterns.html#
client said me this :
I placed order from this partyId https://devnet.ccview.io/party/ext-9da814114256::12206f8bc85eae12cbedc597ffd6cf39f1019d41ddf6f78468d2703499805f9f38ce/


If there was transfer of tokens then the balance shouldnt be 10CC


[2:20 AM, 3/1/2026] +92 327 8227842: @~AHMED
If I am not wrong ccview and all other explorer will show token standard transfers that include Amulet, and if an allocation has Amulet or CC transfer it will surely show in explorer
[2:20 AM, 3/1/2026] +92 327 8227842: As mentioned before unless you are implementing splice-api-token-holding-v1:Splice.Api.Token.HoldingV1:Holding  interface in your template other holding contracts are of no use to us
[2:20 AM, 3/1/2026] +92 327 8227842: So, at the moment there is only change of text in your Holding contract



This is the Holding contract for cbtc, no change in balance

Similarly for Amulet or CC



https://docs.sync.global/app_dev/token_standard/index.html 








 Splice
Search docs
Overview

Global Synchronizer for the Canton Network
Deployment and Operations

Overview
Validators
Supervalidators
Operations
Application Development

Overview
Version Information
Testing
Ledger API
Scan APIs
Token Standard APIs
Overview
Holding UTXO Management
Wallet integration with Token Standard Assets
API References
Splice HTTP APIs
Splice Daml APIs
Splice Daml Models
Background

Architecture
Tokenomics
Canton Coin Preapprovals
Scalability

Scalability
FAQ

FAQ
Glossary

Glossary
Release Notes

0.5.10
0.5.9
0.5.8
0.5.7
0.5.6
0.5.5
0.5.4
0.5.3
0.5.1
0.5.0
0.4.25
0.4.23
0.4.22
0.4.21
0.4.20
0.4.19
0.4.18
0.4.17
0.4.16
0.4.15
0.4.14
0.4.13
0.4.12
0.4.11
0.4.10
0.4.9
0.4.8
0.4.7
0.4.5
0.4.4
0.4.3
0.4.2
0.4.1
0.4.0
0.3.21
0.3.20
0.3.19
0.3.18
0.3.17
0.3.16
0.3.15
0.3.13
0.3.12
0.3.11
0.3.10
0.3.9
0.3.8
0.3.7
0.3.6
0.3.5
0.3.4
0.3.3
0.3.2
0.3.1
0.3.0
0.2.8
0.2.7
0.2.6
0.2.4
0.2.3
0.2.1
0.2.0
0.1.19
0.1.18
0.1.17
0.1.16
0.1.15
0.1.13
0.1.12
0.1.10
0.1.9
0.1.8
0.1.7
0.1.6
0.1.5
0.1.4
0.1.3
0.1.2
2024-04-01
2024-03-25
2024-03-18
2024-03-11
2024-03-04
2024-02-26
2024-02-19
2024-02-12
2024-02-05
2024-01-29
2024-01-22
2024-01-15
2024-01-08
2023-12-18
2023-12-11
2023-12-04
2023-11-27
2023-11-20
2023-11-13
2023-11-06
2023-10-30
2023-10-23
2023-10-16
2023-10-09
2023-10-02
2023-09-25
2023-09-11
2023-09-04
2023-08-28
2023-08-14
2023-08-07
2023-07-31
2023-07-16
2023-07-02
2023-06-25
2023-06-18
2023-06-11
2023-06-04
2023-05-28
2023-05-21
2023-05-14
2023-05-07
2023-04-30
2023-04-23
Community-Contributed

Community-Contributed Documentation
 Token Standard APIs Edit on GitHub
Token Standard APIsÔÉÅ
OverviewÔÉÅ
See the text of the CIP-0056 for an overview of the APIs that are part of the Canton Network Token Standard.

See the README in its source-code for background on how to use the APIs.

Holding UTXO ManagementÔÉÅ
Analogous to Bitcoin, Canton uses a UTXO model, where the UTXOs are all the active contracts that implement the Holding interface.

Active Holding contracts incur both storage and compute cost on the validator nodes hosting users that own Holding contracts and the validator nodes hosting the token administrator. To make efficient use of the network‚Äôs resources, we thus recommend that wallet providers aim to keep the number of UTXOs per user low, i.e, below ~10 UTXOs per user on average.

This also optimizes traffic costs, as each UTXO input to a transfer costs extra traffic. Furthermore, this recommendation aligns with the incentives put in place by tokens like Canton Coin, which:

allows at most 100 input contracts for a single transfer, and thus discourages excessive splitting of holdings

expires coin UTXOs whose initial amount is lower than the accrued holding fee, and thus discourages the creation of dust UTXOs

We recommend wallet providers to implement a UTXO management strategy that:

prefers the selection of Holding UTXOs with small amounts to provide the input holdings to fund a transfer

asks the user to setup a MergeDelegation contract (see docs) as part of wallet onboarding, which enables the wallet provider to automatically merge small Holding UTXOs on behalf of the user

Note

MergeDelegation contracts also allow wallet providers to run airdrop campaigns jointly with the auto merging of holdings using a single, batched call to airdrop and merge holdings for multiple users and multiple instruments. Furthermore, featured wallet providers earn featured app rewards for performing merges for their users.

Setting up MergeDelegationsÔÉÅ
Assuming you are a wallet provider that runs a validator node for your users, you can set up MergeDelegation contracts for your users as follows.

Extract the latest version of the splice-util-token-standard-wallet.dar file from the release bundle (Download Bundle).

Upload the extracted .dar file to your validator node.

Adjust your user onboarding procedure such that the users signs the creation of a MergeDelegationProposal contract (see docs).

Accept the MergeDelegationProposal contracts by exercising their Accept choice using your wallet provider‚Äôs party.

Using MergeDelegationsÔÉÅ
We recommend to use the MergeDelegation contracts in a batched fashion as follows.

Create a single BatchMergeUtility contract (see docs) for your wallet provider‚Äôs party as part of your validator node‚Äôs setup.

Grant your wallet provider‚Äôs user the CanReadAsAnyParty right on your validator node to allow it to read all users‚Äô Holding UTXOs.

Run a background process that regularly performs the following steps:

Determines all users that have more than 10 Holding UTXOs. For example, using the DB provided by the Participant Query Store; or by reading the Holding contracts directly from the Ledger API of your validator node. The former being the more scalable option.

Constructs the transfer choices to merge the extra Holding contracts by querying the registry API as explained in Executing a factory choice.

Lookup the MergeDelegation contract for each user and construct the corresponding call to exercise the MergeDelegation_Merge choice.

Assemble batches of ~100 merge delegation choices into a single call to the BatchMergeUtility_MergeHoldings choice.

Lookup the contract-id of the BatchMergeUtility contract that you setup above.

Execute the batched merge by exercising the BatchMergeUtility_MergeHoldings choice using your wallet provider user on your validator node. Use the Ledger API to exercise the choice and make sure that you add all disclosed contracts obtained from the previous steps to the single call.

Note that for you can execute multiple batches in parallel for higher throughput.

Optionally, you can add transfers from your operator party to the merge calls to implement airdrop campaigns in a batched fashion.

Upgrading from custom MergeDelegation implementationsÔÉÅ
Some wallet providers already implement their own custom merge delegation contracts. They can continue to use them alongside the MergeDelegation contracts provided by Splice. There is no requirement to upgrade to the Splice-provided contracts.

However, if you would like to upgrade to the Splice-provided contracts (e.g., to benefit from the additional features), then you can do so as follows.

Add a CustomMergeDelegation_Upgrade choice to your CustomMergeDelegation template that creates a MergeDelegation contract for the user. Make the choice consuming, so that the old CustomMergeDelegation contract is archived as part of exercising the upgrade choice.

Bump the version of your custom merge delegation .dar file and build a new release.

Upload the new custom-merge-delegation.dar file to your validator node.

Call the CustomMergeDelegation_Upgrade choice on all existing CustomMergeDelegation contracts to upgrade them to the Splice-provided MergeDelegation contracts

Wallet integration with Token Standard AssetsÔÉÅ
This section provides wallet developers with guidance on how to integrate with token standard assets. Such an integration works by sending the right read and write requests to the Ledger API of the validator node hosting the wallet user‚Äôs party. There are five kinds of integration patterns:

Reading contracts implementing a Token Standard interface for a party

Reading and parsing transaction history involving Token Standard contracts

Executing a factory choice

Executing a non-factory choice

Using token standard choices from custom Daml code

These integrations patterns have recently been nicely packaged in the wallet SDK maintained as part of hyperledger-labs/splice-wallet-kernel and documented here.

All of these integration patterns are also demonstrated in the form of executable code as part of the experimental command-line interface for token standard assets. The sections below explaining the patterns below thus all start with a link to the code. They then provide additional context for an implementor.

All interaction works via the JSON Ledger API (see its OpenAPI definition here). This OpenAPI definition is also accessible at http(s)://${YOUR_PARTICIPANT}/docs/openapi. We encourage developers to use OpenAPI code generation tools as opposed to manually writing HTTP requests.

Check out the Authentication docs for more information on how to authenticate the requests.

Reading contracts implementing a Token Standard interface for a partyÔÉÅ
Reference code from the Token Standard CLI to list contracts by interface

The Token Standard includes several interfaces that are implemented by Daml templates. To list all contracts implementing a particular interface, you have to query the participant‚Äôs active-contracts endpoint.

The activeAtOffset parameter can be set to the result of the ledger-end endpoint on the participant to get the latest ACS, or an older (non-pruned) one to get the ACS at that point in time.

To filter for a particular party and interface, it should include a filtersByParty with an InterfaceFilter:

{
  "filtersByParty": {
    "$A_PARTY": {
      "cumulative": [
        {
          "identifierFilter": {
            "InterfaceFilter": {
              "value": {
                "interfaceId": "$AN_INTERFACE_ID",
                "includeInterfaceView": true,
                "includeCreatedEventBlob": true
              }
            }
          }
        }
      ]
    }
  }
}
For example:

"$A_PARTY" could look like test::1220a0db3761b3fc919b55e7ff80ad740824336010bfde8829611c0e64477ab7bee5.

"$AN_INTERFACE_ID" could be #splice-api-token-holding-v1:Splice.Api.Token.HoldingV1:Holding.

Additionally, there‚Äôs three flags that can be set:

includeInterfaceView: to include the interface view of the contract in the response.

includeCreatedEventBlob: to include a binary blob that is required for explicit disclosure.

verbose: to include additional information in the response.

The response for such a query will contain the createdEvent of the contract, including the interface views requested (if any). The viewValue within it will be the JSON-serialized Daml interface view. If more than one interface is requested, you can distinguish them by checking the interfaceId field. You can find an example response for Holdings here.

Reading and parsing transaction history involving Token Standard contractsÔÉÅ
Example code: Token Standard CLI‚Äôs code to list transactions

The participant has an endpoint to list all transactions involving the provided parties and interfaces.

To filter for a particular party and interface, it should include a filtersByParty with an InterfaceFilter:

{
  "filtersByParty": {
    "$A_PARTY": {
      "cumulative": [
        {
          "identifierFilter": {
            "InterfaceFilter": {
              "value": {
                "interfaceId": "$AN_INTERFACE_ID",
                "includeInterfaceView": true,
                "includeCreatedEventBlob": true
              }
            }
          }
        }
      ]
    }
  }
}
For example:

"$A_PARTY" could look like test::1220a0db3761b3fc919b55e7ff80ad740824336010bfde8829611c0e64477ab7bee5.

"$AN_INTERFACE_ID" could be #splice-api-token-holding-v1:Splice.Api.Token.HoldingV1:Holding to read all Holding contracts of the specified party.

To include other transaction nodes that don‚Äôt directly involve the interfaces (e.g., non-interface-specific children nodes), a WildcardFilter can be included in the cumulative filter array:

{
  "identifierFilter": {
    "WildcardFilter": {
      "value": {
        "includeCreatedEventBlob": true
      }
    }
  }
}
The beginExclusive field is the offset from which to start reading transactions. To paginate, you can start with the participantPrunedUpToInclusive from GET ${PARTICIPANT_URL}/v2/state/latest-pruned-offsets and continue by passing the offset of the last transaction from the previous response.

Parsing the historyÔÉÅ
Example code: the parser here. It extracts a user-readable wallet history by parsing transactions involving the Holding and TransferInstruction interfaces.

The endpoint returns transaction trees as an array. The transactions are ordered as they occur in the ledger. Given an ExercisedEvent with nodeId=X and lastDescendantNodeId=Y, the children of that node are those with nodeId in the range [X+1, Y]. CreatedEvent and ArchivedEvent (or equivalently, ExercisedEvent where consuming=true) do not have children.

Given the above, a tree-like traversal can be performed on the transaction nodes. Generally, a Token Standard parser will focus on the exercise of Token Standard choices and creation of contracts implementing Token Standard interfaces. Where further customization is required, a parser can decide to also focus on internal/specific choices that are not available in the standard, but in some specific implementation.

In each Token Standard exercise node, one can find:

The choice being executed, useful to distinguish what operation was performed.

As part of the archival/creation of children, one can find out other relevant operations that happened. For example, creation or archival of Holdings.

Meta key/values, of which part of the standard:

splice.lfdecentralizedtrust.org/tx-kind: the kind of operation happening in the node. This can give more information than the exercised choice does. It can be one of:

transfer

merge-split

burn

mint

unlock

expire-dust

splice.lfdecentralizedtrust.org/sender: which party is the sender in the node.

splice.lfdecentralizedtrust.org/reason: a text specifying the reason for the operation in the node.

splice.lfdecentralizedtrust.org/burned: how much of a holding was burned in the node.

Warning

Meta key/values can be specified in several optional fields. For transfers, the values from fields that are present should be merged in last-write-wins order of:

event.choiceArgument.transfer.meta,

event.choiceArgument.extraArgs.meta,

event.choiceArgument.meta,

event.exerciseResult.meta,

Executing a factory choiceÔÉÅ
Example code: Token Standard CLI‚Äôs code to create a transfer via TransferFactory

To execute a choice via a Token Standard factory, first you need need to fetch the factory from the corresponding registry.

Note

The mapping from an instrument‚Äôs admin party-id to the corresponding registry URL needs to be maintained currently by wallets themselves, until a generic solution (likely based on CNS) is implemented.

The registry will return the relevant factory in the corresponding endpoint:

TransferFactory

AllocationFactory

The response‚Äôs payload will include three relevant fields:

factoryId: the contract id of the factory

disclosedContracts: must be provided to the exercise of the factory‚Äôs choice for it to work

choiceContextData: to be passed as context in the choiceArgument.

With this data, you can execute a choice on the factory. For external parties you must call the prepare and execute endpoints of the participant. For non-external parties, you can just use the submit-and-wait endpoint.

In both cases, you must include an ExerciseCommand in your payload with the following fields:

templateId: the interface id of the factory you want to exercise the choice on. For example, #splice-api-token-transfer-instruction-v1:Splice.Api.Token.TransferInstructionV1:TransferFactory.

contractId: the factoryId obtained from the registry.

choice: the name of the choice you want to execute. For example, TransferFactory_Transfer.

choiceArgument: the arguments that will be passed to the Daml choice. These will be decoded from JSON. For a TransferFactory_Transfer, this will include for example the sender, receiver and amount, among other fields.

Executing a non-factory choiceÔÉÅ
Example code: Token Standard CLI‚Äôs code to accept a transfer instruction

To execute a choice on a contract implementing a Token Standard interface for external parties, you must call the prepare and execute endpoints of the participant. For non-external parties, you can just use the submit-and-wait endpoint.

In both cases, you must include an ExerciseCommand in your payload with the following fields:

templateId: the interface id of the contract you want to exercise the choice on. For example, #splice-api-token-transfer-instruction-v1:Splice.Api.Token.TransferInstructionV1:TransferInstruction.

contractId: the contract id of the contract you want to exercise the choice on. Typically, you‚Äôll get this from the current ACS of a party.

choice: the name of the choice you want to execute. For example, TransferInstruction_Accept.

choiceArgument: the arguments that will be passed to the Daml choice. These will be decoded from JSON.

Where a context is required as part of the choiceArgument, it can be fetched from the corresponding registry:

To accept a TransferInstruction

To reject a TransferInstruction

To withdraw a TransferInstruction

To withdraw an Allocation

To cancel an Allocation

The response of these endpoints include two fields:

choiceContextData: to be passed as context in the choiceArgument.

disclosedContracts: to be passed in the submit or prepare request.

Warning

Note that AllocationRequest_Reject and AllocationRequest_Withdraw should be called with an empty choice context. This ChoiceContext is present to allow for potential future extensions of the behavior of implementations of these choices.

Using token standard choices from custom Daml codeÔÉÅ
Calling the token standard choices from custom Daml code is useful when integrating one‚Äôs own app workflows with the token standard. Example workflows relevant to a wallet provider are merging of holdings for a user to keep their ACS small, doing bulk transfers, or marking a user‚Äôs action as activity of the wallet app.

Splice releases the optional splice-util-token-standard-wallet.dar file, which packages common workflows that improve the operations of a wallet app. See its documentation below for the reference of the templates provided.

splice-util-token-standard-wallet docs
API ReferencesÔÉÅ
Refer to CIP-0056 for more context on the APIs.

Token MetadataÔÉÅ
Daml reference
OpenAPI reference
HoldingÔÉÅ
This allows implementation of a Portfolio View.

Daml reference
Transfer InstructionÔÉÅ
This allows implementation of Direct Peer-to-Peer / Free of Payment (FOP) Transfers.

Daml reference
OpenAPI reference
AllocationÔÉÅ
This allows implementation of Delivery versus Payment (DVP) Transfer Workflows, jointly with the Allocation Instruction and Allocation Request APIs below.

Daml reference
OpenAPI reference
Allocation InstructionÔÉÅ
Daml reference
OpenAPI reference
Allocation RequestÔÉÅ
Daml reference
CommentsÔÉÅ

¬© Copyright 2026, Digital Asset.

Built with Sphinx using a theme provided by Read the Docs.
