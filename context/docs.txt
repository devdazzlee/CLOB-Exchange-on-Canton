
cleint saying me this :
@AHMED In production the 200 limit will reach very soon, we need to use ledger-api or web sockets to get stream of data. Also we need to optimise the daml choices in such a way that only useful contracts are in active set and rest are archived‚Ä¶
00:08
Here's what the client is saying in simple terms:

The system has a limit problem and needs to be fixed in 3 ways:

200 Limit Issue ‚Äî The current setup can only fetch/handle 200 records at a time. In production, real data will exceed this limit very quickly, so it's not scalable.
Use Ledger API or WebSockets ‚Äî Instead of pulling data in batches (which hits that 200 limit), they want to stream data continuously in real-time using either the Ledger API or WebSockets. This way, data flows in as it's created rather than being fetched in chunks.
Optimize DAML Contracts ‚Äî In DAML (a smart contract language), the "active set" means contracts that are currently open/active. The client wants you to clean this up so that:
Only useful/relevant contracts stay active
Unnecessary contracts get archived (closed/removed from active state)
This reduces clutter and improves performance
Bottom line: The current approach won't handle production load. They need real-time data streaming and cleaner contract management in DAML before going live.

tell me links of docs what should i use tell me\

00:08
Let me search for the relevant documentation for you.


Searched the web
Searched the web


Here are all the relevant documentation links you need for each part of what the client requested:

1. üì° Ledger API (main entry point) https://docs.daml.com/app-dev/ledger-api.html

2. üîß Ledger API Services (Transaction Service, Active Contracts Service, etc.) https://docs.daml.com/app-dev/services.html

3. üìã Ledger API Reference (Protobuf / gRPC details) https://docs.daml.com/app-dev/grpc/proto-docs.html

4. üåê HTTP JSON API + WebSocket Streaming (most relevant for WebSocket part) https://docs.daml.com/json-api/index.html

Which section to focus on inside the JSON API doc:

Inside the JSON API doc, look specifically for:

/v1/stream/query ‚Üí this is the WebSocket endpoint to stream active contracts in real-time (replaces the polling with 200 limit)
/v1/query ‚Üí the regular REST endpoint (the one hitting the 200 limit currently)
5. üì¶ @daml/ledger (JavaScript/TypeScript client library) https://www.npmjs.com/package/@daml/ledger

Quick Summary of what to read:

What to solve	Where to read
Replace 200 limit with streaming	JSON API docs ‚Üí /v1/stream/query (WebSocket)
Lower-level gRPC streaming	Ledger API Services ‚Üí Transaction Service
Archiving unused contracts in DAML	Ledger API Services ‚Üí Active Contracts Service
JS/TS client for ledger	@daml/ledger on npm
please check docs in detial deep then tell me cleint requiremnt is this psosibnle

00:13
Let me deep dive into the DAML documentation for you.


Searched the web
Searched the web


Great, I now have deep information from the official DAML docs. Here is a full breakdown:

‚úÖ YES ‚Äî The Client's Requirements Are 100% Possible
Here's what the docs confirm, point by point:

1. üî¥ Problem: 200 Contract Limit
The current /v1/query REST endpoint has a pagination limit. In production with thousands of contracts, this breaks. The docs confirm this is a known limitation of the basic REST API.

2. ‚úÖ Solution: WebSocket Streaming via /v1/stream/query
The DAML docs explicitly confirm this endpoint exists for exactly this purpose.

How it works: Instead of fetching 200 contracts at a time, you open a WebSocket connection and DAML streams all active contracts to you in real-time ‚Äî including new creations and archivals as they happen.

Endpoint: ws://your-host/v1/stream/query

Doc link: üëâ https://docs.daml.com/json-api/index.html (scroll to "WebSocket" section)

3. ‚úÖ Solution: Ledger API (gRPC) for Advanced Streaming
For even more control (lower level), the Ledger API via gRPC supports streaming transaction data directly with no limits. This is more powerful but more complex to implement.

Doc link: üëâ https://docs.daml.com/app-dev/ledger-api.html

4. ‚úÖ Solution: Archive Unused Contracts to Keep ACS Small
The DAML docs have an entire dedicated page on this exact topic ‚Äî "Managing Active Contract Set (ACS) Size."

The docs confirm that a large ACS (too many active contracts) directly causes:

Slower query performance
Higher database load
Increased latency
How to fix it in DAML code: Use consuming choices ‚Äî when a choice is exercised it automatically archives the contract:

daml
choice CloseContract : ()
  controller owner
  do
    return () -- contract is automatically archived (consuming by default)
Any contract that is no longer needed ‚Üí exercise a consuming choice on it ‚Üí it gets removed from the active set.

Doc links: üëâ https://docs.daml.com/daml/resource-management/active-contract-set.html (ACS size management) üëâ https://docs.daml.com/daml/reference/choices.html (consuming vs nonconsuming choices)

üìã Summary Table
Client Requirement	Possible?	Solution	Doc Link
Fix 200 limit	‚úÖ Yes	Use WebSocket /v1/stream/query	docs.daml.com/json-api
Stream data in real-time	‚úÖ Yes	WebSocket or Ledger API gRPC	docs.daml.com/app-dev/ledger-api
Archive unused contracts	‚úÖ Yes	Consuming choices in DAML templates	docs.daml.com/daml/resource-management/active-contract-set
Keep only useful active contracts	‚úÖ Yes	Design choices to archive after workflow completes	docs.daml.com/daml/reference/choices
Bottom line for your client: Everything they asked for is fully supported by DAML. The WebSocket streaming directly replaces the 200-limit polling, and the ACS cleanup is a DAML template design change.

tell me docs what api i need to use

00:37

Searched the web
Searched the web

Okay, I've read the official DAML docs deeply. Here is everything clearly:

üîó Exact APIs & Doc Links You Need
‚úÖ API 1 ‚Äî WebSocket Stream (Easiest Fix for 200 Limit)
Endpoint: ws://your-host/v1/stream/query

This is confirmed in the docs ‚Äî the websocket endpoint /v1/stream/query can be used in place of iteratively invoking the REST endpoint to respond to changes on the ledger. 
Daml
 This directly replaces the 200-limit REST call.

üìÑ Doc Link: üëâ https://docs.daml.com/json-api/index.html (scroll to WebSocket section)

‚úÖ API 2 ‚Äî Active Contracts Service (Ledger API)
For getting the current active set without re-reading from the beginning. Use the active contracts service to quickly bootstrap an application with the currently active contracts ‚Äî it saves you the work of processing the ledger from the beginning to obtain its current state. 
Daml

üìÑ Doc Link: üëâ https://docs.daml.com/app-dev/services.html

‚úÖ API 3 ‚Äî Transaction Service (Real-time Streaming via gRPC)
Use the transaction service to listen to changes in the ledger state, reported via a stream of transactions ‚Äî it contains all events (create, exercise, archive of contracts) that had an effect in that transaction. 
Daml

üìÑ Doc Link: üëâ https://docs.daml.com/app-dev/services.html (scroll to Transaction Service)

‚úÖ API 4 ‚Äî @daml/ledger (TypeScript/JS ‚Äî if you're using frontend)
The docs confirm: an instance of the Ledger class provides methods including streamQueries ‚Äî and notably the query method is deprecated in favor of streamQueries. 
Daml

üìÑ Doc Link: üëâ https://docs.daml.com/app-dev/bindings-ts/daml-ledger/index.html

üìã Quick Decision Table ‚Äî Which API to Use?
Your Stack	API to Use	Doc Link
Frontend JS/TS	@daml/ledger ‚Üí streamQueries()	bindings-ts/daml-ledger
Backend (any lang)	HTTP JSON API WebSocket /v1/stream/query	docs.daml.com/json-api
Java Backend	Ledger API gRPC ‚Üí Transaction Service	docs.daml.com/app-dev/services.html
Python Backend	DAZL (Python Bindings)	docs.daml.com/app-dev/ledger-api.html
‚ö†Ô∏è Important Note from Docs
The JSON API provides a significantly simpler way to interact with a ledger than the Ledger API ‚Äî but for advanced features, use the Ledger API instead. 
npm

So: Start with WebSocket JSON API ‚Üí if you need more control, move to gRPC Ledger API.




Daml Documentation
Home

Set Up Your Developer Environment

Tutorial: Write Your First Daml App

Create Daml Apps

Important Considerations When Building Applications With Daml
Write Smart Contracts with Daml
Integrate Daml with Off-Ledger Services
Build Applications
Daml Application Architecture
Parties and Users On a Daml Ledger
Access Active Contracts with the HTTP JSON API Service
Build Integration with the Ledger API
What‚Äôs in the Ledger API
How to Access the Ledger API
Daml-LF
The Ledger API Services
Java Bindings
Python Bindings
Use the Ledger API With gRPC
Ledger API Reference
How Daml Types are Translated to Protobuf
How Daml Types are Translated to Daml-LF
Create Your Own Bindings
Write Off-Ledger Automation Using Daml
Handle Errors
Authorization
Explicit Contract Disclosure
Resource Management in Daml Application Design
Upgrading and Extending Daml Applications
Developer Tools
Daml Finance

Deploy Daml

Operate a Daml Ledger

Help

Reference

Early Access

Download as PDF

Developers
Products
Company
Version 
Search

In This Section
Build Integration with the Ledger API
What‚Äôs in the Ledger API
How to Access the Ledger API
Daml-LF
When You Need to Know About Daml-LF
Build Integration with the Ledger API
To write an application around a Daml ledger, you will need to interact with the Ledger API.

Every ledger that Daml can run on exposes this same API.

What‚Äôs in the Ledger API
The Ledger API exposes the following services:

Submitting commands to the ledger
Use the command submission service to submit commands (create a contract or exercise a choice) to the ledger.
Use the command completion service to track the status of submitted commands.
Use the command service for a convenient service that combines the command submission and completion services.
Reading from the ledger
Use the transaction service to stream committed transactions and the resulting events (choices exercised, and contracts created or archived), and to look up transactions.
Use the active contracts service to quickly bootstrap an application with the currently active contracts. It saves you the work to process the ledger from the beginning to obtain its current state.
Utility services
Use the party management service to allocate and find information about parties on the Daml ledger.
Use the package service to query the Daml packages deployed to the ledger.
Use the ledger identity service to retrieve the Ledger ID of the ledger the application is connected to.
Use the ledger configuration service to retrieve some dynamic properties of the ledger, like maximum deduplication duration for commands.
Use the version service to retrieve information about the Ledger API version.
Use the user management service to manage users and their rights.
Use the metering report service to retrieve a participant metering report.
Testing services (on Sandbox only, not for production ledgers)
Use the time service to obtain the time as known by the ledger.
For full information on the services see The Ledger API Services.

You may also want to read the protobuf documentation, which explains how each service is defined as protobuf messages.

How to Access the Ledger API
You can access the Ledger API via the Java Bindings or the Python Bindings (formerly known as DAZL).

If you don‚Äôt use a language that targets the JVM or Python, you can use gRPC to generate the code to access the Ledger API in several supported programming languages. Further documentation provides a few pointers on how you may want to approach this.

You can also use the HTTP JSON API Service to tap into the Ledger API.

At its core, this service provides a simplified view of the active contract set and additional primitives to query it and exposing it using a well-defined JSON-based encoding over a conventional HTTP connection.

A subset of the services mentioned above is also available as part of the HTTP JSON API.

Daml-LF
When you compile Daml source into a .dar file, the underlying format is Daml-LF. Daml-LF is similar to Daml, but is stripped down to a core set of features. The relationship between the surface Daml syntax and Daml-LF is loosely similar to that between Java and JVM bytecode.

As a user, you don‚Äôt need to interact with Daml-LF directly. But internally, it‚Äôs used for:

Executing Daml code on the Sandbox or on another platform
Sending and receiving values via the Ledger API (using a protocol such as gRPC)
Generating code in other languages for interacting with Daml models (often called ‚Äúcodegen‚Äù)
When You Need to Know About Daml-LF
Daml-LF is only really relevant when you‚Äôre dealing with the objects you send to or receive from the ledger. If you use any of the provided language bindings for the Ledger API, you don‚Äôt need to know about Daml-LF at all, because this generates idiomatic representations of Daml for you.

Otherwise, it can be helpful to know what the types in your Daml code look like at the Daml-LF level, so you know what to expect from the Ledger API.

For example, if you are writing an application that creates some Daml contracts, you need to construct values to pass as parameters to the contract. These values are determined by the Daml-LF types in that contract template. This means you need an idea of how the Daml-LF types correspond to the types in the original Daml model.

For the most part the translation of types from Daml to Daml-LF should not be surprising. This page goes through all the cases in detail.

For the bindings to your specific programming language, you should refer to the language-specific documentation.

Previous Next
Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved. Any unauthorized use, duplication or distribution is strictly prohibited. "Digital Asset" and "Daml" are Registered in the U.S. Patent and Trademark Office.

Daml Documentation
Home

Set Up Your Developer Environment

Tutorial: Write Your First Daml App

Create Daml Apps

Important Considerations When Building Applications With Daml
Write Smart Contracts with Daml
Integrate Daml with Off-Ledger Services
Build Applications
Daml Application Architecture
Parties and Users On a Daml Ledger
Access Active Contracts with the HTTP JSON API Service
Build Integration with the Ledger API
What‚Äôs in the Ledger API
How to Access the Ledger API
Daml-LF
The Ledger API Services
Overview
Submit Commands to the Ledger
Read From the Ledger
Utility Services
Testing Services
Java Bindings
Python Bindings
Use the Ledger API With gRPC
Ledger API Reference
How Daml Types are Translated to Protobuf
How Daml Types are Translated to Daml-LF
Create Your Own Bindings
Write Off-Ledger Automation Using Daml
Handle Errors
Authorization
Explicit Contract Disclosure
Resource Management in Daml Application Design
Upgrading and Extending Daml Applications
Developer Tools
Daml Finance

Deploy Daml

Operate a Daml Ledger

Help

Reference

Early Access

Download as PDF

Developers
Products
Company
Version 
Search

In This Section
The Ledger API Services
Overview
Glossary
Submit Commands to the Ledger
Command Submission Service
Change ID
Application-specific IDs
Command Deduplication
Explicit contract disclosure (experimental)
Command Completion Service
Command Service
Read From the Ledger
Transaction Service
Transaction and transaction Trees
Verbosity
Transaction Filter
Active Contracts Service
Verbosity
Transaction Filter
Event Query Service
Utility Services
Party Management Service
User Management Service
Identity Provider Config Service
Package Service
Ledger Identity Service (DEPRECATED)
Ledger Configuration Service
Version Service
Pruning Service
Metering Report Service
Testing Services
Time Service
The Ledger API Services
The Ledger API is structured as a set of services. The core services are implemented using gRPC and Protobuf, but most applications access this API through the mediation of the language bindings.

This page gives more detail about each of the services in the API, and will be relevant whichever way you‚Äôre accessing it.

If you want to read low-level detail about each service, see the protobuf documentation of the API.

Overview
The API is structured as two separate data streams:

A stream of commands TO the ledger that allow an application to submit transactions and change state.
A stream of transactions and corresponding events FROM the ledger that indicate all state changes that have taken place on the ledger.
Commands are the only way an application can cause the state of the ledger to change, and events are the only mechanism to read those changes.

For an application, the most important consequence of these architectural decisions and implementation is that the Ledger API is asynchronous. This means:

The outcome of commands is only known some time after they are submitted.
The application must deal with successful and erroneous command completions separately from command submission.
Ledger state changes are indicated by events received asynchronously from the command submissions that cause them.
The need to handle these issues is a major determinant of application architecture. Understanding the consequences of the API characteristics is important for a successful application design.

For more help understanding these issues so you can build correct, performant and maintainable applications, read the application architecture guide.

Glossary
The ledger is a list of transactions. The transaction service returns these.
A transaction is a tree of actions, also called events, which are of type create, exercise or archive. The transaction service can return the whole tree, or a flattened list.
A submission is a proposed transaction, consisting of a list of commands, which correspond to the top-level actions in that transaction.
A completion indicates the success or failure of a submission.
Submit Commands to the Ledger
Command Submission Service
Use the command submission service to submit commands to the ledger. Commands either create a new contract, or exercise a choice on an existing contract.

A call to the command submission service will return as soon as the ledger server has parsed the command, and has either accepted or rejected it. This does not mean the command has been executed, only that the server has looked at the command and decided that its format is acceptable, or has rejected it for syntactic or content reasons.

The on-ledger effect of the command execution will be reported via the transaction service, described below. The completion status of the command is reported via the command completion service. Your application should receive completions, correlate them with command submission, and handle errors and failed commands. Alternatively, you can use the command service, which conveniently wraps the command submission and completion services.

Change ID
Each intended ledger change is identified by its change ID, consisting of the following three components:

The submitting parties, i.e., the union of party and act_as
the application ID
The command ID
Application-specific IDs
The following application-specific IDs, all of which are included in completion events, can be set in commands:

A submission ID, returned to the submitting application only. It may be used to correlate specific submissions to specific completions.
A command ID, returned to the submitting application only; it can be used to correlate commands to completions.
A workflow ID, returned as part of the resulting transaction to all applications receiving it. It can be used to track workflows between parties, consisting of several transactions.
For full details, see the proto documentation for the service.

Command Deduplication
The command submission service deduplicates submitted commands based on their change ID.

Applications can provide a deduplication period for each command. If this parameter is not set, the default maximum deduplication duration is used.
A command submission is considered a duplicate submission if the Ledger API server is aware of another command within the deduplication period and with the same change ID.
A command resubmission will generate a rejection until the original submission was rejected (i.e. the command failed and resulted in a rejected transaction) or until the effective deduplication period has elapsed since the completion of the original command, whichever comes first.
Command deduplication is only guaranteed to work if all commands are submitted to the same participant. Ledgers are free to perform additional command deduplication across participants. Consult the respective ledger‚Äôs manual for more details.
For details on how to use command deduplication, see the Command Deduplication Guide.

Explicit contract disclosure (experimental)
Starting with Canton 2.7, Ledger API clients can use explicit contract disclosure to submit commands with attached disclosed contracts received from third parties. For more details, see Explicit contract disclosure.

Command Completion Service
Use the command completion service to find out the completion status of commands you have submitted.

Completions contain the command ID of the completed command, and the completion status of the command. This status indicates failure or success, and your application should use it to update what it knows about commands in flight, and implement any application-specific error recovery.

For full details, see the proto documentation for the service.

Command Service
Use the command service when you want to submit a command and wait for it to be executed. This service is similar to the command submission service, but also receives completions and waits until it knows whether or not the submitted command has completed. It returns the completion status of the command execution.

You can use either the command or command submission services to submit commands to effect a ledger change. The command service is useful for simple applications, as it handles a basic form of coordination between command submission and completion, correlating submissions with completions, and returning a success or failure status. This allow simple applications to be completely stateless, and alleviates the need for them to track command submissions.

For full details, see the proto documentation for the service.

Read From the Ledger
Transaction Service
Use the transaction service to listen to changes in the ledger state, reported via a stream of transactions.

Transactions detail the changes on the ledger, and contains all the events (create, exercise, archive of contracts) that had an effect in that transaction.

Transactions contain a transaction ID (assigned by the server), the workflow ID, the command ID, and the events in the transaction.

Subscribe to the transaction service to read events from an arbitrary point on the ledger. This arbitrary point is specified by the ledger offset. This is important when starting or restarting and application, and to work in conjunction with the active contracts service.

For full details, see the proto documentation for the service.

Transaction and transaction Trees
TransactionService offers several different subscriptions. The most commonly used is GetTransactions. If you need more details, you can use GetTransactionTrees instead, which returns transactions as flattened trees, represented as a map of event IDs to events and a list of root event IDs.

Verbosity
The service works in a non-verbose mode by default, which means that some identifiers are omitted:

Record IDs
Record field labels
Variant IDs
You can get these included in requests related to Transactions by setting the verbose field in message GetTransactionsRequest or GetActiveContractsRequest to true.

Transaction Filter
TransactionService offers transaction subscriptions filtered by templates and interfaces using GetTransactions calls. A transaction filter in GetTransactionsRequest allows:

filtering by a party, when the inclusive field is left empty
filtering by a party and template ID
filtering by a party and interface ID
exposing an interface view, when the include_interface_view is set to true
exposing a created event blob to be used for a disclosed contract in command submission when include_created_event_blob is set to true in either TemplateFilter or InterfaceFilter
Note

The template_ids field is deprecated as of Canton 2.8.0 and will be removed in future releases. Use template_filter instead.

Active Contracts Service
Use the active contracts service to obtain a party-specific view of all contracts that are active on the ledger at the time of the request.

The active contracts service returns its response as a stream of batches of the created events that would re-create the state being reported (the size of these batches is left to the ledger implementation). As part of the last message, the offset at which the reported active contract set was valid is included. This offset can be used to subscribe to the ‚Äúflat transactions‚Äù stream to keep a consistent view of the active contract set without querying the active contract service further.

This is most important at application start, if the application needs to synchronize its initial state with a known view of the ledger. Without this service, the only way to do this would be to read the Transaction Stream from the beginning of the ledger, which can be prohibitively expensive with a large ledger.

For full details, see the proto documentation for the service.

Verbosity
See Verbosity above.

Transaction Filter
See Transaction Filter above.

Note

The RPCs exposed as part of the transaction and active contracts services make use of offsets.

An offset is an opaque string of bytes assigned by the participant to each transaction as they are received from the ledger. Two offsets returned by the same participant are guaranteed to be lexicographically ordered: while interacting with a single participant, the offset of two transactions can be compared to tell which was committed earlier. The state of a ledger (i.e. the set of active contracts) as exposed by the Ledger API is valid at a specific offset, which is why the last message your application receives when calling the ActiveContractsService is precisely that offset. In this way, the client can keep track of the relevant state without needing to invoke the ActiveContractsService again, by starting to read transactions from the given offset.

Offsets are also useful to perform crash recovery and failover as documented more in depth in the application architecture page.

You can read more about offsets in the protobuf documentation of the API.

Event Query Service
Use the event query service to obtain a party-specific view of contract events.

The gRPC API provides ledger streams to off-ledger components that maintain a queryable state. This service allows you to make simple event queries without off-ledger components like the JSON API.

Using the Event Query Service, you can create, retrieve, and archive events associated with a contract ID or contract key. The API returns only those events where at least one of the requesting parties is a stakeholder of the contract. If the contract is still active, the archive_event is unset.

Contract keys can be used by multiple contracts over time. The latest contract events are returned first. To access earlier contract key events, use the continuation_token returned in the GetEventsByContractKeyResponse in a subsequent GetEventsByContractKeyRequest.

If no events match the request criteria or the requested events are not visible to the requesting parties, an empty structure is returned. Events associated with consumed contracts are returned until they are pruned.

Note

When querying by contract key, the key value must be structured in the same way as the key returned in the create event.

For full details, see the proto documentation for the service.

Utility Services
Party Management Service
Use the party management service to allocate parties on the ledger, update party properties local to the participant and retrieve information about allocated parties.

Parties govern on-ledger access control as per Daml‚Äôs privacy model and authorization rules. Applications and their operators are expected to allocate and use parties to manage on-ledger access control as per their business requirements.

For more information, refer to the pages on Identity Management and the API reference documentation.

User Management Service
Use the user management service to manage the set of users on a participant node and their access rights to that node‚Äôs Ledger API services and as the integration point for your organization‚Äôs IAM (Identity and Access Management) framework.

Daml 2.0 introduced the concept of the user in Daml. While a party represents a single individual with a single set of rights and is universal across participant nodes, a user is local to a specific participant node. Each user is typically associated with a primary party and is given the right to act as or read as other parties. Every participant node will maintain its own mapping from its user ids to the parties that they can act and/or read as. Also, when used, the user‚Äôs ids will serve as application ids. Thus, participant users can be used to manage the permissions of Daml applications (i.e. to authorize applications to read as or act as certain parties). Unlike a JWT token-based system, the user management system does not limit the number of parties that the user can act or read as.

The relation between a participant node‚Äôs users and Daml parties is best understood by analogy to classical databases: a participant node‚Äôs users are analogous to database users while Daml parties are analogous to database roles. Further, the rights granted to a user are analogous to the user‚Äôs assigned database roles.

For more information, consult the the API reference documentation for how to list, create, update, and delete users and their rights. See the UserManagementFeature descriptor to learn about the limits of the user management service, e.g., the maximum number of rights per user. The feature descriptor can be retrieved using the Version service.

With user management enabled you can use both new user-based and old custom Daml authorization tokens. Consult the Authorization documentation to understand how Ledger API requests are authorized, and how to use user management to dynamically change an application‚Äôs rights.

User management is available in Canton-enabled drivers and not yet available in the Daml for VMware Blockchain driver.

Identity Provider Config Service
Use identity provider config service to define and manage the parameters of an external IDP systems configured to issue tokens for a participant node.

The identity provider config service makes it possible for participant node administrators to set up and manage additional identity providers at runtime. This allows using access tokens from identity providers unknown at deployment time. When an identity provider is configured, independent IDP administrators can manage their own set of parties and users.

Such parties and users have a matching identity_provider_id defined and are inaccessible to administrators from other identity providers. A user will only be authenticated if the corresponding JWT token is issued by the appropriate identity provider. Users and parties without identity_provider_id defined are assumed to be using the default identity provider, which is configured statically when the participant node is deployed.

For full details, see the proto documentation for the service.

Package Service
Use the package service to obtain information about Daml packages available on the ledger.

This is useful for obtaining type and metadata information that allow you to interpret event data in a more useful way.

For full details, see the proto documentation for the service.

Ledger Identity Service (DEPRECATED)
Use the ledger identity service to get the identity string of the ledger that your application is connected to.

Including identity string is optional for all Ledger API requests. If you include it, commands with an incorrect identity string will be rejected.

For full details, see the proto documentation for the service.

Ledger Configuration Service
Use the ledger configuration service to subscribe to changes in ledger configuration.

This configuration includes the maximum command deduplication period (see Command Deduplication for details).

For full details, see the proto documentation for the service.

Version Service
Use the version service to retrieve information about the Ledger API version and what optional features are supported by the ledger server.

For full details, see the proto documentation for the service.

Pruning Service
Use the pruning service to prune archived contracts and transactions before or at a given offset.

For full details, see the proto documentation for the service.

Metering Report Service
Use the metering report service to retrieve a participant metering report.

For full details, see the proto documentation for the service.

Testing Services
These are only for use for testing with the Sandbox, not for on production ledgers.

Time Service
Use the time service to obtain the time as known by the ledger server.

For full details, see the proto documentation for the service.

Previous Next
Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved. Any unauthorized use, duplication or distribution is strictly prohibited. "Digital Asset" and "Daml" are Registered in the U.S. Patent and Trademark Office.

Daml Documentation
Home

Set Up Your Developer Environment

Tutorial: Write Your First Daml App

Create Daml Apps

Important Considerations When Building Applications With Daml
Write Smart Contracts with Daml
Integrate Daml with Off-Ledger Services
Build Applications
Daml Application Architecture
Parties and Users On a Daml Ledger
Access Active Contracts with the HTTP JSON API Service
Build Integration with the Ledger API
What‚Äôs in the Ledger API
How to Access the Ledger API
Daml-LF
The Ledger API Services
Java Bindings
Python Bindings
Use the Ledger API With gRPC
Ledger API Reference
ActiveContractsService, v1
CommandInspectionService, v1/admin
ConfigManagementService, v1/admin
IdentityProviderConfigService, v1/admin
MeteringReportService, v1/admin
PackageManagementService, v1/admin
ParticipantPruningService, v1/admin
PartyManagementService, v1/admin
UserManagementService, v1/admin
CommandCompletionService, v1
CommandService, v1
CommandSubmissionService, v1
EventQueryService, v1
LedgerConfigurationService, v1
LedgerIdentityService, v1
PackageService, v1
TimeService, v1/testing
TransactionService, v1
VersionService, v1
CommandCompletionService, v2
CommandService, v2
CommandSubmissionService, v2
EventQueryService, v2
PackageService, v2
StateService, v2
TimeService, v2/testing
UpdateService, v2
VersionService, v2
Scalar Value Types
How Daml Types are Translated to Protobuf
How Daml Types are Translated to Daml-LF
Create Your Own Bindings
Write Off-Ledger Automation Using Daml
Handle Errors
Authorization
Explicit Contract Disclosure
Resource Management in Daml Application Design
Upgrading and Extending Daml Applications
Developer Tools
Daml Finance

Deploy Daml

Operate a Daml Ledger

Help

Reference

Early Access

Download as PDF

Developers
Products
Company
Version 
Search

In This Section
Ledger API Reference
ActiveContractsService, v1
GetActiveContracts method, v1
GetActiveContractsRequest message, v1
GetActiveContractsResponse message, v1
CommandInspectionService, v1/admin
GetCommandStatus method, v1/admin
GetCommandStatusRequest message, v1/admin
GetCommandStatusResponse message, v1/admin
GetCommandStatusResponse.CommandStatus message, v1/admin
GetCommandStatusResponse.CommandStatus.CommandUpdates message, v1/admin
GetCommandStatusResponse.CommandStatus.CommandUpdates.Contract message, v1/admin
GetCommandStatusResponse.CommandStatus.RequestStatistics message, v1/admin
CommandState enum, v1/admin
ConfigManagementService, v1/admin
GetTimeModel method, v1/admin
SetTimeModel method, v1/admin
GetTimeModelRequest message, v1/admin
GetTimeModelResponse message, v1/admin
SetTimeModelRequest message, v1/admin
SetTimeModelResponse message, v1/admin
TimeModel message, v1/admin
IdentityProviderConfigService, v1/admin
CreateIdentityProviderConfig method, v1/admin
GetIdentityProviderConfig method, v1/admin
UpdateIdentityProviderConfig method, v1/admin
ListIdentityProviderConfigs method, v1/admin
DeleteIdentityProviderConfig method, v1/admin
CreateIdentityProviderConfigRequest message, v1/admin
CreateIdentityProviderConfigResponse message, v1/admin
DeleteIdentityProviderConfigRequest message, v1/admin
DeleteIdentityProviderConfigResponse message, v1/admin
GetIdentityProviderConfigRequest message, v1/admin
GetIdentityProviderConfigResponse message, v1/admin
IdentityProviderConfig message, v1/admin
ListIdentityProviderConfigsRequest message, v1/admin
ListIdentityProviderConfigsResponse message, v1/admin
UpdateIdentityProviderConfigRequest message, v1/admin
UpdateIdentityProviderConfigResponse message, v1/admin
MeteringReportService, v1/admin
GetMeteringReport method, v1/admin
GetMeteringReportRequest message, v1/admin
GetMeteringReportResponse message, v1/admin
ObjectMeta message, v1/admin
ObjectMeta.AnnotationsEntry message, v1/admin
PackageManagementService, v1/admin
ListKnownPackages method, v1/admin
UploadDarFile method, v1/admin
ValidateDarFile method, v1/admin
ListKnownPackagesRequest message, v1/admin
ListKnownPackagesResponse message, v1/admin
PackageDetails message, v1/admin
UploadDarFileRequest message, v1/admin
UploadDarFileResponse message, v1/admin
ValidateDarFileRequest message, v1/admin
ValidateDarFileResponse message, v1/admin
ParticipantPruningService, v1/admin
Prune method, v1/admin
PruneRequest message, v1/admin
PruneResponse message, v1/admin
PartyManagementService, v1/admin
GetParticipantId method, v1/admin
GetParties method, v1/admin
ListKnownParties method, v1/admin
AllocateParty method, v1/admin
UpdatePartyDetails method, v1/admin
UpdatePartyIdentityProviderId method, v1/admin
AllocatePartyRequest message, v1/admin
AllocatePartyResponse message, v1/admin
GetParticipantIdRequest message, v1/admin
GetParticipantIdResponse message, v1/admin
GetPartiesRequest message, v1/admin
GetPartiesResponse message, v1/admin
ListKnownPartiesRequest message, v1/admin
ListKnownPartiesResponse message, v1/admin
PartyDetails message, v1/admin
UpdatePartyDetailsRequest message, v1/admin
UpdatePartyDetailsResponse message, v1/admin
UpdatePartyIdentityProviderRequest message, v1/admin
UpdatePartyIdentityProviderResponse message, v1/admin
UserManagementService, v1/admin
CreateUser method, v1/admin
GetUser method, v1/admin
UpdateUser method, v1/admin
DeleteUser method, v1/admin
ListUsers method, v1/admin
GrantUserRights method, v1/admin
RevokeUserRights method, v1/admin
ListUserRights method, v1/admin
UpdateUserIdentityProviderId method, v1/admin
CreateUserRequest message, v1/admin
CreateUserResponse message, v1/admin
DeleteUserRequest message, v1/admin
DeleteUserResponse message, v1/admin
GetUserRequest message, v1/admin
GetUserResponse message, v1/admin
GrantUserRightsRequest message, v1/admin
GrantUserRightsResponse message, v1/admin
ListUserRightsRequest message, v1/admin
ListUserRightsResponse message, v1/admin
ListUsersRequest message, v1/admin
ListUsersResponse message, v1/admin
RevokeUserRightsRequest message, v1/admin
RevokeUserRightsResponse message, v1/admin
Right message, v1/admin
Right.CanActAs message, v1/admin
Right.CanReadAs message, v1/admin
Right.IdentityProviderAdmin message, v1/admin
Right.ParticipantAdmin message, v1/admin
UpdateUserIdentityProviderRequest message, v1/admin
UpdateUserIdentityProviderResponse message, v1/admin
UpdateUserRequest message, v1/admin
UpdateUserResponse message, v1/admin
User message, v1/admin
CommandCompletionService, v1
CompletionStream method, v1
CompletionEnd method, v1
Checkpoint message, v1
CompletionEndRequest message, v1
CompletionEndResponse message, v1
CompletionStreamRequest message, v1
CompletionStreamResponse message, v1
CommandService, v1
SubmitAndWait method, v1
SubmitAndWaitForTransactionId method, v1
SubmitAndWaitForTransaction method, v1
SubmitAndWaitForTransactionTree method, v1
SubmitAndWaitForTransactionIdResponse message, v1
SubmitAndWaitForTransactionResponse message, v1
SubmitAndWaitForTransactionTreeResponse message, v1
SubmitAndWaitRequest message, v1
CommandSubmissionService, v1
Submit method, v1
SubmitRequest message, v1
Command message, v1
Commands message, v1
CreateAndExerciseCommand message, v1
CreateCommand message, v1
DisclosedContract message, v1
ExerciseByKeyCommand message, v1
ExerciseCommand message, v1
PrefetchContractKey message, v1
Completion message, v1
ContractMetadata message, v1
ArchivedEvent message, v1
CreatedEvent message, v1
Event message, v1
ExercisedEvent message, v1
InterfaceView message, v1
EventQueryService, v1
GetEventsByContractId method, v1
GetEventsByContractKey method, v1
GetEventsByContractIdRequest message, v1
GetEventsByContractIdResponse message, v1
GetEventsByContractKeyRequest message, v1
GetEventsByContractKeyResponse message, v1
AcsActiveAtOffsetFeature message, v1
CommandDeduplicationFeatures message, v1
CommandDeduplicationPeriodSupport message, v1
ExperimentalCommandInspectionService message, v1
ExperimentalCommitterEventLog message, v1
ExperimentalContractIds message, v1
ExperimentalExplicitDisclosure message, v1
ExperimentalFeatures message, v1
ExperimentalOptionalLedgerId message, v1
ExperimentalSelfServiceErrorCodes message, v1
ExperimentalStaticTime message, v1
ExperimentalUserAndPartyLocalMetadataExtensions message, v1
StreamingPrunedOffsets message, v1
TransactionsWithTemplateFilters message, v1
CommandDeduplicationPeriodSupport.DurationSupport enum, v1
CommandDeduplicationPeriodSupport.OffsetSupport enum, v1
CommandDeduplicationType enum, v1
ExperimentalCommitterEventLog.CommitterEventLogType enum, v1
ExperimentalContractIds.ContractIdV1Support enum, v1
LedgerConfigurationService, v1
GetLedgerConfiguration method, v1
GetLedgerConfigurationRequest message, v1
GetLedgerConfigurationResponse message, v1
LedgerConfiguration message, v1
LedgerIdentityService, v1
GetLedgerIdentity method, v1
GetLedgerIdentityRequest message, v1
GetLedgerIdentityResponse message, v1
LedgerOffset message, v1
LedgerOffset.LedgerBoundary enum, v1
PackageService, v1
ListPackages method, v1
GetPackage method, v1
GetPackageStatus method, v1
GetPackageRequest message, v1
GetPackageResponse message, v1
GetPackageStatusRequest message, v1
GetPackageStatusResponse message, v1
ListPackagesRequest message, v1
ListPackagesResponse message, v1
HashFunction enum, v1
PackageStatus enum, v1
TimeService, v1/testing
GetTime method, v1/testing
SetTime method, v1/testing
GetTimeRequest message, v1/testing
GetTimeResponse message, v1/testing
SetTimeRequest message, v1/testing
TraceContext message, v1
Transaction message, v1
TransactionTree message, v1
TransactionTree.EventsByIdEntry message, v1
TreeEvent message, v1
Filters message, v1
InclusiveFilters message, v1
InterfaceFilter message, v1
TemplateFilter message, v1
TransactionFilter message, v1
TransactionFilter.FiltersByPartyEntry message, v1
TransactionService, v1
GetTransactions method, v1
GetTransactionTrees method, v1
GetTransactionByEventId method, v1
GetTransactionById method, v1
GetFlatTransactionByEventId method, v1
GetFlatTransactionById method, v1
GetLedgerEnd method, v1
GetLatestPrunedOffsets method, v1
GetFlatTransactionResponse message, v1
GetLatestPrunedOffsetsRequest message, v1
GetLatestPrunedOffsetsResponse message, v1
GetLedgerEndRequest message, v1
GetLedgerEndResponse message, v1
GetTransactionByEventIdRequest message, v1
GetTransactionByIdRequest message, v1
GetTransactionResponse message, v1
GetTransactionTreesResponse message, v1
GetTransactionsRequest message, v1
GetTransactionsResponse message, v1
Enum message, v1
GenMap message, v1
GenMap.Entry message, v1
Identifier message, v1
List message, v1
Map message, v1
Map.Entry message, v1
Optional message, v1
Record message, v1
RecordField message, v1
Value message, v1
Variant message, v1
VersionService, v1
GetLedgerApiVersion method, v1
FeaturesDescriptor message, v1
GetLedgerApiVersionRequest message, v1
GetLedgerApiVersionResponse message, v1
PartyManagementFeature message, v1
UserManagementFeature message, v1
CommandCompletionService, v2
CompletionStream method, v2
CompletionStreamRequest message, v2
CompletionStreamResponse message, v2
CommandService, v2
SubmitAndWait method, v2
SubmitAndWaitForUpdateId method, v2
SubmitAndWaitForTransaction method, v2
SubmitAndWaitForTransactionTree method, v2
SubmitAndWaitForTransactionResponse message, v2
SubmitAndWaitForTransactionTreeResponse message, v2
SubmitAndWaitForUpdateIdResponse message, v2
SubmitAndWaitRequest message, v2
CommandSubmissionService, v2
Submit method, v2
SubmitReassignment method, v2
SubmitReassignmentRequest message, v2
SubmitReassignmentResponse message, v2
SubmitRequest message, v2
SubmitResponse message, v2
Commands message, v2
Completion message, v2
EventQueryService, v2
GetEventsByContractId method, v2
Archived message, v2
Created message, v2
GetEventsByContractIdResponse message, v2
PackageService, v2
ListPackages method, v2
GetPackage method, v2
GetPackageStatus method, v2
GetPackageRequest message, v2
GetPackageStatusRequest message, v2
ListPackagesRequest message, v2
ParticipantOffset message, v2
ParticipantOffset.ParticipantBoundary enum, v2
AssignedEvent message, v2
Reassignment message, v2
UnassignedEvent message, v2
AssignCommand message, v2
ReassignmentCommand message, v2
UnassignCommand message, v2
StateService, v2
GetActiveContracts method, v2
GetConnectedDomains method, v2
GetLedgerEnd method, v2
GetLatestPrunedOffsets method, v2
ActiveContract message, v2
GetActiveContractsRequest message, v2
GetActiveContractsResponse message, v2
GetConnectedDomainsRequest message, v2
GetConnectedDomainsResponse message, v2
GetConnectedDomainsResponse.ConnectedDomain message, v2
GetLatestPrunedOffsetsRequest message, v2
GetLatestPrunedOffsetsResponse message, v2
GetLedgerEndRequest message, v2
GetLedgerEndResponse message, v2
IncompleteAssigned message, v2
IncompleteUnassigned message, v2
ParticipantPermission enum, v2
TimeService, v2/testing
GetTime method, v2/testing
SetTime method, v2/testing
GetTimeRequest message, v2/testing
GetTimeResponse message, v2/testing
SetTimeRequest message, v2/testing
Transaction message, v2
TransactionTree message, v2
TransactionTree.EventsByIdEntry message, v2
TransactionFilter message, v2
TransactionFilter.FiltersByPartyEntry message, v2
UpdateService, v2
GetUpdates method, v2
GetUpdateTrees method, v2
GetTransactionTreeByEventId method, v2
GetTransactionTreeById method, v2
GetTransactionByEventId method, v2
GetTransactionById method, v2
GetTransactionByEventIdRequest message, v2
GetTransactionByIdRequest message, v2
GetTransactionResponse message, v2
GetTransactionTreeResponse message, v2
GetUpdateTreesResponse message, v2
GetUpdatesRequest message, v2
GetUpdatesResponse message, v2
VersionService, v2
GetLedgerApiVersion method, v2
GetLedgerApiVersionRequest message, v2
Scalar Value Types
Ledger API Reference
The specification for the services, methods, and messages for interacting with the gRPC-based Ledger API.

com/daml/ledger/api/v1/active_contracts_service.proto

ActiveContractsService, v1
Allows clients to initialize themselves according to a fairly recent state of the ledger without reading through all transactions that were committed since the ledger‚Äôs creation. In V2 Ledger API this service is not available anymore. Use v2.StateService instead.

GetActiveContracts method, v1
Returns a stream of the snapshot of the active contracts at a ledger offset. If there are no active contracts, the stream returns a single response message with the offset at which the snapshot has been taken. Clients SHOULD use the offset in the last GetActiveContractsResponse message to continue streaming transactions with the transaction service. Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.

Request: GetActiveContractsRequest
Response: GetActiveContractsResponse
GetActiveContractsRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

filter : TransactionFilter

Templates to include in the served snapshot, per party. Required

verbose : bool

If enabled, values served over the API will contain more information than strictly necessary to interpret the data. In particular, setting the verbose flag to true triggers the ledger to include labels for record fields. Optional

active_at_offset : string

The offset at which the snapshot of the active contracts will be computed. Must be no greater than the current ledger end offset. Must be greater than or equal to the last pruning offset. If not set the current ledger end offset will be used. Optional

GetActiveContractsResponse message, v1
offset : string

Included only in the last message. The client should start consuming the transactions endpoint with this offset. The format of this field is described in ledger_offset.proto.

workflow_id : string

The workflow that created the contracts. Must be a valid LedgerString (as described in value.proto).

active_contracts : CreatedEvent (repeated)

The list of contracts that were introduced by the workflow with workflow_id at the offset. Must be a valid LedgerString (as described in value.proto).

com/daml/ledger/api/v1/admin/command_inspection_service.proto

CommandInspectionService, v1/admin
Status: experimental interface, will change before it is deemed production ready

The inspection service provides methods for the ledger administrator to look under the hood of a running system. In V2 Ledger API this service is not available.

GetCommandStatus method, v1/admin
Inquire about the status of a command. This service is used for debugging only. The command status is only tracked in memory and is not persisted. The service can be used to understand the failure status and the structure of a command. Requires admin privileges The service is alpha without backward compatibility guarantees.

Request: GetCommandStatusRequest
Response: GetCommandStatusResponse
GetCommandStatusRequest message, v1/admin
command_id_prefix : string

optional filter by command id

state : CommandState

optional filter by state

limit : uint32

optional limit of returned statuses, defaults to 100

GetCommandStatusResponse message, v1/admin
command_status : GetCommandStatusResponse.CommandStatus (repeated)

GetCommandStatusResponse.CommandStatus message, v1/admin
started : google.protobuf.Timestamp

completed : google.protobuf.Timestamp

completion : com.daml.ledger.api.v1.Completion

state : CommandState

commands : com.daml.ledger.api.v1.Command (repeated)

request_statistics : GetCommandStatusResponse.CommandStatus.RequestStatistics

updates : GetCommandStatusResponse.CommandStatus.CommandUpdates

GetCommandStatusResponse.CommandStatus.CommandUpdates message, v1/admin
created : GetCommandStatusResponse.CommandStatus.CommandUpdates.Contract (repeated)

archived : GetCommandStatusResponse.CommandStatus.CommandUpdates.Contract (repeated)

exercised : uint32

fetched : uint32

looked_up_by_key : uint32

GetCommandStatusResponse.CommandStatus.CommandUpdates.Contract message, v1/admin
template_id : com.daml.ledger.api.v1.Identifier

contract_id : string

contract_key : com.daml.ledger.api.v1.Value

GetCommandStatusResponse.CommandStatus.RequestStatistics message, v1/admin
envelopes : uint32

request_size : uint32

recipients : uint32

CommandState enum, v1/admin
STATE_UNSPECIFIED

0	This value acts as wildcard in the queries
STATE_PENDING

1	 
STATE_SUCCEEDED

2	 
STATE_FAILED

3	 
com/daml/ledger/api/v1/admin/config_management_service.proto

ConfigManagementService, v1/admin
Status: experimental interface, will change before it is deemed production ready

The ledger configuration management service provides methods for the ledger administrator to change the current ledger configuration. The services provides methods to modify different aspects of the configuration. In V2 Ledger API this service is not available anymore.

GetTimeModel method, v1/admin
Return the currently active time model and the current configuration generation.

Request: GetTimeModelRequest
Response: GetTimeModelResponse
SetTimeModel method, v1/admin
Set the ledger time model.

Request: SetTimeModelRequest
Response: SetTimeModelResponse
GetTimeModelRequest message, v1/admin
Message has no fields.

GetTimeModelResponse message, v1/admin
configuration_generation : int64

The current configuration generation. The generation is a monotonically increasing integer that is incremented on each change. Used when setting the time model.

time_model : TimeModel

The current ledger time model.

SetTimeModelRequest message, v1/admin
submission_id : string

Submission identifier used for tracking the request and to reject duplicate submissions. Required.

maximum_record_time : google.protobuf.Timestamp

Deadline for the configuration change after which the change is rejected.

configuration_generation : int64

The current configuration generation which we‚Äôre submitting the change against. This is used to perform a compare-and-swap of the configuration to safeguard against concurrent modifications. Required.

new_time_model : TimeModel

The new time model that replaces the current one. Required.

SetTimeModelResponse message, v1/admin
configuration_generation : int64

The configuration generation of the committed time model.

TimeModel message, v1/admin
avg_transaction_latency : google.protobuf.Duration

The expected average latency of a transaction, i.e., the average time from submitting the transaction to a [[WriteService]] and the transaction being assigned a record time. Required.

min_skew : google.protobuf.Duration

The minimimum skew between ledger time and record time: lt_TX >= rt_TX - minSkew Required.

max_skew : google.protobuf.Duration

The maximum skew between ledger time and record time: lt_TX <= rt_TX + maxSkew Required.

com/daml/ledger/api/v1/admin/identity_provider_config_service.proto

IdentityProviderConfigService, v1/admin
Identity Provider Config Service makes it possible for participant node administrators to setup and manage additional identity providers at runtime.

This allows using access tokens from identity providers unknown at deployment time. When an identity provider is configured, independent IDP administrators can manage their own set of parties and users. Such parties and users have a matching identity_provider_id defined and are inaccessible to administrators from other identity providers. A user will only be authenticated if the corresponding JWT token is issued by the appropriate identity provider. Users and parties without identity_provider_id defined are assumed to be using the default identity provider, which is configured statically at the participant node‚Äôs deployment time.

The Ledger API uses the ‚Äúiss‚Äù claim of a JWT token to match the token to a specific IDP. If there is no match, the default IDP is assumed.

The fields of request messages (and sub-messages) are marked either as Optional or Required:

Optional denoting the client may leave the field unset when sending a request.
Required denoting the client must set the field to a non-default value when sending a request.
An identity provider config resource is described by the IdentityProviderConfig message, An identity provider config resource, once it has been created, can be modified. In order to update the properties represented by the IdentityProviderConfig message use the UpdateIdentityProviderConfig RPC. The only fields that can be modified are those marked as Modifiable.

CreateIdentityProviderConfig method, v1/admin
Create a new identity provider configuration. The request will fail if the maximum allowed number of separate configurations is reached.

Request: CreateIdentityProviderConfigRequest
Response: CreateIdentityProviderConfigResponse
GetIdentityProviderConfig method, v1/admin
Get the identity provider configuration data by id.

Request: GetIdentityProviderConfigRequest
Response: GetIdentityProviderConfigResponse
UpdateIdentityProviderConfig method, v1/admin
Update selected modifiable attribute of an identity provider config resource described by the IdentityProviderConfig message.

Request: UpdateIdentityProviderConfigRequest
Response: UpdateIdentityProviderConfigResponse
ListIdentityProviderConfigs method, v1/admin
List all existing identity provider configurations.

Request: ListIdentityProviderConfigsRequest
Response: ListIdentityProviderConfigsResponse
DeleteIdentityProviderConfig method, v1/admin
Delete an existing identity provider configuration.

Request: DeleteIdentityProviderConfigRequest
Response: DeleteIdentityProviderConfigResponse
CreateIdentityProviderConfigRequest message, v1/admin
identity_provider_config : IdentityProviderConfig

Required

CreateIdentityProviderConfigResponse message, v1/admin
identity_provider_config : IdentityProviderConfig

DeleteIdentityProviderConfigRequest message, v1/admin
identity_provider_id : string

The identity provider config to delete. Required

DeleteIdentityProviderConfigResponse message, v1/admin
Does not (yet) contain any data.

Message has no fields.

GetIdentityProviderConfigRequest message, v1/admin
identity_provider_id : string

Required

GetIdentityProviderConfigResponse message, v1/admin
identity_provider_config : IdentityProviderConfig

IdentityProviderConfig message, v1/admin
identity_provider_id : string

The identity provider identifier Must be a valid LedgerString (as describe in value.proto). Required

is_deactivated : bool

When set, the callers using JWT tokens issued by this identity provider are denied all access to the Ledger API. Optional, Modifiable

issuer : string

Specifies the issuer of the JWT token. The issuer value is a case sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components and no query or fragment components. Required Modifiable

jwks_url : string

The JWKS (JSON Web Key Set) URL. The Ledger API uses JWKs (JSON Web Keys) from the provided URL to verify that the JWT has been signed with the loaded JWK. Only RS256 (RSA Signature with SHA-256) signing algorithm is supported. Required Modifiable

audience : string

Specifies the audience of the JWT token. When set, the callers using JWT tokens issued by this identity provider are allowed to get an access only if the ‚Äúaud‚Äù claim includes the string specified here Optional, Modifiable

ListIdentityProviderConfigsRequest message, v1/admin
Pagination is not required as the resulting data set is small enough to be returned in a single call

Message has no fields.

ListIdentityProviderConfigsResponse message, v1/admin
identity_provider_configs : IdentityProviderConfig (repeated)

UpdateIdentityProviderConfigRequest message, v1/admin
identity_provider_config : IdentityProviderConfig

The identity provider config to update. Required, Modifiable

update_mask : google.protobuf.FieldMask

An update mask specifies how and which properties of the IdentityProviderConfig message are to be updated. An update mask consists of a set of update paths. A valid update path points to a field or a subfield relative to the IdentityProviderConfig message. A valid update mask must:

contain at least one update path,
contain only valid update paths.
Fields that can be updated are marked as Modifiable. For additional information see the documentation for standard protobuf3‚Äôs google.protobuf.FieldMask. Required

UpdateIdentityProviderConfigResponse message, v1/admin
identity_provider_config : IdentityProviderConfig

Updated identity provider config

com/daml/ledger/api/v1/admin/metering_report_service.proto

MeteringReportService, v1/admin
Experimental API to retrieve metering reports.

Metering reports aim to provide the information necessary for billing participant and application operators.

GetMeteringReport method, v1/admin
Retrieve a metering report.

Request: GetMeteringReportRequest
Response: GetMeteringReportResponse
GetMeteringReportRequest message, v1/admin
Authorized if and only if the authenticated user is a participant admin.

from : google.protobuf.Timestamp

The from timestamp (inclusive). Required.

to : google.protobuf.Timestamp

The to timestamp (exclusive). If not provided, the server will default to its current time.

application_id : string

If set to a non-empty value, then the report will only be generated for that application. Optional.

GetMeteringReportResponse message, v1/admin
request : GetMeteringReportRequest

The actual request that was executed.

report_generation_time : google.protobuf.Timestamp

The time at which the report was computed.

metering_report_json : google.protobuf.Struct

The metering report json. For a JSON Schema definition of the JSon see: https://github.com/digital-asset/daml/blob/main/ledger-api/grpc-definitions/metering-report-schema.json

com/daml/ledger/api/v1/admin/object_meta.proto

ObjectMeta message, v1/admin
Represents metadata corresponding to a participant resource (e.g. a participant user or participant local information about a party).

Based on ObjectMeta meta used in Kubernetes API. See https://github.com/kubernetes/apimachinery/blob/master/pkg/apis/meta/v1/generated.proto#L640

resource_version : string

An opaque, non-empty value, populated by a participant server which represents the internal version of the resource this ObjectMeta message is attached to. The participant server will change it to a unique value each time the corresponding resource is updated. You must not rely on the format of resource version. The participant server might change it without notice. You can obtain the newest resource version value by issuing a read request. You may use it for concurrent change detection by passing it back unmodified in an update request. The participant server will then compare the passed value with the value maintained by the system to determine if any other updates took place since you had read the resource version. Upon a successful update you are guaranteed that no other update took place during your read-modify-write sequence. However, if another update took place during your read-modify-write sequence then your update will fail with an appropriate error. Concurrent change control is optional. It will be applied only if you include a resource version in an update request. When creating a new instance of a resource you must leave the resource version empty. Its value will be populated by the participant server upon successful resource creation. Optional

annotations : ObjectMeta.AnnotationsEntry (repeated)

A set of modifiable key-value pairs that can be used to represent arbitrary, client-specific metadata. Constraints:

The total size over all keys and values cannot exceed 256kb in UTF-8 encoding.
Keys are composed of an optional prefix segment and a required name segment such that:
key prefix, when present, must be a valid DNS subdomain with at most 253 characters, followed by a ‚Äò/‚Äô (forward slash) character,
name segment must have at most 63 characters that are either alphanumeric ([a-z0-9A-Z]), or a ‚Äò.‚Äô (dot), ‚Äò-‚Äô (dash) or ‚Äò_‚Äô (underscore); and it must start and end with an alphanumeric character.
Values can be any non-empty strings.
Keys with empty prefix are reserved for end-users. Properties set by external tools or internally by the participant server must use non-empty key prefixes. Duplicate keys are disallowed by the semantics of the protobuf3 maps. See: https://developers.google.com/protocol-buffers/docs/proto3#maps Annotations may be a part of a modifiable resource. Use the resource‚Äôs update RPC to update its annotations. In order to add a new annotation or update an existing one using an update RPC, provide the desired annotation in the update request. In order to remove an annotation using an update RPC, provide the target annotation‚Äôs key but set its value to the empty string in the update request. Optional Modifiable

ObjectMeta.AnnotationsEntry message, v1/admin
key : string

value : string

com/daml/ledger/api/v1/admin/package_management_service.proto

PackageManagementService, v1/admin
Status: experimental interface, will change before it is deemed production ready

Query the Daml-LF packages supported by the ledger participant and upload DAR files. We use ‚Äòbacking participant‚Äô to refer to this specific participant in the methods of this API.

ListKnownPackages method, v1/admin
Returns the details of all Daml-LF packages known to the backing participant.

Request: ListKnownPackagesRequest
Response: ListKnownPackagesResponse
UploadDarFile method, v1/admin
Upload a DAR file to the backing participant. Depending on the ledger implementation this might also make the package available on the whole ledger. This call might not be supported by some ledger implementations. Canton could be an example, where uploading a DAR is not sufficient to render it usable, it must be activated first. This call may:

Succeed, if the package was successfully uploaded, or if the same package was already uploaded before.
Respond with a gRPC error
Request: UploadDarFileRequest
Response: UploadDarFileResponse
ValidateDarFile method, v1/admin
Performs the same checks that UploadDarFile call performs, but doesn‚Äôt persist the DAR and does not make it available for command execution. This call: - Succeeds if the packages contained in the DAR are valid - Respond with a gRPC error if the provided packages are not valid

Request: ValidateDarFileRequest
Response: ValidateDarFileResponse
ListKnownPackagesRequest message, v1/admin
Message has no fields.

ListKnownPackagesResponse message, v1/admin
package_details : PackageDetails (repeated)

The details of all Daml-LF packages known to backing participant. Required

PackageDetails message, v1/admin
package_id : string

The identity of the Daml-LF package. Must be a valid PackageIdString (as describe in value.proto). Required

package_size : uint64

Size of the package in bytes. The size of the package is given by the size of the daml_lf ArchivePayload. See further details in daml_lf.proto. Required

known_since : google.protobuf.Timestamp

Indicates since when the package is known to the backing participant. Required

source_description : string

Description provided by the backing participant describing where it got the package from. Optional

UploadDarFileRequest message, v1/admin
dar_file : bytes

Contains a Daml archive DAR file, which in turn is a jar like zipped container for daml_lf archives. See further details in daml_lf.proto. Required

submission_id : string

Unique submission identifier. Optional, defaults to a random identifier.

UploadDarFileResponse message, v1/admin
An empty message that is received when the upload operation succeeded.

Message has no fields.

ValidateDarFileRequest message, v1/admin
dar_file : bytes

Contains a Daml archive DAR file, which in turn is a jar like zipped container for daml_lf archives. See further details in daml_lf.proto. Required

submission_id : string

Unique submission identifier. Optional, defaults to a random identifier.

ValidateDarFileResponse message, v1/admin
Message has no fields.

com/daml/ledger/api/v1/admin/participant_pruning_service.proto

ParticipantPruningService, v1/admin
Prunes/truncates the ‚Äúoldest‚Äù transactions from the participant (the participant Ledger Api Server plus any other participant-local state) by removing a portion of the ledger in such a way that the set of future, allowed commands are not affected.

This enables:

keeping the ‚Äúinactive‚Äù portion of the ledger to a manageable size and
removing inactive state to honor the right to be forgotten.
Prune method, v1/admin
Prune the ledger specifying the offset before and at which ledger transactions should be removed. Only returns when the potentially long-running prune request ends successfully or with an error.

Request: PruneRequest
Response: PruneResponse
PruneRequest message, v1/admin
prune_up_to : string

Inclusive offset up to which the ledger is to be pruned. By default the following data is pruned:

All normal and divulged contracts that have been archived before prune_up_to.
All transaction events and completions before prune_up_to
submission_id : string

Unique submission identifier. Optional, defaults to a random identifier, used for logging.

prune_all_divulged_contracts : bool

Prune all immediately and retroactively divulged contracts created before prune_up_to independent of whether they were archived before prune_up_to. Useful to avoid leaking storage on participant nodes that can see a divulged contract but not its archival.

Application developers SHOULD write their Daml applications such that they do not rely on divulged contracts; i.e., no warnings from using divulged contracts as inputs to transactions are emitted.

Participant node operators SHOULD set the prune_all_divulged_contracts flag to avoid leaking storage due to accumulating unarchived divulged contracts PROVIDED that:

no application using this participant node relies on divulgence OR
divulged contracts on which applications rely have been re-divulged after the prune_up_to offset.
PruneResponse message, v1/admin
Empty for now, but may contain fields in the future

Message has no fields.

com/daml/ledger/api/v1/admin/party_management_service.proto

PartyManagementService, v1/admin
This service allows inspecting the party management state of the ledger known to the participant and managing the participant-local party metadata.

The authorization rules for its RPCs are specified on the <RpcName>Request messages as boolean expressions over these facts:

HasRight(r) denoting whether the authenticated user has right r and
IsAuthenticatedIdentityProviderAdmin(idp) denoting whether idp is equal to the identity_provider_id of the authenticated user and the user has an IdentityProviderAdmin right.
If identity_provider_id is set to an empty string, then it‚Äôs effectively set to the value of access token‚Äôs ‚Äòiss‚Äô field if that is provided. If identity_provider_id remains an empty string, the default identity provider will be assumed.

The fields of request messages (and sub-messages) are marked either as Optional or Required:

Optional denoting the client may leave the field unset when sending a request.
Required denoting the client must set the field to a non-default value when sending a request.
A party details resource is described by the PartyDetails message, A party details resource, once it has been created, can be modified using the UpdatePartyDetails RPC. The only fields that can be modified are those marked as Modifiable.

GetParticipantId method, v1/admin
Return the identifier of the participant. All horizontally scaled replicas should return the same id. daml-on-kv-ledger: returns an identifier supplied on command line at launch time canton: returns globally unique identifier of the participant

Request: GetParticipantIdRequest
Response: GetParticipantIdResponse
GetParties method, v1/admin
Get the party details of the given parties. Only known parties will be returned in the list.

Request: GetPartiesRequest
Response: GetPartiesResponse
ListKnownParties method, v1/admin
List the parties known by the participant. The list returned contains parties whose ledger access is facilitated by the participant and the ones maintained elsewhere.

Request: ListKnownPartiesRequest
Response: ListKnownPartiesResponse
AllocateParty method, v1/admin
Allocates a new party on a ledger and adds it to the set managed by the participant. Caller specifies a party identifier suggestion, the actual identifier allocated might be different and is implementation specific. Caller can specify party metadata that is stored locally on the participant. This call may:

Succeed, in which case the actual allocated identifier is visible in the response.
Respond with a gRPC error
daml-on-kv-ledger: suggestion‚Äôs uniqueness is checked by the validators in the consensus layer and call rejected if the identifier is already present. canton: completely different globally unique identifier is allocated. Behind the scenes calls to an internal protocol are made. As that protocol is richer than the surface protocol, the arguments take implicit values The party identifier suggestion must be a valid party name. Party names are required to be non-empty US-ASCII strings built from letters, digits, space, colon, minus and underscore limited to 255 chars

Request: AllocatePartyRequest
Response: AllocatePartyResponse
UpdatePartyDetails method, v1/admin
Update selected modifiable participant-local attributes of a party details resource. Can update the participant‚Äôs local information for local parties.

Request: UpdatePartyDetailsRequest
Response: UpdatePartyDetailsResponse
UpdatePartyIdentityProviderId method, v1/admin
Update the assignment of a party from one IDP to another.

Request: UpdatePartyIdentityProviderRequest
Response: UpdatePartyIdentityProviderResponse
AllocatePartyRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)

party_id_hint : string

A hint to the participant which party ID to allocate. It can be ignored. Must be a valid PartyIdString (as described in value.proto). Optional

display_name : string

Human-readable name of the party to be added to the participant. It doesn‚Äôt have to be unique. Use of this field is discouraged. Use local_metadata instead. Optional

local_metadata : ObjectMeta

Participant-local metadata to be stored in the PartyDetails of this newly allocated party. Optional

identity_provider_id : string

The id of the Identity Provider Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.

AllocatePartyResponse message, v1/admin
party_details : PartyDetails

GetParticipantIdRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin)

Message has no fields.

GetParticipantIdResponse message, v1/admin
participant_id : string

Identifier of the participant, which SHOULD be globally unique. Must be a valid LedgerString (as describe in value.proto).

GetPartiesRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)

parties : string (repeated)

The stable, unique identifier of the Daml parties. Must be valid PartyIdStrings (as described in value.proto). Required

identity_provider_id : string

The id of the Identity Provider whose parties should be retrieved. Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.

GetPartiesResponse message, v1/admin
party_details : PartyDetails (repeated)

The details of the requested Daml parties by the participant, if known. The party details may not be in the same order as requested. Required

ListKnownPartiesRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)

page_token : string

Pagination token to determine the specific page to fetch. Using the token guarantees that parties on a subsequent page are all lexically greater than the last party on a previous page. Server does not store intermediate results between calls chained by a series of page tokens. As a consequence, if new parties are being added and a page is requested twice using the same token, more parties can be returned on the second call. Leave empty to fetch the first page. Optional

page_size : int32

Maximum number of results to be returned by the server. The server will return no more than that many results, but it might return fewer. If the page_size is 0, the server will decide the number of results to be returned. If the page_size exceeds the maximum supported by the server, an error will be returned. To obtain the server‚Äôs maximum consult the PartyManagementFeature descriptor available in the VersionService. Optional

identity_provider_id : string

The id of the Identity Provider whose parties should be retrieved. Optional, if not set, assume the party is managed by the default identity provider or party is not hosted by the participant.

ListKnownPartiesResponse message, v1/admin
party_details : PartyDetails (repeated)

The details of all Daml parties known by the participant. Required

next_page_token : string

Pagination token to retrieve the next page. Empty, if there are no further results.

PartyDetails message, v1/admin
party : string

The stable unique identifier of a Daml party. Must be a valid PartyIdString (as described in value.proto). Required

display_name : string

Human readable name associated with the party at allocation time. Caution, it might not be unique. Use of this field is discouraged. Use the local_metadata field instead. Optional

is_local : bool

true if party is hosted by the participant and the party shares the same identity provider as the user issuing the request. Optional

local_metadata : ObjectMeta

Participant-local metadata of this party. Optional, Modifiable

identity_provider_id : string

The id of the Identity Provider Optional, if not set, there could be 3 options:

the party is managed by the default identity provider.
party is not hosted by the participant.
party is hosted by the participant, but is outside of the user‚Äôs identity provider.
UpdatePartyDetailsRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(party_details.identity_provider_id)

party_details : PartyDetails

Party to be updated Required, Modifiable

update_mask : google.protobuf.FieldMask

An update mask specifies how and which properties of the PartyDetails message are to be updated. An update mask consists of a set of update paths. A valid update path points to a field or a subfield relative to the PartyDetails message. A valid update mask must:

contain at least one update path,
contain only valid update paths.
Fields that can be updated are marked as Modifiable. An update path can also point to non-Modifiable fields such as ‚Äòparty‚Äô and ‚Äòlocal_metadata.resource_version‚Äô because they are used:

to identify the party details resource subject to the update,
for concurrent change control.
An update path can also point to non-Modifiable fields such as ‚Äòis_local‚Äô and ‚Äòdisplay_name‚Äô as long as the values provided in the update request match the server values. Examples of update paths: ‚Äòlocal_metadata.annotations‚Äô, ‚Äòlocal_metadata‚Äô. For additional information see the documentation for standard protobuf3‚Äôs google.protobuf.FieldMask. For similar Ledger API see com.daml.ledger.api.v1.admin.UpdateUserRequest. Required

UpdatePartyDetailsResponse message, v1/admin
party_details : PartyDetails

Updated party details

UpdatePartyIdentityProviderRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin)

party : string

Party to update

source_identity_provider_id : string

Current identity provider id of the party

target_identity_provider_id : string

Target identity provider id of the party

UpdatePartyIdentityProviderResponse message, v1/admin
Message has no fields.

com/daml/ledger/api/v1/admin/user_management_service.proto

UserManagementService, v1/admin
Service to manage users and their rights for interacting with the Ledger API served by a participant node.

The authorization rules for its RPCs are specified on the <RpcName>Request messages as boolean expressions over these facts:

HasRight(r) denoting whether the authenticated user has right r and
IsAuthenticatedUser(uid) denoting whether uid is the empty string or equal to the id of the authenticated user.
IsAuthenticatedIdentityProviderAdmin(idp) denoting whether idp is equal to the identity_provider_id of the authenticated user and the user has an IdentityProviderAdmin right.
If user_id is set to the empty string (the default), then the data for the authenticated user will be retrieved. If identity_provider_id is set to an empty string, then it‚Äôs effectively set to the value of access token‚Äôs ‚Äòiss‚Äô field if that is provided. If identity_provider_id remains an empty string, the default identity provider will be assumed.

The fields of request messages (and sub-messages) are marked either as Optional or Required:

Optional denoting the client may leave the field unset when sending a request.
Required denoting the client must set the field to a non-default value when sending a request.
A user resource consists of:

a set of properties represented by the User message,
a set of user rights, where each right is represented by the Right message.
A user resource, once it has been created, can be modified. In order to update the properties represented by the User message use the UpdateUser RPC. The only fields that can be modified are those marked as Modifiable. In order to grant or revoke user rights use GrantRights' and ``RevokeRights RPCs.

CreateUser method, v1/admin
Create a new user.

Request: CreateUserRequest
Response: CreateUserResponse
GetUser method, v1/admin
Get the user data of a specific user or the authenticated user.

Request: GetUserRequest
Response: GetUserResponse
UpdateUser method, v1/admin
Update selected modifiable attribute of a user resource described by the User message.

Request: UpdateUserRequest
Response: UpdateUserResponse
DeleteUser method, v1/admin
Delete an existing user and all its rights.

Request: DeleteUserRequest
Response: DeleteUserResponse
ListUsers method, v1/admin
List all existing users.

Request: ListUsersRequest
Response: ListUsersResponse
GrantUserRights method, v1/admin
Grant rights to a user. Granting rights does not affect the resource version of the corresponding user.

Request: GrantUserRightsRequest
Response: GrantUserRightsResponse
RevokeUserRights method, v1/admin
Revoke rights from a user. Revoking rights does not affect the resource version of the corresponding user.

Request: RevokeUserRightsRequest
Response: RevokeUserRightsResponse
ListUserRights method, v1/admin
List the set of all rights granted to a user.

Request: ListUserRightsRequest
Response: ListUserRightsResponse
UpdateUserIdentityProviderId method, v1/admin
Update the assignment of a user from one IDP to another.

Request: UpdateUserIdentityProviderRequest
Response: UpdateUserIdentityProviderResponse
CreateUserRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)

user : User

The user to create. Required

rights : Right (repeated)

The rights to be assigned to the user upon creation, which SHOULD include appropriate rights for the user.primary_party. Optional

CreateUserResponse message, v1/admin
user : User

Created user.

DeleteUserRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)

user_id : string

The user to delete. Required

identity_provider_id : string

The id of the Identity Provider Optional, if not set, assume the user is managed by the default identity provider.

DeleteUserResponse message, v1/admin
Does not (yet) contain any data.

Message has no fields.

GetUserRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id) OR IsAuthenticatedUser(user_id)

user_id : string

The user whose data to retrieve. If set to empty string (the default), then the data for the authenticated user will be retrieved. Optional

identity_provider_id : string

The id of the Identity Provider Optional, if not set, assume the user is managed by the default identity provider.

GetUserResponse message, v1/admin
user : User

Retrieved user.

GrantUserRightsRequest message, v1/admin
Add the rights to the set of rights granted to the user.

Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)

user_id : string

The user to whom to grant rights. Required

rights : Right (repeated)

The rights to grant. Optional

identity_provider_id : string

The id of the Identity Provider Optional, if not set, assume the user is managed by the default identity provider.

GrantUserRightsResponse message, v1/admin
newly_granted_rights : Right (repeated)

The rights that were newly granted by the request.

ListUserRightsRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id) OR IsAuthenticatedUser(user_id)

user_id : string

The user for which to list the rights. If set to empty string (the default), then the rights for the authenticated user will be listed. Required

identity_provider_id : string

The id of the Identity Provider Optional, if not set, assume the user is managed by the default identity provider.

ListUserRightsResponse message, v1/admin
rights : Right (repeated)

All rights of the user.

ListUsersRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)

page_token : string

Pagination token to determine the specific page to fetch. Leave empty to fetch the first page. Optional

page_size : int32

Maximum number of results to be returned by the server. The server will return no more than that many results, but it might return fewer. If 0, the server will decide the number of results to be returned. Optional

identity_provider_id : string

The id of the Identity Provider Optional, if not set, assume the user is managed by the default identity provider.

ListUsersResponse message, v1/admin
users : User (repeated)

A subset of users of the participant node that fit into this page.

next_page_token : string

Pagination token to retrieve the next page. Empty, if there are no further results.

RevokeUserRightsRequest message, v1/admin
Remove the rights from the set of rights granted to the user.

Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(identity_provider_id)

user_id : string

The user from whom to revoke rights. Required

rights : Right (repeated)

The rights to revoke. Optional

identity_provider_id : string

The id of the Identity Provider Optional, if not set, assume the user is managed by the default identity provider.

RevokeUserRightsResponse message, v1/admin
newly_revoked_rights : Right (repeated)

The rights that were actually revoked by the request.

Right message, v1/admin
A right granted to a user.

oneof kind.participant_admin : Right.ParticipantAdmin

The user can administer the participant node.

oneof kind.can_act_as : Right.CanActAs

The user can act as a specific party.

oneof kind.can_read_as : Right.CanReadAs

The user can read ledger data visible to a specific party.

oneof kind.identity_provider_admin : Right.IdentityProviderAdmin

The user can administer users and parties assigned to the same identity provider as the one of the user.

Right.CanActAs message, v1/admin
party : string

The right to authorize commands for this party.

Right.CanReadAs message, v1/admin
party : string

The right to read ledger data visible to this party.

Right.IdentityProviderAdmin message, v1/admin
The right to administer the identity provider that the user is assigned to. It means, being able to manage users and parties that are also assigned to the same identity provider.

Message has no fields.

Right.ParticipantAdmin message, v1/admin
The right to administer the participant node.

Message has no fields.

UpdateUserIdentityProviderRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin)

user_id : string

User to update

source_identity_provider_id : string

Current identity provider id of the user

target_identity_provider_id : string

Target identity provider id of the user

UpdateUserIdentityProviderResponse message, v1/admin
Message has no fields.

UpdateUserRequest message, v1/admin
Required authorization: HasRight(ParticipantAdmin) OR IsAuthenticatedIdentityProviderAdmin(user.identity_provider_id)

user : User

The user to update. Required, Modifiable

update_mask : google.protobuf.FieldMask

An update mask specifies how and which properties of the User message are to be updated. An update mask consists of a set of update paths. A valid update path points to a field or a subfield relative to the User message. A valid update mask must:

contain at least one update path,
contain only valid update paths.
Fields that can be updated are marked as Modifiable. An update path can also point to a non-Modifiable fields such as ‚Äòid‚Äô and ‚Äòmetadata.resource_version‚Äô because they are used:

to identify the user resource subject to the update,
for concurrent change control.
Examples of valid update paths: ‚Äòprimary_party‚Äô, ‚Äòmetadata‚Äô, ‚Äòmetadata.annotations‚Äô. For additional information see the documentation for standard protobuf3‚Äôs google.protobuf.FieldMask. For similar Ledger API see com.daml.ledger.api.v1.admin.UpdatePartyDetailsRequest. Required

UpdateUserResponse message, v1/admin
user : User

Updated user

User message, v1/admin
Users are used to dynamically manage the rights given to Daml applications. They are stored and managed per participant node.

Read the Authorization documentation to learn more.

id : string

The user identifier, which must be a non-empty string of at most 128 characters that are either alphanumeric ASCII characters or one of the symbols ‚Äú@^$.!`-#+‚Äô~_|:‚Äù. Required

primary_party : string

The primary party as which this user reads and acts by default on the ledger provided it has the corresponding CanReadAs(primary_party) or CanActAs(primary_party) rights. Ledger API clients SHOULD set this field to a non-empty value for all users to enable the users to act on the ledger using their own Daml party. Users for participant administrators MAY have an associated primary party. Optional, Modifiable

is_deactivated : bool

When set, then the user is denied all access to the Ledger API. Otherwise, the user has access to the Ledger API as per the user‚Äôs rights. Optional, Modifiable

metadata : ObjectMeta

The metadata of this user. Note that the metadata.resource_version tracks changes to the properties described by the User message and not the user‚Äôs rights. Optional, Modifiable

identity_provider_id : string

The id of the identity provider configured by Identity Provider Config Optional, if not set, assume the user is managed by the default identity provider.

com/daml/ledger/api/v1/command_completion_service.proto

CommandCompletionService, v1
Allows clients to observe the status of their submissions. Commands may be submitted via the Command Submission Service. The on-ledger effects of their submissions are disclosed by the Transaction Service.

Commands may fail in 2 distinct manners:

Failure communicated synchronously in the gRPC error of the submission.
Failure communicated asynchronously in a Completion, see completion.proto.
Note that not only successfully submitted commands MAY produce a completion event. For example, the participant MAY choose to produce a completion event for a rejection of a duplicate command.

Clients that do not receive a successful completion about their submission MUST NOT assume that it was successful. Clients SHOULD subscribe to the CompletionStream before starting to submit commands to prevent race conditions.

CompletionStream method, v1
Subscribe to command completion events.

Request: CompletionStreamRequest
Response: CompletionStreamResponse
CompletionEnd method, v1
Returns the offset after the latest completion.

Request: CompletionEndRequest
Response: CompletionEndResponse
Checkpoint message, v1
Checkpoints may be used to:

detect time out of commands.
provide an offset which can be used to restart consumption.
record_time : google.protobuf.Timestamp

All commands with a maximum record time below this value MUST be considered lost if their completion has not arrived before this checkpoint. Required

offset : LedgerOffset

May be used in a subsequent CompletionStreamRequest to resume the consumption of this stream at a later time. Required

CompletionEndRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

CompletionEndResponse message, v1
offset : LedgerOffset

This offset can be used in a CompletionStreamRequest message. Required

CompletionStreamRequest message, v1
ledger_id : string

Must correspond to the ledger id reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

application_id : string

Only completions of commands submitted with the same application_id will be visible in the stream. Must be a valid ApplicationIdString (as described in value.proto). Required unless authentication is used with a user token or a custom token specifying an application-id. In that case, the token‚Äôs user-id, respectively application-id, will be used for the request‚Äôs application_id.

parties : string (repeated)

Non-empty list of parties whose data should be included. Only completions of commands for which at least one of the act_as parties is in the given set of parties will be visible in the stream. Must be a valid PartyIdString (as described in value.proto). Required

offset : LedgerOffset

This field indicates the minimum offset for completions. This can be used to resume an earlier completion stream. This offset is exclusive: the response will only contain commands whose offset is strictly greater than this. Optional, if not set the ledger uses the current ledger end offset instead.

CompletionStreamResponse message, v1
checkpoint : Checkpoint

This checkpoint may be used to restart consumption. The checkpoint is after any completions in this response. Optional

completions : Completion (repeated)

If set, one or more completions.

com/daml/ledger/api/v1/command_service.proto

CommandService, v1
Command Service is able to correlate submitted commands with completion data, identify timeouts, and return contextual information with each tracking result. This supports the implementation of stateless clients.

Note that submitted commands generally produce completion events as well, even in case a command gets rejected. For example, the participant MAY choose to produce a completion event for a rejection of a duplicate command.

SubmitAndWait method, v1
Submits a single composite command and waits for its result. Propagates the gRPC error of failed submissions including Daml interpretation errors.

Request: SubmitAndWaitRequest
Response: .google.protobuf.Empty
SubmitAndWaitForTransactionId method, v1
Submits a single composite command, waits for its result, and returns the transaction id. Propagates the gRPC error of failed submissions including Daml interpretation errors.

Request: SubmitAndWaitRequest
Response: SubmitAndWaitForTransactionIdResponse
SubmitAndWaitForTransaction method, v1
Submits a single composite command, waits for its result, and returns the transaction. Propagates the gRPC error of failed submissions including Daml interpretation errors.

Request: SubmitAndWaitRequest
Response: SubmitAndWaitForTransactionResponse
SubmitAndWaitForTransactionTree method, v1
Submits a single composite command, waits for its result, and returns the transaction tree. Propagates the gRPC error of failed submissions including Daml interpretation errors.

Request: SubmitAndWaitRequest
Response: SubmitAndWaitForTransactionTreeResponse
SubmitAndWaitForTransactionIdResponse message, v1
transaction_id : string

The id of the transaction that resulted from the submitted command. Must be a valid LedgerString (as described in value.proto). Required

completion_offset : string

The format of this field is described in ledger_offset.proto. Optional

SubmitAndWaitForTransactionResponse message, v1
transaction : Transaction

The flat transaction that resulted from the submitted command. Required

completion_offset : string

The format of this field is described in ledger_offset.proto. Optional

SubmitAndWaitForTransactionTreeResponse message, v1
transaction : TransactionTree

The transaction tree that resulted from the submitted command. Required

completion_offset : string

The format of this field is described in ledger_offset.proto. Optional

SubmitAndWaitRequest message, v1
These commands are atomic, and will become transactions.

commands : Commands

The commands to be submitted. Required

com/daml/ledger/api/v1/command_submission_service.proto

CommandSubmissionService, v1
Allows clients to attempt advancing the ledger‚Äôs state by submitting commands. The final states of their submissions are disclosed by the Command Completion Service. The on-ledger effects of their submissions are disclosed by the Transaction Service.

Commands may fail in 2 distinct manners:

Failure communicated synchronously in the gRPC error of the submission.
Failure communicated asynchronously in a Completion, see completion.proto.
Note that not only successfully submitted commands MAY produce a completion event. For example, the participant MAY choose to produce a completion event for a rejection of a duplicate command.

Clients that do not receive a successful completion about their submission MUST NOT assume that it was successful. Clients SHOULD subscribe to the CompletionStream before starting to submit commands to prevent race conditions.

Submit method, v1
Submit a single composite command.

Request: SubmitRequest
Response: .google.protobuf.Empty
SubmitRequest message, v1
The submitted commands will be processed atomically in a single transaction. Moreover, each Command in commands will be executed in the order specified by the request.

commands : Commands

The commands to be submitted in a single transaction. Required

com/daml/ledger/api/v1/commands.proto

Command message, v1
A command can either create a new contract or exercise a choice on an existing contract.

oneof command.create : CreateCommand

oneof command.exercise : ExerciseCommand

oneof command.exerciseByKey : ExerciseByKeyCommand

oneof command.createAndExercise : CreateAndExerciseCommand

Commands message, v1
A composite command that groups multiple commands together.

ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

workflow_id : string

Identifier of the on-ledger workflow that this command is a part of. Must be a valid LedgerString (as described in value.proto). Optional

application_id : string

Uniquely identifies the application or participant user that issued the command. Must be a valid ApplicationIdString (as described in value.proto). Required unless authentication is used with a user token or a custom token specifying an application-id. In that case, the token‚Äôs user-id, respectively application-id, will be used for the request‚Äôs application_id.

command_id : string

Uniquely identifies the command. The triple (application_id, party + act_as, command_id) constitutes the change ID for the intended ledger change, where party + act_as is interpreted as a set of party names. The change ID can be used for matching the intended ledger changes with all their completions. Must be a valid LedgerString (as described in value.proto). Required

party : string

Party on whose behalf the command should be executed. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to act on behalf of the given party. Must be a valid PartyIdString (as described in value.proto). Deprecated in favor of the act_as field. If both are set, then the effective list of parties on whose behalf the command should be executed is the union of all parties listed in party and act_as. Optional

commands : Command (repeated)

Individual elements of this atomic command. Must be non-empty. Required

oneof deduplication_period.deduplication_time : google.protobuf.Duration

Specifies the length of the deduplication period. Same semantics apply as for deduplication_duration. Must be non-negative. Must not exceed the maximum deduplication time (see ledger_configuration_service.proto).

oneof deduplication_period.deduplication_duration : google.protobuf.Duration

Specifies the length of the deduplication period. It is interpreted relative to the local clock at some point during the submission‚Äôs processing. Must be non-negative. Must not exceed the maximum deduplication time (see ledger_configuration_service.proto).

oneof deduplication_period.deduplication_offset : string

Specifies the start of the deduplication period by a completion stream offset (exclusive). Must be a valid LedgerString (as described in ledger_offset.proto).

min_ledger_time_abs : google.protobuf.Timestamp

Lower bound for the ledger time assigned to the resulting transaction. Note: The ledger time of a transaction is assigned as part of command interpretation. Use this property if you expect that command interpretation will take a considerate amount of time, such that by the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore. Must not be set at the same time as min_ledger_time_rel. Optional

min_ledger_time_rel : google.protobuf.Duration

Same as min_ledger_time_abs, but specified as a duration, starting from the time the command is received by the server. Must not be set at the same time as min_ledger_time_abs. Optional

act_as : string (repeated)

Set of parties on whose behalf the command should be executed. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to act on behalf of each of the given parties. This field supersedes the party field. The effective set of parties on whose behalf the command should be executed is the union of all parties listed in party and act_as, which must be non-empty. Each element must be a valid PartyIdString (as described in value.proto). Optional

read_as : string (repeated)

Set of parties on whose behalf (in addition to all parties listed in act_as) contracts can be retrieved. This affects Daml operations such as fetch, fetchByKey, lookupByKey, exercise, and exerciseByKey. Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant node is only visible to a subset of these parties. A command can only use contracts that are visible to at least one of the parties in act_as or read_as. This visibility check is independent from the Daml authorization rules for fetch operations. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to read contract data on behalf of each of the given parties. Optional

submission_id : string

A unique identifier to distinguish completions for different submissions with the same change ID. Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission with the same change ID. Must be a valid LedgerString (as described in value.proto).

If omitted, the participant or the committer may set a value of their choice. Optional

disclosed_contracts : DisclosedContract (repeated)

Additional contracts used to resolve contract & contract key lookups. Optional

package_id_selection_preference : string (repeated)

The package-id selection preference of the client for resolving package names and interface instances in command submission and interpretation

prefetch_contract_keys : PrefetchContractKey (repeated)

Fetches the contract keys into the caches to speed up the command processing. Should only contain contract keys that are expected to be resolved during interpretation of the commands. Keys of disclosed contracts do not need prefetching.

Optional

CreateAndExerciseCommand message, v1
Create a contract and exercise a choice on it in the same transaction.

template_id : Identifier

The template of the contract the client wants to create. Both package-name and package-id reference identifier formats for the template-id are supported.

Required

create_arguments : Record

The arguments required for creating a contract from this template. Required

choice : string

The name of the choice the client wants to exercise. Must be a valid NameString (as described in value.proto). Required

choice_argument : Value

The argument for this choice. Required

CreateCommand message, v1
Create a new contract instance based on a template.

template_id : Identifier

The template of contract the client wants to create. Both package-name and package-id reference identifier formats for the template-id are supported.

Required

create_arguments : Record

The arguments required for creating a contract from this template. Required

DisclosedContract message, v1
An additional contract that is used to resolve contract & contract key lookups.

template_id : Identifier

The template id of the contract. The identifier uses the package-id reference format.

Required

contract_id : string

The contract id Required

created_event_blob : bytes

Opaque byte string containing the complete payload required by the Daml engine to reconstruct a contract not known to the receiving participant. Required

ExerciseByKeyCommand message, v1
Exercise a choice on an existing contract specified by its key.

template_id : Identifier

The template of contract the client wants to exercise. Both package-name and package-id reference identifier formats for the template-id are supported.

Required

contract_key : Value

The key of the contract the client wants to exercise upon. Required

choice : string

The name of the choice the client wants to exercise. Must be a valid NameString (as described in value.proto) Required

choice_argument : Value

The argument for this choice. Required

ExerciseCommand message, v1
Exercise a choice on an existing contract.

template_id : Identifier

The template of contract the client wants to exercise. Both package-name and package-id reference identifier formats for the template-id are supported.

Required

contract_id : string

The ID of the contract the client wants to exercise upon. Must be a valid LedgerString (as described in value.proto). Required

choice : string

The name of the choice the client wants to exercise. Must be a valid NameString (as described in value.proto) Required

choice_argument : Value

The argument for this choice. Required

PrefetchContractKey message, v1
Preload contracts

template_id : Identifier

The template of contract the client wants to prefetch. Both package-name and package-id reference identifier formats for the template-id are supported.

Required

contract_key : Value

The key of the contract the client wants to prefetch. Required

com/daml/ledger/api/v1/completion.proto

Completion message, v1
A completion represents the status of a submitted command on the ledger: it can be successful or failed.

command_id : string

The ID of the succeeded or failed command. Must be a valid LedgerString (as described in value.proto). Required

status : google.rpc.Status

Identifies the exact type of the error. It uses the same format of conveying error details as it is used for the RPC responses of the APIs. Optional

transaction_id : string

The transaction_id of the transaction that resulted from the command with command_id. Only set for successfully executed commands. Must be a valid LedgerString (as described in value.proto). Optional

application_id : string

The application-id or user-id that was used for the submission, as described in commands.proto. Must be a valid ApplicationIdString (as described in value.proto). Optional for historic completions where this data is not available.

act_as : string (repeated)

The set of parties on whose behalf the commands were executed. Contains the union of party and act_as from commands.proto. The order of the parties need not be the same as in the submission. Each element must be a valid PartyIdString (as described in value.proto). Optional for historic completions where this data is not available.

submission_id : string

The submission ID this completion refers to, as described in commands.proto. Must be a valid LedgerString (as described in value.proto). Optional

oneof deduplication_period.deduplication_offset : string

Specifies the start of the deduplication period by a completion stream offset (exclusive).

Must be a valid LedgerString (as described in value.proto).

oneof deduplication_period.deduplication_duration : google.protobuf.Duration

Specifies the length of the deduplication period. It is measured in record time of completions.

Must be non-negative.

trace_context : TraceContext

Optional; ledger api trace context

The trace context transported in this message corresponds to the trace context supplied by the client application in a HTTP2 header of the original command submission. We typically use a header to transfer this type of information. Here we use message body, because it is used in gRPC streams which do not support per message headers. This field will be populated with the trace context contained in the original submission. If that was not provided, a unique ledger-api-server generated trace context will be used instead.

com/daml/ledger/api/v1/contract_metadata.proto

ContractMetadata message, v1
Contract-related metadata used in DisclosedContract (that can be included in command submission) or forwarded as part of the CreatedEvent in Active Contract Set or Transaction streams.

created_at : google.protobuf.Timestamp

Ledger effective time of the transaction that created the contract. Required

contract_key_hash : bytes

Hash of the contract key if defined. Optional

driver_metadata : bytes

Driver-specific metadata. This is opaque and cannot be decoded. Optional

com/daml/ledger/api/v1/event.proto

ArchivedEvent message, v1
Records that a contract has been archived, and choices may no longer be exercised on it.

event_id : string

The ID of this particular event. Must be a valid LedgerString (as described in value.proto). Required

contract_id : string

The ID of the archived contract. Must be a valid LedgerString (as described in value.proto). Required

template_id : Identifier

The template of the archived contract. The identifier uses the package-id reference format.

Required

witness_parties : string (repeated)

The parties that are notified of this event. For an ArchivedEvent, these are the intersection of the stakeholders of the contract in question and the parties specified in the TransactionFilter. The stakeholders are the union of the signatories and the observers of the contract. Each one of its elements must be a valid PartyIdString (as described in value.proto). Required

package_name : google.protobuf.StringValue

The package name of the archived contract. Optional

CreatedEvent message, v1
Records that a contract has been created, and choices may now be exercised on it.

event_id : string

The ID of this particular event. Must be a valid LedgerString (as described in value.proto). Required

contract_id : string

The ID of the created contract. Must be a valid LedgerString (as described in value.proto). Required

template_id : Identifier

The template of the created contract. The identifier uses the package-id reference format.

Required

package_name : google.protobuf.StringValue

The package name of the created contract. Optional

contract_key : Value

The key of the created contract. This will be set if and only if create_arguments is set and template_id defines a contract key. Optional

create_arguments : Record

The arguments that have been used to create the contract. Set either:

if there was a party, which is in the witness_parties of this event, and for which an InclusiveFilters exists with the template_id of this event among the template_ids,
or if there was a party, which is in the witness_parties of this event, and for which a wildcard filter exists (Filters without InclusiveFilters, or with an InclusiveFilters with empty template_ids and empty interface_filters).
Optional

created_event_blob : bytes

Opaque representation of contract create event payload intended for forwarding to an API server as a contract disclosed as part of a command submission. Optional

interface_views : InterfaceView (repeated)

Interface views specified in the transaction filter. Includes an InterfaceView for each interface for which there is a InterfaceFilter with

its party in the witness_parties of this event,
and which is implemented by the template of this event,
and which has include_interface_view set.
Optional

witness_parties : string (repeated)

The parties that are notified of this event. When a CreatedEvent is returned as part of a transaction tree, this will include all the parties specified in the TransactionFilter that are informees of the event. If served as part of a flat transaction those will be limited to all parties specified in the TransactionFilter that are stakeholders of the contract (i.e. either signatories or observers).

In case of v2 API, if the CreatedEvent is returned as part of an AssignedEvent, ActiveContract or IncompleteUnassigned (so the event is related to an assignment or unassignment): this will include all parties of the TransactionFilter that are stakeholders of the contract.

Required

signatories : string (repeated)

The signatories for this contract as specified by the template. Required

observers : string (repeated)

The observers for this contract as specified explicitly by the template or implicitly as choice controllers. This field never contains parties that are signatories. Required

agreement_text : google.protobuf.StringValue

The agreement text of the contract. We use StringValue to properly reflect optionality on the wire for backwards compatibility. This is necessary since the empty string is an acceptable (and in fact the default) agreement text, but also the default string in protobuf. This means a newer client works with an older sandbox seamlessly. Optional

created_at : google.protobuf.Timestamp

Ledger effective time of the transaction that created the contract. Required

Event message, v1
An event in the flat transaction stream can either be the creation or the archiving of a contract.

In the transaction service the events are restricted to the events visible for the parties specified in the transaction filter. Each event message type below contains a witness_parties field which indicates the subset of the requested parties that can see the event in question. In the flat transaction stream you‚Äôll only receive events that have witnesses.

oneof event.created : CreatedEvent

oneof event.archived : ArchivedEvent

ExercisedEvent message, v1
Records that a choice has been exercised on a target contract.

event_id : string

The ID of this particular event. Must be a valid LedgerString (as described in value.proto). Required

contract_id : string

The ID of the target contract. Must be a valid LedgerString (as described in value.proto). Required

template_id : Identifier

The template of the target contract. The identifier uses the package-id reference format, with the package id at which the contract was created.

Required

package_name : google.protobuf.StringValue

The package name of the created contract. Optional

interface_id : Identifier

The interface where the choice is defined, if inherited. If defined, the identifier uses the package-id reference format.

Optional

choice : string

The choice that was exercised on the target contract. Must be a valid NameString (as described in value.proto). Required

choice_argument : Value

The argument of the exercised choice. Required

acting_parties : string (repeated)

The parties that exercised the choice. Each element must be a valid PartyIdString (as described in value.proto). Required

consuming : bool

If true, the target contract may no longer be exercised. Required

witness_parties : string (repeated)

The parties that are notified of this event. The witnesses of an exercise node will depend on whether the exercise was consuming or not. If consuming, the witnesses are the union of the stakeholders and the actors. If not consuming, the witnesses are the union of the signatories and the actors. Note that the actors might not necessarily be observers and thus signatories. This is the case when the controllers of a choice are specified using ‚Äúflexible controllers‚Äù, using the choice ... controller syntax, and said controllers are not explicitly marked as observers. Each element must be a valid PartyIdString (as described in value.proto). Required

child_event_ids : string (repeated)

References to further events in the same transaction that appeared as a result of this ExercisedEvent. It contains only the immediate children of this event, not all members of the subtree rooted at this node. The order of the children is the same as the event order in the transaction. Each element must be a valid LedgerString (as described in value.proto). Optional

exercise_result : Value

The result of exercising the choice. Required

choice_package_id : google.protobuf.StringValue

The package of the choice that was exercised, which may be different from the package with which the contract was created.

Optional

InterfaceView message, v1
View of a create event matched by an interface filter.

interface_id : Identifier

The interface implemented by the matched event. The identifier uses the package-id reference format.

Required

view_status : google.rpc.Status

Whether the view was successfully computed, and if not, the reason for the error. The error is reported using the same rules for error codes and messages as the errors returned for API requests. Required

view_value : Record

The value of the interface‚Äôs view method on this event. Set if it was requested in the InterfaceFilter and it could be sucessfully computed. Optional

com/daml/ledger/api/v1/event_query_service.proto

EventQueryService, v1
Query events by contract id or key.

GetEventsByContractId method, v1
Get the create and the consuming exercise event for the contract with the provided ID. No events will be returned for contracts that have been pruned because they have already been archived before the latest pruning offset.

Request: GetEventsByContractIdRequest
Response: GetEventsByContractIdResponse
GetEventsByContractKey method, v1
Get all create and consuming exercise events for the contracts with the provided contract key. Only events for unpruned contracts will be returned. Matching events are delivered in reverse chronological order, i.e., the most recent events are delivered first.

Request: GetEventsByContractKeyRequest
Response: GetEventsByContractKeyResponse
GetEventsByContractIdRequest message, v1
contract_id : string

The contract id being queried. Required

requesting_parties : string (repeated)

The parties whose events the client expects to see. The events associated with the contract id will only be returned if the requesting parties includes at least one party that is a stakeholder of the event. For a definition of stakeholders see https://docs.daml.com/concepts/ledger-model/ledger-privacy.html#contract-observers-and-stakeholders Required

GetEventsByContractIdResponse message, v1
create_event : CreatedEvent

The create event for the contract with the contract_id given in the request provided it exists and has not yet been pruned. Optional

archive_event : ArchivedEvent

The archive event for the contract with the contract_id given in the request provided such an archive event exists and it has not yet been pruned. Optional

GetEventsByContractKeyRequest message, v1
contract_key : Value

The contract key to search for. Required

template_id : Identifier

The template id associated with the contract key Both package-name and package-id reference formats for the identifier are supported.

Required

requesting_parties : string (repeated)

The parties whose events the client expects to see. The events associated with the contract key will only be returned if the requesting parties includes at least one party that is a stakeholder of the event. For a definition of stakeholders see https://docs.daml.com/concepts/ledger-model/ledger-privacy.html#contract-observers-and-stakeholders To gain visibility of all contract key bindings and to ensure consistent performance use a key maintainer as a requesting party. Required

continuation_token : string

A continuation_token associated with a previous response. Optional

GetEventsByContractKeyResponse message, v1
create_event : CreatedEvent

The most recent create event for a contract with the key given in the request, if no continuation_token is provided. If a continuation_token is provided, then this is the most recent create event preceding the create event whose continuation_token was provided. Optional

archive_event : ArchivedEvent

The archive event for the create event provided the created contract is archived. Optional

continuation_token : string

If the continuation_token is populated then there may be additional events available. To retrieve these events use the continuation_token in a subsequent request. Optional

com/daml/ledger/api/v1/experimental_features.proto

AcsActiveAtOffsetFeature message, v1
Whether the Ledger API supports requesting ACS at an offset

supported : bool

CommandDeduplicationFeatures message, v1
Feature descriptors for command deduplication intended to be used for adapting Ledger API tests.

deduplication_period_support : CommandDeduplicationPeriodSupport

deduplication_type : CommandDeduplicationType

max_deduplication_duration_enforced : bool

The ledger will reject any requests which specify a deduplication period which exceeds the specified max deduplication duration. This is also enforced for ledgers that convert deduplication periods specified as offsets to durations.

CommandDeduplicationPeriodSupport message, v1
Feature descriptor specifying how deduplication periods can be specified and how they are handled by the participant node.

offset_support : CommandDeduplicationPeriodSupport.OffsetSupport

duration_support : CommandDeduplicationPeriodSupport.DurationSupport

ExperimentalCommandInspectionService message, v1
Whether the Ledger API supports command inspection service

supported : bool

ExperimentalCommitterEventLog message, v1
How the committer stores events.

event_log_type : ExperimentalCommitterEventLog.CommitterEventLogType

ExperimentalContractIds message, v1
See daml-lf/spec/contract-id.rst for more information on contract ID formats.

v1 : ExperimentalContractIds.ContractIdV1Support

ExperimentalExplicitDisclosure message, v1
Enables the use of explicitly disclosed contracts for command submission

supported : bool

ExperimentalFeatures message, v1
See the feature message definitions for descriptions.

self_service_error_codes : ExperimentalSelfServiceErrorCodes

static_time : ExperimentalStaticTime

command_deduplication : CommandDeduplicationFeatures

optional_ledger_id : ExperimentalOptionalLedgerId

contract_ids : ExperimentalContractIds

committer_event_log : ExperimentalCommitterEventLog

explicit_disclosure : ExperimentalExplicitDisclosure

user_and_party_local_metadata_extensions : ExperimentalUserAndPartyLocalMetadataExtensions

acs_active_at_offset : AcsActiveAtOffsetFeature

template_filters : TransactionsWithTemplateFilters

command_inspection_service : ExperimentalCommandInspectionService

pruned_offsets : StreamingPrunedOffsets

ExperimentalOptionalLedgerId message, v1
Ledger API does not require ledgerId to be set in the requests.

Message has no fields.

ExperimentalSelfServiceErrorCodes message, v1
GRPC self-service error codes are returned by the Ledger API.

Message has no fields.

ExperimentalStaticTime message, v1
Ledger is in the static time mode and exposes a time service.

supported : bool

ExperimentalUserAndPartyLocalMetadataExtensions message, v1
Whether the Ledger API supports: - is_deactivated user property, - metadata with annotations and resource version for users and parties, - update calls for users and parties.

supported : bool

StreamingPrunedOffsets message, v1
Whether the Ledger API supports streaming pruned offsets in the transaction streams

supported : bool

TransactionsWithTemplateFilters message, v1
Whether the Ledger API supports querying for transaction streams using template filters

supported : bool

CommandDeduplicationPeriodSupport.DurationSupport enum, v1
How the participant node supports deduplication periods specified as durations.

DURATION_NATIVE_SUPPORT

0	 
DURATION_CONVERT_TO_OFFSET

1	 
CommandDeduplicationPeriodSupport.OffsetSupport enum, v1
How the participant node supports deduplication periods specified using offsets.

OFFSET_NOT_SUPPORTED

0	 
OFFSET_NATIVE_SUPPORT

1	 
OFFSET_CONVERT_TO_DURATION

2	 
CommandDeduplicationType enum, v1
How the participant node reports duplicate command submissions.

ASYNC_ONLY

0	Duplicate commands are exclusively reported asynchronously via completions.
ASYNC_AND_CONCURRENT_SYNC

1	Commands that are duplicates of concurrently submitted commands are reported synchronously via a gRPC error on the command submission, while all other duplicate commands are reported asynchronously via completions.
ExperimentalCommitterEventLog.CommitterEventLogType enum, v1
CENTRALIZED

0	Default. There is a single log.
DISTRIBUTED

1	There is more than one event log. Usually, when the committer itself is distributed. Or there are per-participant event logs. It may result in transaction IDs being different for the same transaction across participants, for example.
ExperimentalContractIds.ContractIdV1Support enum, v1
SUFFIXED

0	Contract IDs must be suffixed. Distributed ledger implementations must reject non-suffixed contract IDs.
NON_SUFFIXED

1	Contract IDs do not need to be suffixed. This can be useful for shorter contract IDs in centralized committer implementations. Suffixed contract IDs must also be supported.
com/daml/ledger/api/v1/ledger_configuration_service.proto

LedgerConfigurationService, v1
LedgerConfigurationService allows clients to subscribe to changes of the ledger configuration. In V2 Ledger API this service is not available anymore.

GetLedgerConfiguration method, v1
Returns the latest configuration as the first response, and publishes configuration updates in the same stream.

Request: GetLedgerConfigurationRequest
Response: GetLedgerConfigurationResponse
GetLedgerConfigurationRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

GetLedgerConfigurationResponse message, v1
ledger_configuration : LedgerConfiguration

The latest ledger configuration.

LedgerConfiguration message, v1
LedgerConfiguration contains parameters of the ledger instance that may be useful to clients.

max_deduplication_duration : google.protobuf.Duration

If a command submission specifies a deduplication period of length up to max_deduplication_duration, the submission SHOULD not be rejected with FAILED_PRECONDITION because the deduplication period starts too early. The deduplication period is measured on a local clock of the participant or Daml ledger, and therefore subject to clock skews and clock drifts. Command submissions with longer periods MAY get accepted though.

com/daml/ledger/api/v1/ledger_identity_service.proto

LedgerIdentityService, v1
DEPRECATED: This service is now deprecated and ledger identity string is optional for all Ledger API requests.

Allows clients to verify that the server they are communicating with exposes the ledger they wish to operate on. In V2 Ledger API this service is not available anymore.

GetLedgerIdentity method, v1
Clients may call this RPC to return the identifier of the ledger they are connected to.

Request: GetLedgerIdentityRequest
Response: GetLedgerIdentityResponse
GetLedgerIdentityRequest message, v1
Message has no fields.

GetLedgerIdentityResponse message, v1
ledger_id : string

The ID of the ledger exposed by the server. Must be a valid LedgerString (as described in value.proto). Optional

com/daml/ledger/api/v1/ledger_offset.proto

LedgerOffset message, v1
Describes a specific point on the ledger.

The Ledger API endpoints that take offsets allow to specify portions of the ledger that are relevant for the client to read.

Offsets returned by the Ledger API can be used as-is (e.g. to keep track of processed transactions and provide a restart point to use in case of need).

The format of absolute offsets is opaque to the client: no client-side transformation of an offset is guaranteed to return a meaningful offset.

The server implementation ensures internally that offsets are lexicographically comparable.

oneof value.absolute : string

The format of this string is specific to the ledger and opaque to the client.

oneof value.boundary : LedgerOffset.LedgerBoundary

LedgerOffset.LedgerBoundary enum, v1
LEDGER_BEGIN

0	Refers to the first transaction.
LEDGER_END

1	Refers to the currently last transaction, which is a moving target.
com/daml/ledger/api/v1/package_service.proto

PackageService, v1
Allows clients to query the Daml-LF packages that are supported by the server.

ListPackages method, v1
Returns the identifiers of all supported packages.

Request: ListPackagesRequest
Response: ListPackagesResponse
GetPackage method, v1
Returns the contents of a single package.

Request: GetPackageRequest
Response: GetPackageResponse
GetPackageStatus method, v1
Returns the status of a single package.

Request: GetPackageStatusRequest
Response: GetPackageStatusResponse
GetPackageRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

package_id : string

The ID of the requested package. Must be a valid PackageIdString (as described in value.proto). Required

GetPackageResponse message, v1
hash_function : HashFunction

The hash function we use to calculate the hash. Required

archive_payload : bytes

Contains a daml_lf ArchivePayload. See further details in daml_lf.proto. Required

hash : string

The hash of the archive payload, can also used as a package_id. Must be a valid PackageIdString (as described in value.proto). Required

GetPackageStatusRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

package_id : string

The ID of the requested package. Must be a valid PackageIdString (as described in value.proto). Required

GetPackageStatusResponse message, v1
package_status : PackageStatus

The status of the package.

ListPackagesRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

ListPackagesResponse message, v1
package_ids : string (repeated)

The IDs of all Daml-LF packages supported by the server. Each element must be a valid PackageIdString (as described in value.proto). Required

HashFunction enum, v1
SHA256

0	 
PackageStatus enum, v1
UNKNOWN

0	The server is not aware of such a package.
REGISTERED

1	The server is able to execute Daml commands operating on this package.
com/daml/ledger/api/v1/testing/time_service.proto

TimeService, v1/testing
Optional service, exposed for testing static time scenarios.

GetTime method, v1/testing
Returns a stream of time updates. Always returns at least one response, where the first one is the current time. Subsequent responses are emitted whenever the ledger server‚Äôs time is updated.

Request: GetTimeRequest
Response: GetTimeResponse
SetTime method, v1/testing
Allows clients to change the ledger‚Äôs clock in an atomic get-and-set operation.

Request: SetTimeRequest
Response: .google.protobuf.Empty
GetTimeRequest message, v1/testing
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as describe in value.proto). Optional

GetTimeResponse message, v1/testing
current_time : google.protobuf.Timestamp

The current time according to the ledger server.

SetTimeRequest message, v1/testing
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as describe in value.proto). Optional

current_time : google.protobuf.Timestamp

MUST precisely match the current time as it‚Äôs known to the ledger server.

new_time : google.protobuf.Timestamp

The time the client wants to set on the ledger. MUST be a point int time after current_time.

com/daml/ledger/api/v1/trace_context.proto

TraceContext message, v1
traceparent : google.protobuf.StringValue

https://www.w3.org/TR/trace-context/

tracestate : google.protobuf.StringValue

com/daml/ledger/api/v1/transaction.proto

Transaction message, v1
Filtered view of an on-ledger transaction‚Äôs create and archive events.

transaction_id : string

Assigned by the server. Useful for correlating logs. Must be a valid LedgerString (as described in value.proto). Required

command_id : string

The ID of the command which resulted in this transaction. Missing for everyone except the submitting party. Must be a valid LedgerString (as described in value.proto). Optional

workflow_id : string

The workflow ID used in command submission. Must be a valid LedgerString (as described in value.proto). Optional

effective_at : google.protobuf.Timestamp

Ledger effective time. Must be a valid LedgerString (as described in value.proto). Required

events : Event (repeated)

The collection of events. Only contains CreatedEvent or ArchivedEvent. Required

offset : string

The absolute offset. The format of this field is described in ledger_offset.proto. Required

trace_context : TraceContext

Optional; ledger api trace context

The trace context transported in this message corresponds to the trace context supplied by the client application in a HTTP2 header of the original command submission. We typically use a header to transfer this type of information. Here we use message body, because it is used in gRPC streams which do not support per message headers. This field will be populated with the trace context contained in the original submission. If that was not provided, a unique ledger-api-server generated trace context will be used instead.

TransactionTree message, v1
Complete view of an on-ledger transaction.

transaction_id : string

Assigned by the server. Useful for correlating logs. Must be a valid LedgerString (as described in value.proto). Required

command_id : string

The ID of the command which resulted in this transaction. Missing for everyone except the submitting party. Must be a valid LedgerString (as described in value.proto). Optional

workflow_id : string

The workflow ID used in command submission. Only set if the workflow_id for the command was set. Must be a valid LedgerString (as described in value.proto). Optional

effective_at : google.protobuf.Timestamp

Ledger effective time. Required

offset : string

The absolute offset. The format of this field is described in ledger_offset.proto. Required

events_by_id : TransactionTree.EventsByIdEntry (repeated)

Changes to the ledger that were caused by this transaction. Nodes of the transaction tree. Each key be a valid LedgerString (as describe in value.proto). Required

root_event_ids : string (repeated)

Roots of the transaction tree. Each element must be a valid LedgerString (as describe in value.proto). The elements are in the same order as the commands in the corresponding Commands object that triggered this transaction. Required

trace_context : TraceContext

Optional; ledger api trace context

The trace context transported in this message corresponds to the trace context supplied by the client application in a HTTP2 header of the original command submission. We typically use a header to transfer this type of information. Here we use message body, because it is used in gRPC streams which do not support per message headers. This field will be populated with the trace context contained in the original submission. If that was not provided, a unique ledger-api-server generated trace context will be used instead.

TransactionTree.EventsByIdEntry message, v1
key : string

value : TreeEvent

TreeEvent message, v1
Each tree event message type below contains a witness_parties field which indicates the subset of the requested parties that can see the event in question.

Note that transaction trees might contain events with _no_ witness parties, which were included simply because they were children of events which have witnesses.

oneof kind.created : CreatedEvent

oneof kind.exercised : ExercisedEvent

com/daml/ledger/api/v1/transaction_filter.proto

Filters message, v1
The union of a set of contract filters, or a wildcard.

inclusive : InclusiveFilters

If set, then contracts matching any of the InclusiveFilters match this filter. If not set, or if InclusiveFilters has empty template_ids and empty interface_filters: any contract matches this filter. Optional

InclusiveFilters message, v1
A filter that matches all contracts that are either an instance of one of the template_ids or that match one of the interface_filters.

template_ids : Identifier (repeated)

A collection of templates for which the data will be included in the create_arguments of a matching CreatedEvent. SHOULD NOT contain duplicates. All template_ids need to be valid: corresponding templates should be defined in one of the available packages at the time of the query. Deprecated in favor of the template_filters. If the template_filters field is set, the template_ids field is ignored. Optional

interface_filters : InterfaceFilter (repeated)

Include an InterfaceView for every InterfaceFilter matching a contract. The InterfaceFilter instances MUST each use a unique interface_id. Optional

template_filters : TemplateFilter (repeated)

A collection of templates for which the data will be included in the create_arguments of a matching CreatedEvent. SHOULD NOT contain duplicate templates. In contrast to the template_ids field, one can specify whether the create event payloads should be provided alongside the create arguments. If a contract is simultaneously selected by a template filter and one or more interface filters, the corresponding include_created_event_blob are consolidated using an OR operation. Optional

InterfaceFilter message, v1
This filter matches contracts that implement a specific interface.

interface_id : Identifier

The interface that a matching contract must implement. The interface_id needs to be valid: corresponding interface should be defined in one of the available packages at the time of the query. Both package-name and package-id reference formats for the identifier are supported.

Required

include_interface_view : bool

Whether to include the interface view on the contract in the returned CreatedEvent. Use this to access contract data in a uniform manner in your API client. Optional

include_created_event_blob : bool

Whether to include a created_event_blob in the returned CreatedEvent. Use this to access the contract create event payload in your API client for submitting it as a disclosed contract with future commands. Optional

TemplateFilter message, v1
This filter matches contracts of a specific template.

template_id : Identifier

A template for which the payload should be included in the response. The template_id needs to be valid: corresponding template should be defined in one of the available packages at the time of the query. Both package-name and package-id reference formats for the identifier are supported.

Required

include_created_event_blob : bool

Whether to include a created_event_blob in the returned CreatedEvent. Use this to access the contract event payload in your API client for submitting it as a disclosed contract with future commands. Optional

TransactionFilter message, v1
A filter both for filtering create and archive events as well as for filtering transaction trees.

filters_by_party : TransactionFilter.FiltersByPartyEntry (repeated)

Each key must be a valid PartyIdString (as described in value.proto). The interpretation of the filter depends on the stream being filtered:

For transaction tree streams only party filters with wildcards are allowed, and all subtrees whose root has one of the listed parties as an informee are returned.
For transaction and active-contract-set streams create and archive events are returned for all contracts whose stakeholders include at least one of the listed parties and match the per-party filter.
Required

TransactionFilter.FiltersByPartyEntry message, v1
key : string

value : Filters

com/daml/ledger/api/v1/transaction_service.proto

TransactionService, v1
Allows clients to read transactions from the ledger. In V2 Ledger API this service is not available anymore. Use v2.UpdateService instead.

GetTransactions method, v1
Read the ledger‚Äôs filtered transaction stream for a set of parties. Lists only creates and archives, but not other events. Omits all events on transient contracts, i.e., contracts that were both created and archived in the same transaction.

Request: GetTransactionsRequest
Response: GetTransactionsResponse
GetTransactionTrees method, v1
Read the ledger‚Äôs complete transaction tree stream for a set of parties. The stream can be filtered only by parties, but not templates (template filter must be empty).

Request: GetTransactionsRequest
Response: GetTransactionTreesResponse
GetTransactionByEventId method, v1
Lookup a transaction tree by the ID of an event that appears within it. For looking up a transaction instead of a transaction tree, please see GetFlatTransactionByEventId

Request: GetTransactionByEventIdRequest
Response: GetTransactionResponse
GetTransactionById method, v1
Lookup a transaction tree by its ID. For looking up a transaction instead of a transaction tree, please see GetFlatTransactionById

Request: GetTransactionByIdRequest
Response: GetTransactionResponse
GetFlatTransactionByEventId method, v1
Lookup a transaction by the ID of an event that appears within it.

Request: GetTransactionByEventIdRequest
Response: GetFlatTransactionResponse
GetFlatTransactionById method, v1
Lookup a transaction by its ID.

Request: GetTransactionByIdRequest
Response: GetFlatTransactionResponse
GetLedgerEnd method, v1
Get the current ledger end. Subscriptions started with the returned offset will serve transactions created after this RPC was called.

Request: GetLedgerEndRequest
Response: GetLedgerEndResponse
GetLatestPrunedOffsets method, v1
Get the latest successfully pruned ledger offsets

Request: GetLatestPrunedOffsetsRequest
Response: GetLatestPrunedOffsetsResponse
GetFlatTransactionResponse message, v1
transaction : Transaction

GetLatestPrunedOffsetsRequest message, v1
Empty for now, but may contain fields in the future.

Message has no fields.

GetLatestPrunedOffsetsResponse message, v1
participant_pruned_up_to_inclusive : LedgerOffset

The offset up to which the ledger has been pruned, disregarding the state of all divulged contracts pruning.

all_divulged_contracts_pruned_up_to_inclusive : LedgerOffset

The offset up to which all divulged events have been pruned on the ledger. It can be at or before the participant_pruned_up_to_inclusive offset. For more details about all divulged events pruning, see PruneRequest.prune_all_divulged_contracts in participant_pruning_service.proto.

GetLedgerEndRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as describe in value.proto). Optional

GetLedgerEndResponse message, v1
offset : LedgerOffset

The absolute offset of the current ledger end.

GetTransactionByEventIdRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

event_id : string

The ID of a particular event. Must be a valid LedgerString (as described in value.proto). Required

requesting_parties : string (repeated)

The parties whose events the client expects to see. Events that are not visible for the parties in this collection will not be present in the response. Each element must be a valid PartyIdString (as described in value.proto). Required

GetTransactionByIdRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as describe in value.proto). Optional

transaction_id : string

The ID of a particular transaction. Must be a valid LedgerString (as describe in value.proto). Required

requesting_parties : string (repeated)

The parties whose events the client expects to see. Events that are not visible for the parties in this collection will not be present in the response. Each element be a valid PartyIdString (as describe in value.proto). Required

GetTransactionResponse message, v1
transaction : TransactionTree

GetTransactionTreesResponse message, v1
transactions : TransactionTree (repeated)

The list of transaction trees that matches the filter in GetTransactionsRequest for the GetTransactionTrees method.

pruned_offset : string

Current pruned offset. It is sent when following three conditions are met: - a pruning operation has completed - the transaction stream tails the LEDGER_END - the send_pruned_offsets field was set on the corresponding request. The conditions for including the pruned_offset in messages may change in the future implementations. When pruned_offset is set, the message does not contain any transactions in the transactions field.

GetTransactionsRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

begin : LedgerOffset

Beginning of the requested ledger section. This offset is exclusive: the response will only contain transactions whose offset is strictly greater than this. Required

end : LedgerOffset

End of the requested ledger section. This offset is inclusive: the response will only contain transactions whose offset is less than or equal to this. Optional, if not set, the stream will not terminate.

filter : TransactionFilter

Requesting parties with template filters. Template filters must be empty for GetTransactionTrees requests. Required

verbose : bool

If enabled, values served over the API will contain more information than strictly necessary to interpret the data. In particular, setting the verbose flag to true triggers the ledger to include labels for record fields. Optional

send_pruned_offsets : bool

If set to true, the server will send responses containing pruned offset upon pruning completion. Optional

GetTransactionsResponse message, v1
transactions : Transaction (repeated)

The list of transactions that matches the filter in GetTransactionsRequest for the GetTransactions method.

pruned_offset : string

Current pruned offset. It is sent when following three conditions are met: - a pruning operation has completed - the transaction stream tails the LEDGER_END - the send_pruned_offsets field was set on the corresponding request. The conditions for including the pruned_offset in messages may change in the future implementations. When pruned_offset is set, the message does not contain any transactions in the transactions field.

com/daml/ledger/api/v1/value.proto

Enum message, v1
A value with finite set of alternative representations.

enum_id : Identifier

Omitted from the transaction stream when verbose streaming is not enabled. Optional when submitting commands.

constructor : string

Determines which of the Variant‚Äôs alternatives is encoded in this message. Must be a valid NameString. Required

GenMap message, v1
entries : GenMap.Entry (repeated)

GenMap.Entry message, v1
key : Value

value : Value

Identifier message, v1
Unique identifier of an entity. Throughout this API, the following terminology is being used:

if a Daml package-id is encoded in the package_id field, it is referred to as using a ‚Äúpackage-id reference format‚Äù
if a Daml package-name is encoded in the package_id field, it is referred to as using a ‚Äúpackage-name reference format‚Äù
package_id : string

Generally, the identifier of the Daml package that contains the entity. When encoding a package-id, it must be a valid PackageIdString.

The field is overloaded to also be able to contain the package-name of the Daml package. This is supported if the entity referenced is either an interface or template. When representing the Daml package-name, the encoding is of form #<package-name> where # (not a valid package-id character) is used as a discriminator for signalling a package-name encoding.

Required

module_name : string

The dot-separated module name of the identifier. Required

entity_name : string

The dot-separated name of the entity (e.g. record, template, ‚Ä¶) within the module. Required

List message, v1
A homogenous collection of values.

elements : Value (repeated)

The elements must all be of the same concrete value type. Optional

Map message, v1
entries : Map.Entry (repeated)

Map.Entry message, v1
key : string

value : Value

Optional message, v1
Corresponds to Java‚Äôs Optional type, Scala‚Äôs Option, and Haskell‚Äôs Maybe. The reason why we need to wrap this in an additional message is that we need to be able to encode the None case in the Value oneof.

value : Value

optional

Record message, v1
Contains nested values.

record_id : Identifier

Omitted from the transaction stream when verbose streaming is not enabled. Optional when submitting commands.

fields : RecordField (repeated)

The nested values of the record. Required

RecordField message, v1
A named nested value within a record.

label : string

When reading a transaction stream, it‚Äôs omitted if verbose streaming is not enabled. When submitting a commmand, it‚Äôs optional:

if all keys within a single record are present, the order in which fields appear does not matter. however, each key must appear exactly once.
if any of the keys within a single record are omitted, the order of fields MUST match the order of declaration in the Daml template.
Must be a valid NameString

value : Value

A nested value of a record. Required

Value message, v1
Encodes values that the ledger accepts as command arguments and emits as contract arguments.

The values encoding use different classes of non-empty strings as identifiers. Those classes are defined as follows: - NameStrings are strings with length <= 1000 that match the regexp [A-Za-z\$_][A-Za-z0-9\$_]*. - PackageIdStrings are strings with length <= 64 that match the regexp [A-Za-z0-9\-_ ]+. - PartyIdStrings are strings with length <= 255 that match the regexp [A-Za-z0-9:\-_ ]+. - LedgerStrings are strings with length <= 255 that match the regexp [A-Za-z0-9#:\-_/ ]+. - ApplicationIdStrings are strings with length <= 255 that match the regexp [A-Za-z0-9#:\-_/ @\|]+.

oneof Sum.record : Record

oneof Sum.variant : Variant

oneof Sum.contract_id : string

Identifier of an on-ledger contract. Commands which reference an unknown or already archived contract ID will fail. Must be a valid LedgerString.

oneof Sum.list : List

Represents a homogeneous list of values.

oneof Sum.int64 : sint64

oneof Sum.numeric : string

A Numeric, that is a decimal value with precision 38 (at most 38 significant digits) and a scale between 0 and 37 (significant digits on the right of the decimal point). The field has to match the regex:

[+-]?\d{1,38}(.\d{0,37})?
and should be representable by a Numeric without loss of precision.

oneof Sum.text : string

A string.

oneof Sum.timestamp : sfixed64

Microseconds since the UNIX epoch. Can go backwards. Fixed since the vast majority of values will be greater than 2^28, since currently the number of microseconds since the epoch is greater than that. Range: 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999Z, so that we can convert to/from https://www.ietf.org/rfc/rfc3339.txt

oneof Sum.party : string

An agent operating on the ledger. Must be a valid PartyIdString.

oneof Sum.bool : bool

True or false.

oneof Sum.unit : google.protobuf.Empty

This value is used for example for choices that don‚Äôt take any arguments.

oneof Sum.date : int32

Days since the unix epoch. Can go backwards. Limited from 0001-01-01 to 9999-12-31, also to be compatible with https://www.ietf.org/rfc/rfc3339.txt

oneof Sum.optional : Optional

The Optional type, None or Some

oneof Sum.map : Map

The Map type

oneof Sum.enum : Enum

The Enum type

oneof Sum.gen_map : GenMap

The GenMap type

Variant message, v1
A value with alternative representations.

variant_id : Identifier

Omitted from the transaction stream when verbose streaming is not enabled. Optional when submitting commands.

constructor : string

Determines which of the Variant‚Äôs alternatives is encoded in this message. Must be a valid NameString. Required

value : Value

The value encoded within the Variant. Required

com/daml/ledger/api/v1/version_service.proto

VersionService, v1
Allows clients to retrieve information about the ledger API version

GetLedgerApiVersion method, v1
Read the Ledger API version

Request: GetLedgerApiVersionRequest
Response: GetLedgerApiVersionResponse
FeaturesDescriptor message, v1
user_management : UserManagementFeature

If set, then the Ledger API server supports user management. It is recommended that clients query this field to gracefully adjust their behavior for ledgers that do not support user management.

party_management : PartyManagementFeature

If set, then the Ledger API server supports party management configurability. It is recommended that clients query this field to gracefully adjust their behavior to maximum party page size.

experimental : ExperimentalFeatures

Features under development or features that are used for ledger implementation testing purposes only.

Daml applications SHOULD not depend on these in production.

GetLedgerApiVersionRequest message, v1
ledger_id : string

Must correspond to the ledger ID reported by the Ledger Identification Service. Must be a valid LedgerString (as described in value.proto). Optional

GetLedgerApiVersionResponse message, v1
version : string

The version of the ledger API.

features : FeaturesDescriptor

The features supported by this Ledger API endpoint.

Daml applications CAN use the feature descriptor on top of version constraints on the Ledger API version to determine whether a given Ledger API endpoint supports the features required to run the application.

See the feature descriptions themselves for the relation between Ledger API versions and feature presence.

PartyManagementFeature message, v1
max_parties_page_size : int32

The maximum number of parties the server can return in a single response (page).

UserManagementFeature message, v1
supported : bool

Whether the Ledger API server provides the user management service.

max_rights_per_user : int32

The maximum number of rights that can be assigned to a single user. Servers MUST support at least 100 rights per user. A value of 0 means that the server enforces no rights per user limit.

max_users_page_size : int32

The maximum number of users the server can return in a single response (page). Servers MUST support at least a 100 users per page. A value of 0 means that the server enforces no page size limit.

com/daml/ledger/api/v2/command_completion_service.proto

CommandCompletionService, v2
Allows clients to observe the status of their submissions. Commands may be submitted via the Command Submission Service. The on-ledger effects of their submissions are disclosed by the Update Service.

Commands may fail in 2 distinct manners:

Failure communicated synchronously in the gRPC error of the submission.
Failure communicated asynchronously in a Completion, see completion.proto.
Note that not only successfully submitted commands MAY produce a completion event. For example, the participant MAY choose to produce a completion event for a rejection of a duplicate command.

Clients that do not receive a successful completion about their submission MUST NOT assume that it was successful. Clients SHOULD subscribe to the CompletionStream before starting to submit commands to prevent race conditions.

CompletionStream method, v2
Subscribe to command completion events.

Request: CompletionStreamRequest
Response: CompletionStreamResponse
CompletionStreamRequest message, v2
application_id : string

Only completions of commands submitted with the same application_id will be visible in the stream. Must be a valid ApplicationIdString (as described in value.proto). Required unless authentication is used with a user token or a custom token specifying an application-id. In that case, the token‚Äôs user-id, respectively application-id, will be used for the request‚Äôs application_id.

parties : string (repeated)

Non-empty list of parties whose data should be included. Only completions of commands for which at least one of the act_as parties is in the given set of parties will be visible in the stream. Must be a valid PartyIdString (as described in value.proto). Required

begin_exclusive : ParticipantOffset

This field indicates the minimum offset for completions. This can be used to resume an earlier completion stream. Optional, if not set the ledger uses the current ledger end offset instead.

CompletionStreamResponse message, v2
checkpoint : com.daml.ledger.api.v1.Checkpoint

This checkpoint may be used to restart consumption. The checkpoint belongs to the completion in this response. Required

completion : Completion

Required

domain_id : string

The sequencing domain. In case

successful/failed transactions: identifies the sequencing domain of the transaction
for successful/failed unassign commands: identifies the source domain
for successful/failed assign commands: identifies the target domain
Required

com/daml/ledger/api/v2/command_service.proto

CommandService, v2
Command Service is able to correlate submitted commands with completion data, identify timeouts, and return contextual information with each tracking result. This supports the implementation of stateless clients.

Note that submitted commands generally produce completion events as well, even in case a command gets rejected. For example, the participant SHOULD produce a completion event for a rejection of a duplicate command.

SubmitAndWait method, v2
Submits a single composite command and waits for its result. Propagates the gRPC error of failed submissions including Daml interpretation errors.

Request: SubmitAndWaitRequest
Response: .google.protobuf.Empty
SubmitAndWaitForUpdateId method, v2
Submits a single composite command, waits for its result, and returns the update id. Propagates the gRPC error of failed submissions including Daml interpretation errors.

Request: SubmitAndWaitRequest
Response: SubmitAndWaitForUpdateIdResponse
SubmitAndWaitForTransaction method, v2
Submits a single composite command, waits for its result, and returns the transaction. Propagates the gRPC error of failed submissions including Daml interpretation errors.

Request: SubmitAndWaitRequest
Response: SubmitAndWaitForTransactionResponse
SubmitAndWaitForTransactionTree method, v2
Submits a single composite command, waits for its result, and returns the transaction tree. Propagates the gRPC error of failed submissions including Daml interpretation errors.

Request: SubmitAndWaitRequest
Response: SubmitAndWaitForTransactionTreeResponse
SubmitAndWaitForTransactionResponse message, v2
transaction : Transaction

The flat transaction that resulted from the submitted command. Required

completion_offset : string

The format of this field is described in participant_offset.proto. Optional

SubmitAndWaitForTransactionTreeResponse message, v2
transaction : TransactionTree

The transaction tree that resulted from the submitted command. Required

completion_offset : string

The format of this field is described in participant_offset.proto. Optional

SubmitAndWaitForUpdateIdResponse message, v2
update_id : string

The id of the transaction that resulted from the submitted command. Must be a valid LedgerString (as described in value.proto). Required

completion_offset : string

The format of this field is described in participant_offset.proto. Optional

SubmitAndWaitRequest message, v2
These commands are atomic, and will become transactions.

commands : Commands

The commands to be submitted. Required

com/daml/ledger/api/v2/command_submission_service.proto

CommandSubmissionService, v2
Allows clients to attempt advancing the ledger‚Äôs state by submitting commands. The final states of their submissions are disclosed by the Command Completion Service. The on-ledger effects of their submissions are disclosed by the Update Service.

Commands may fail in 2 distinct manners:

Failure communicated synchronously in the gRPC error of the submission.
Failure communicated asynchronously in a Completion, see completion.proto.
Note that not only successfully submitted commands MAY produce a completion event. For example, the participant MAY choose to produce a completion event for a rejection of a duplicate command.

Clients that do not receive a successful completion about their submission MUST NOT assume that it was successful. Clients SHOULD subscribe to the CompletionStream before starting to submit commands to prevent race conditions.

Submit method, v2
Submit a single composite command.

Request: SubmitRequest
Response: SubmitResponse
SubmitReassignment method, v2
Submit a single reassignment.

Request: SubmitReassignmentRequest
Response: SubmitReassignmentResponse
SubmitReassignmentRequest message, v2
reassignment_command : ReassignmentCommand

The reassignment command to be submitted. Required

SubmitReassignmentResponse message, v2
Message has no fields.

SubmitRequest message, v2
The submitted commands will be processed atomically in a single transaction. Moreover, each Command in commands will be executed in the order specified by the request.

commands : Commands

The commands to be submitted in a single transaction. Required

SubmitResponse message, v2
Message has no fields.

com/daml/ledger/api/v2/commands.proto

Commands message, v2
A composite command that groups multiple commands together.

workflow_id : string

Identifier of the on-ledger workflow that this command is a part of. Must be a valid LedgerString (as described in value.proto). Optional

application_id : string

Uniquely identifies the application or participant user that issued the command. Must be a valid ApplicationIdString (as described in value.proto). Required unless authentication is used with a user token or a custom token specifying an application-id. In that case, the token‚Äôs user-id, respectively application-id, will be used for the request‚Äôs application_id.

command_id : string

Uniquely identifies the command. The triple (application_id, party + act_as, command_id) constitutes the change ID for the intended ledger change, where party + act_as is interpreted as a set of party names. The change ID can be used for matching the intended ledger changes with all their completions. Must be a valid LedgerString (as described in value.proto). Required

party : string

Party on whose behalf the command should be executed. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to act on behalf of the given party. Must be a valid PartyIdString (as described in value.proto). Deprecated in favor of the act_as field. If both are set, then the effective list of parties on whose behalf the command should be executed is the union of all parties listed in party and act_as. Optional

commands : com.daml.ledger.api.v1.Command (repeated)

Individual elements of this atomic command. Must be non-empty. Required

oneof deduplication_period.deduplication_duration : google.protobuf.Duration

Specifies the length of the deduplication period. It is interpreted relative to the local clock at some point during the submission‚Äôs processing. Must be non-negative. Must not exceed the maximum deduplication time (see ledger_configuration_service.proto).

oneof deduplication_period.deduplication_offset : string

Specifies the start of the deduplication period by a completion stream offset (exclusive). Must be a valid LedgerString (as described in participant_offset.proto).

min_ledger_time_abs : google.protobuf.Timestamp

Lower bound for the ledger time assigned to the resulting transaction. Note: The ledger time of a transaction is assigned as part of command interpretation. Use this property if you expect that command interpretation will take a considerate amount of time, such that by the time the resulting transaction is sequenced, its assigned ledger time is not valid anymore. Must not be set at the same time as min_ledger_time_rel. Optional

min_ledger_time_rel : google.protobuf.Duration

Same as min_ledger_time_abs, but specified as a duration, starting from the time the command is received by the server. Must not be set at the same time as min_ledger_time_abs. Optional

act_as : string (repeated)

Set of parties on whose behalf the command should be executed. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to act on behalf of each of the given parties. This field supersedes the party field. The effective set of parties on whose behalf the command should be executed is the union of all parties listed in party and act_as, which must be non-empty. Each element must be a valid PartyIdString (as described in value.proto). Optional

read_as : string (repeated)

Set of parties on whose behalf (in addition to all parties listed in act_as) contracts can be retrieved. This affects Daml operations such as fetch, fetchByKey, lookupByKey, exercise, and exerciseByKey. Note: A participant node of a Daml network can host multiple parties. Each contract present on the participant node is only visible to a subset of these parties. A command can only use contracts that are visible to at least one of the parties in act_as or read_as. This visibility check is independent from the Daml authorization rules for fetch operations. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to read contract data on behalf of each of the given parties. Optional

submission_id : string

A unique identifier to distinguish completions for different submissions with the same change ID. Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission with the same change ID. Must be a valid LedgerString (as described in value.proto).

If omitted, the participant or the committer may set a value of their choice. Optional

disclosed_contracts : com.daml.ledger.api.v1.DisclosedContract (repeated)

Additional contracts used to resolve contract & contract key lookups. Optional

domain_id : string

Must be a valid domain ID Required

package_id_selection_preference : string (repeated)

The package-id selection preference of the client for resolving package names and interface instances in command submission and interpretation

com/daml/ledger/api/v2/completion.proto

Completion message, v2
A completion represents the status of a submitted command on the ledger: it can be successful or failed.

command_id : string

The ID of the succeeded or failed command. Must be a valid LedgerString (as described in value.proto). Required

status : google.rpc.Status

Identifies the exact type of the error. It uses the same format of conveying error details as it is used for the RPC responses of the APIs. Optional

update_id : string

The update_id of the transaction or reassignment that resulted from the command with command_id. Only set for successfully executed commands. Must be a valid LedgerString (as described in value.proto).

application_id : string

The application-id or user-id that was used for the submission, as described in commands.proto. Must be a valid ApplicationIdString (as described in value.proto). Optional for historic completions where this data is not available.

act_as : string (repeated)

The set of parties on whose behalf the commands were executed. Contains the union of party and act_as from commands.proto. The order of the parties need not be the same as in the submission. Each element must be a valid PartyIdString (as described in value.proto). Optional for historic completions where this data is not available.

submission_id : string

The submission ID this completion refers to, as described in commands.proto. Must be a valid LedgerString (as described in value.proto). Optional

oneof deduplication_period.deduplication_offset : string

Specifies the start of the deduplication period by a completion stream offset (exclusive).

Must be a valid LedgerString (as described in value.proto).

oneof deduplication_period.deduplication_duration : google.protobuf.Duration

Specifies the length of the deduplication period. It is measured in record time of completions.

Must be non-negative.

trace_context : com.daml.ledger.api.v1.TraceContext

Optional; ledger api trace context

The trace context transported in this message corresponds to the trace context supplied by the client application in a HTTP2 header of the original command submission. We typically use a header to transfer this type of information. Here we use message body, because it is used in gRPC streams which do not support per message headers. This field will be populated with the trace context contained in the original submission. If that was not provided, a unique ledger-api-server generated trace context will be used instead.

com/daml/ledger/api/v2/event_query_service.proto

EventQueryService, v2
Query events by contract id.

Note that querying by contract key is not (yet) supported, as contract keys are not supported (yet) in multi-domain scenarios.

GetEventsByContractId method, v2
Get the create and the consuming exercise event for the contract with the provided ID. No events will be returned for contracts that have been pruned because they have already been archived before the latest pruning offset.

Request: .com.daml.ledger.api.v1.GetEventsByContractIdRequest
Response: GetEventsByContractIdResponse
Archived message, v2
archived_event : com.daml.ledger.api.v1.ArchivedEvent

Required

domain_id : string

Required The domain which sequenced the archival of the contract

Created message, v2
created_event : com.daml.ledger.api.v1.CreatedEvent

Required

domain_id : string

The domain which sequenced the creation of the contract Required

GetEventsByContractIdResponse message, v2
created : Created

The create event for the contract with the contract_id given in the request provided it exists and has not yet been pruned. Optional

archived : Archived

The archive event for the contract with the contract_id given in the request provided such an archive event exists and it has not yet been pruned. Optional

com/daml/ledger/api/v2/package_service.proto

PackageService, v2
Allows clients to query the Daml-LF packages that are supported by the server.

ListPackages method, v2
Returns the identifiers of all supported packages.

Request: ListPackagesRequest
Response: .com.daml.ledger.api.v1.ListPackagesResponse
GetPackage method, v2
Returns the contents of a single package.

Request: GetPackageRequest
Response: .com.daml.ledger.api.v1.GetPackageResponse
GetPackageStatus method, v2
Returns the status of a single package.

Request: GetPackageStatusRequest
Response: .com.daml.ledger.api.v1.GetPackageStatusResponse
GetPackageRequest message, v2
package_id : string

The ID of the requested package. Must be a valid PackageIdString (as described in value.proto). Required

GetPackageStatusRequest message, v2
package_id : string

The ID of the requested package. Must be a valid PackageIdString (as described in value.proto). Required

ListPackagesRequest message, v2
Message has no fields.

com/daml/ledger/api/v2/participant_offset.proto

ParticipantOffset message, v2
Describes a specific point on the participant. This is a participant local value: a participant offset is meaningful only in the context of its participant. Different participants may associate different offsets to the same change synchronized over a domain, and conversely, the same literal participant offset may refer to different changes on different participants.

This is also a unique index of the changes which happened on the virtual shared ledger. Participant offset define an order, which is the same in which order the updates are visible as subscribing to the UpdateService. This ordering is also a fully causal ordering for one specific domain: for two updates synchronized by the same domain, the one with a bigger participant offset happened after than the one with a smaller participant offset. Please note this is not true for updates synchronized by a different domain. Accordingly, the participant offset order may deviate from the order of the changes on the virtual shared ledger.

The Ledger API endpoints that take offsets allow to specify portions of the participant that are relevant for the client to read.

Offsets returned by the Ledger API can be used as-is (e.g. to keep track of processed transactions and provide a restart point to use in case of need).

The format of absolute offsets is opaque to the client: no client-side transformation of an offset is guaranteed to return a meaningful offset.

The server implementation ensures internally that offsets are lexicographically comparable.

oneof value.absolute : string

The format of this string is specific to the participant and opaque to the client.

oneof value.boundary : ParticipantOffset.ParticipantBoundary

ParticipantOffset.ParticipantBoundary enum, v2
PARTICIPANT_BEGIN

0	Refers to the first transaction.
PARTICIPANT_END

1	Refers to the currently last transaction, which is a moving target.
com/daml/ledger/api/v2/reassignment.proto

AssignedEvent message, v2
Records that a contract has been assigned, and it can be used on the target domain.

source : string

The ID of the source domain. Must be a valid domain ID. Required

target : string

The ID of the target domain. Must be a valid domain ID. Required

unassign_id : string

The ID from the unassigned event. For correlation capabilities. For one contract the (unassign_id, source domain) pair is unique. Must be a valid LedgerString (as described in value.proto). Required

submitter : string

Party on whose behalf the assign command was executed. Empty if the assignment happened offline via the repair service. Must be a valid PartyIdString (as described in value.proto). Optional

reassignment_counter : uint64

Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter equals zero. Required

created_event : com.daml.ledger.api.v1.CreatedEvent

Required

Reassignment message, v2
Complete view of an on-ledger reassignment.

update_id : string

Assigned by the server. Useful for correlating logs. Must be a valid LedgerString (as described in value.proto). Required

command_id : string

The ID of the command which resulted in this reassignment. Missing for everyone except the submitting party on the submitting participant. Must be a valid LedgerString (as described in value.proto). Optional

workflow_id : string

The workflow ID used in reassignment command submission. Only set if the workflow_id for the command was set. Must be a valid LedgerString (as described in value.proto). Optional

offset : string

The absolute offset. The format of this field is described in participant_offset.proto. Required

oneof event.unassigned_event : UnassignedEvent

oneof event.assigned_event : AssignedEvent

trace_context : com.daml.ledger.api.v1.TraceContext

Optional; ledger api trace context

The trace context transported in this message corresponds to the trace context supplied by the client application in a HTTP2 header of the original command submission. We typically use a header to transfer this type of information. Here we use message body, because it is used in gRPC streams which do not support per message headers. This field will be populated with the trace context contained in the original submission. If that was not provided, a unique ledger-api-server generated trace context will be used instead.

UnassignedEvent message, v2
Records that a contract has been unassigned, and it becomes unusable on the source domain

unassign_id : string

The ID of the unassignment. This needs to be used as an input for a assign ReassignmentCommand. For one contract the (unassign_id, source domain) pair is unique. Must be a valid LedgerString (as described in value.proto). Required

contract_id : string

The ID of the reassigned contract. Must be a valid LedgerString (as described in value.proto). Required

template_id : com.daml.ledger.api.v1.Identifier

The template of the reassigned contract.
Required
source : string

The ID of the source domain Must be a valid domain ID Required

target : string

The ID of the target domain Must be a valid domain ID Required

submitter : string

Party on whose behalf the unassign command was executed. Empty if the unassignment happened offline via the repair service. Must be a valid PartyIdString (as described in value.proto). Optional

reassignment_counter : uint64

Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter equals zero. Required

assignment_exclusivity : google.protobuf.Timestamp

Assignment exclusivity Before this time (measured on the target domain), only the submitter of the unassignment can initiate the assignment Defined for reassigning participants. Optional

witness_parties : string (repeated)

The parties that are notified of this event. Required

com/daml/ledger/api/v2/reassignment_command.proto

AssignCommand message, v2
Assign a contract

unassign_id : string

The ID from the unassigned event to be completed by this assignment. Must be a valid LedgerString (as described in value.proto). Required

source : string

The ID of the source domain Must be a valid domain ID Required

target : string

The ID of the target domain Must be a valid domain ID Required

ReassignmentCommand message, v2
workflow_id : string

Identifier of the on-ledger workflow that this command is a part of. Must be a valid LedgerString (as described in value.proto). Optional

application_id : string

Uniquely identifies the application or participant user that issued the command. Must be a valid ApplicationIdString (as described in value.proto). Required unless authentication is used with a user token or a custom token specifying an application-id. In that case, the token‚Äôs user-id, respectively application-id, will be used for the request‚Äôs application_id.

command_id : string

Uniquely identifies the command. The triple (application_id, submitter, command_id) constitutes the change ID for the intended ledger change. The change ID can be used for matching the intended ledger changes with all their completions. Must be a valid LedgerString (as described in value.proto). Required

submitter : string

Party on whose behalf the command should be executed. If ledger API authorization is enabled, then the authorization metadata must authorize the sender of the request to act on behalf of the given party. Must be a valid PartyIdString (as described in value.proto). Required

oneof command.unassign_command : UnassignCommand

oneof command.assign_command : AssignCommand

submission_id : string

A unique identifier to distinguish completions for different submissions with the same change ID. Typically a random UUID. Applications are expected to use a different UUID for each retry of a submission with the same change ID. Must be a valid LedgerString (as described in value.proto).

If omitted, the participant or the committer may set a value of their choice. Optional

UnassignCommand message, v2
Unassign a contract

contract_id : string

The ID of the contract the client wants to unassign. Must be a valid LedgerString (as described in value.proto). Required

source : string

The ID of the source domain Must be a valid domain ID Required

target : string

The ID of the target domain Must be a valid domain ID Required

com/daml/ledger/api/v2/state_service.proto

StateService, v2
Allows clients to get state from the ledger.

GetActiveContracts method, v2
Returns a stream of the snapshot of the active contracts and incomplete reassignments at a ledger offset. If there are no active contracts, the stream returns a single response message with the offset at which the snapshot has been taken. Clients SHOULD use the offset in the last GetActiveContractsResponse message to continue streaming transactions with the update service. Clients SHOULD NOT assume that the set of active contracts they receive reflects the state at the ledger end.

Request: GetActiveContractsRequest
Response: GetActiveContractsResponse
GetConnectedDomains method, v2
Get the list of connected domains at the time of the query.

Request: GetConnectedDomainsRequest
Response: GetConnectedDomainsResponse
GetLedgerEnd method, v2
Get the current ledger end. Subscriptions started with the returned offset will serve events after this RPC was called.

Request: GetLedgerEndRequest
Response: GetLedgerEndResponse
GetLatestPrunedOffsets method, v2
Get the latest successfully pruned ledger offsets

Request: GetLatestPrunedOffsetsRequest
Response: GetLatestPrunedOffsetsResponse
ActiveContract message, v2
created_event : com.daml.ledger.api.v1.CreatedEvent

Required

domain_id : string

A valid domain ID Required

reassignment_counter : uint64

Each corresponding assigned and unassigned event has the same reassignment_counter. This strictly increases with each unassign command for the same contract. Creation of the contract corresponds to reassignment_counter equals zero. This field will be the reassignment_counter of the latest observable activation event on this domain, which is before the active_at_offset. Required

GetActiveContractsRequest message, v2
filter : TransactionFilter

Templates to include in the served snapshot, per party. Required

verbose : bool

If enabled, values served over the API will contain more information than strictly necessary to interpret the data. In particular, setting the verbose flag to true triggers the ledger to include labels for record fields. Optional

active_at_offset : string

The offset at which the snapshot of the active contracts will be computed. Must be no greater than the current ledger end offset. Must be greater than or equal to the last pruning offset. If not set the current ledger end offset will be used. Optional

GetActiveContractsResponse message, v2
offset : string

Included only in the last message. The client should start consuming the transactions endpoint with this offset. The format of this field is described in participant_offset.proto.

workflow_id : string

The workflow ID used in command submission which corresponds to the contract_entry. Only set if the workflow_id for the command was set. Must be a valid LedgerString (as described in value.proto). Optional

oneof contract_entry.active_contract : ActiveContract

The contract is active on the given domain, meaning: there was an activation event on the given domain ( created, assigned), which is not followed by a deactivation event (archived, unassigned) on the same domain, until the active_at_offset. Since activeness is defined as a per domain concept, it is possible, that a contract is active on one domain, but already archived on another. There will be one such message for each domain the contract is active on.

oneof contract_entry.incomplete_unassigned : IncompleteUnassigned

Included iff the unassigned event was before or at the active_at_offset, but there was no corresponding assigned event before or at the active_at_offset.

oneof contract_entry.incomplete_assigned : IncompleteAssigned

Important: this message is not indicating that the contract is active on the target domain! Included iff the assigned event was before or at the active_at_offset, but there was no corresponding unassigned event before or at the active_at_offset.

GetConnectedDomainsRequest message, v2
party : string

The party of interest Must be a valid PartyIdString (as described in value.proto). Required

GetConnectedDomainsResponse message, v2
connected_domains : GetConnectedDomainsResponse.ConnectedDomain (repeated)

GetConnectedDomainsResponse.ConnectedDomain message, v2
domain_alias : string

The alias of the domain Required

domain_id : string

The ID of the domain Required

permission : ParticipantPermission

The permission on the domain Required

GetLatestPrunedOffsetsRequest message, v2
Empty for now, but may contain fields in the future.

Message has no fields.

GetLatestPrunedOffsetsResponse message, v2
participant_pruned_up_to_inclusive : ParticipantOffset

The offset up to which the ledger has been pruned, disregarding the state of all divulged contracts pruning.

all_divulged_contracts_pruned_up_to_inclusive : ParticipantOffset

The offset up to which all divulged events have been pruned on the ledger. It can be at or before the participant_pruned_up_to_inclusive offset. For more details about all divulged events pruning, see PruneRequest.prune_all_divulged_contracts in participant_pruning_service.proto.

GetLedgerEndRequest message, v2
Message has no fields.

GetLedgerEndResponse message, v2
offset : ParticipantOffset

The absolute offset of the current ledger end.

IncompleteAssigned message, v2
assigned_event : AssignedEvent

Required

IncompleteUnassigned message, v2
created_event : com.daml.ledger.api.v1.CreatedEvent

Required

unassigned_event : UnassignedEvent

Required

ParticipantPermission enum, v2
Enum indicating the permission level that the participant has for the party whose connected domains are being listed.

Submission

0	 
Confirmation

1	participant can only confirm transactions
Observation

2	participant can only observe transactions
com/daml/ledger/api/v2/testing/time_service.proto

TimeService, v2/testing
Optional service, exposed for testing static time scenarios.

GetTime method, v2/testing
Returns the current time according to the ledger server.

Request: GetTimeRequest
Response: GetTimeResponse
SetTime method, v2/testing
Allows clients to change the ledger‚Äôs clock in an atomic get-and-set operation.

Request: SetTimeRequest
Response: .google.protobuf.Empty
GetTimeRequest message, v2/testing
Message has no fields.

GetTimeResponse message, v2/testing
current_time : google.protobuf.Timestamp

The current time according to the ledger server.

SetTimeRequest message, v2/testing
current_time : google.protobuf.Timestamp

MUST precisely match the current time as it‚Äôs known to the ledger server.

new_time : google.protobuf.Timestamp

The time the client wants to set on the ledger. MUST be a point int time after current_time.

com/daml/ledger/api/v2/transaction.proto

Transaction message, v2
Filtered view of an on-ledger transaction‚Äôs create and archive events.

update_id : string

Assigned by the server. Useful for correlating logs. Must be a valid LedgerString (as described in value.proto). Required

command_id : string

The ID of the command which resulted in this transaction. Missing for everyone except the submitting party. Must be a valid LedgerString (as described in value.proto). Optional

workflow_id : string

The workflow ID used in command submission. Must be a valid LedgerString (as described in value.proto). Optional

effective_at : google.protobuf.Timestamp

Ledger effective time. Must be a valid LedgerString (as described in value.proto). Required

events : com.daml.ledger.api.v1.Event (repeated)

The collection of events. Only contains CreatedEvent or ArchivedEvent. Required

offset : string

The absolute offset. The format of this field is described in participant_offset.proto. Required

domain_id : string

A valid domain ID. Identifies the domain that synchronized the transaction. Required

trace_context : com.daml.ledger.api.v1.TraceContext

Optional; ledger api trace context

The trace context transported in this message corresponds to the trace context supplied by the client application in a HTTP2 header of the original command submission. We typically use a header to transfer this type of information. Here we use message body, because it is used in gRPC streams which do not support per message headers. This field will be populated with the trace context contained in the original submission. If that was not provided, a unique ledger-api-server generated trace context will be used instead.

TransactionTree message, v2
Complete view of an on-ledger transaction.

update_id : string

Assigned by the server. Useful for correlating logs. Must be a valid LedgerString (as described in value.proto). Required

command_id : string

The ID of the command which resulted in this transaction. Missing for everyone except the submitting party. Must be a valid LedgerString (as described in value.proto). Optional

workflow_id : string

The workflow ID used in command submission. Only set if the workflow_id for the command was set. Must be a valid LedgerString (as described in value.proto). Optional

effective_at : google.protobuf.Timestamp

Ledger effective time. Required

offset : string

The absolute offset. The format of this field is described in participant_offset.proto. Required

events_by_id : TransactionTree.EventsByIdEntry (repeated)

Changes to the ledger that were caused by this transaction. Nodes of the transaction tree. Each key be a valid LedgerString (as describe in value.proto). Required

root_event_ids : string (repeated)

Roots of the transaction tree. Each element must be a valid LedgerString (as describe in value.proto). The elements are in the same order as the commands in the corresponding Commands object that triggered this transaction. Required

domain_id : string

A valid domain ID. Identifies the domain that synchronized the transaction. Required

trace_context : com.daml.ledger.api.v1.TraceContext

Optional; ledger api trace context

The trace context transported in this message corresponds to the trace context supplied by the client application in a HTTP2 header of the original command submission. We typically use a header to transfer this type of information. Here we use message body, because it is used in gRPC streams which do not support per message headers. This field will be populated with the trace context contained in the original submission. If that was not provided, a unique ledger-api-server generated trace context will be used instead.

TransactionTree.EventsByIdEntry message, v2
key : string

value : com.daml.ledger.api.v1.TreeEvent

com/daml/ledger/api/v2/transaction_filter.proto

TransactionFilter message, v2
A filter both for filtering create and archive events as well as for filtering transaction trees.

filters_by_party : TransactionFilter.FiltersByPartyEntry (repeated)

Each key must be a valid PartyIdString (as described in value.proto). The interpretation of the filter depends on the stream being filtered:

For transaction tree streams all party keys used as wildcard filters, and all subtrees whose root has one of the listed parties as an informee are returned. If there are InclusiveFilters, those will control returned CreatedEvent fields were applicable, but not used for template/interface filtering.
For transaction and active-contract-set streams create and archive events are returned for all contracts whose stakeholders include at least one of the listed parties and match the per-party filter.
Required

TransactionFilter.FiltersByPartyEntry message, v2
key : string

value : com.daml.ledger.api.v1.Filters

com/daml/ledger/api/v2/update_service.proto

UpdateService, v2
Allows clients to read updates (transactions and reassignments) from the ledger.

GetUpdates and GetUpdateTrees provide a comprehensive stream of updates/changes which happened on the virtual shared ledger. These streams are indexed with ledger offsets, which are strictly increasing. The virtual shared ledger consist of changes happening on multiple domains which are connected to the serving participant. Each update belongs to one domain, this is provided in the result (the domain_id field in Transaction and TransactionTree for transactions, the source field in UnassignedEvent and the target field in AssignedEvent). Consumers can rely on strong causal guarantees on the virtual shared ledger for a single domain: updates which have greater offsets are happened after than updates with smaller offsets for the same domain. Across different domains this is not guaranteed.

GetUpdates method, v2
Read the ledger‚Äôs filtered transaction stream and related reassignments for a set of parties. For transactions it lists only creates and archives, but no other events. Omits all events on transient contracts, i.e., contracts that were both created and archived in the same transaction.

Request: GetUpdatesRequest
Response: GetUpdatesResponse
GetUpdateTrees method, v2
Read the ledger‚Äôs complete transaction tree stream and related reassignments for a set of parties. The stream will be filtered only by the parties as wildcard parties. The template/interface filters describe the respective fields in the CreatedEvent results.

Request: GetUpdatesRequest
Response: GetUpdateTreesResponse
GetTransactionTreeByEventId method, v2
Lookup a transaction tree by the ID of an event that appears within it. For looking up a transaction instead of a transaction tree, please see GetTransactionByEventId

Request: GetTransactionByEventIdRequest
Response: GetTransactionTreeResponse
GetTransactionTreeById method, v2
Lookup a transaction tree by its ID. For looking up a transaction instead of a transaction tree, please see GetTransactionById

Request: GetTransactionByIdRequest
Response: GetTransactionTreeResponse
GetTransactionByEventId method, v2
Lookup a transaction by the ID of an event that appears within it.

Request: GetTransactionByEventIdRequest
Response: GetTransactionResponse
GetTransactionById method, v2
Lookup a transaction by its ID.

Request: GetTransactionByIdRequest
Response: GetTransactionResponse
GetTransactionByEventIdRequest message, v2
event_id : string

The ID of a particular event. Must be a valid LedgerString (as described in value.proto). Required

requesting_parties : string (repeated)

The parties whose events the client expects to see. Events that are not visible for the parties in this collection will not be present in the response. Each element must be a valid PartyIdString (as described in value.proto). Required

GetTransactionByIdRequest message, v2
update_id : string

The ID of a particular transaction. Must be a valid LedgerString (as describe in value.proto). Required

requesting_parties : string (repeated)

The parties whose events the client expects to see. Events that are not visible for the parties in this collection will not be present in the response. Each element be a valid PartyIdString (as describe in value.proto). Required

GetTransactionResponse message, v2
transaction : Transaction

Required

GetTransactionTreeResponse message, v2
transaction : TransactionTree

Required

GetUpdateTreesResponse message, v2
oneof update.transaction_tree : TransactionTree

oneof update.reassignment : Reassignment

pruned_offset : string

Current pruned offset. It is sent when following three conditions are met: - a pruning operation has completed - the transaction stream tails the LEDGER_END - the send_pruned_offsets field was set on the corresponding request. The conditions for including the pruned_offset in messages may change in the future implementations. When pruned_offset is set, the message does not contain any transactions in the transactions field.

GetUpdatesRequest message, v2
begin_exclusive : ParticipantOffset

Beginning of the requested ledger section. The response will only contain transactions whose offset is strictly greater than this. Required

end_inclusive : ParticipantOffset

End of the requested ledger section. The response will only contain transactions whose offset is less than or equal to this. Optional, if not set, the stream will not terminate.

filter : TransactionFilter

Requesting parties with template filters. Template filters must be empty for GetUpdateTrees requests. Required

verbose : bool

If enabled, values served over the API will contain more information than strictly necessary to interpret the data. In particular, setting the verbose flag to true triggers the ledger to include labels, record and variant type ids for record fields. Optional

send_pruned_offsets : bool

If set to true, the server will send responses containing pruned offset upon pruning completion. Optional

GetUpdatesResponse message, v2
oneof update.transaction : Transaction

oneof update.reassignment : Reassignment

pruned_offset : string

Current pruned offset. It is sent when following three conditions are met: - a pruning operation has completed - the transaction stream tails the LEDGER_END - the send_pruned_offsets field was set on the corresponding request. The conditions for including the pruned_offset in messages may change in the future implementations. When pruned_offset is set, the message does not contain any transactions in the transactions field.

com/daml/ledger/api/v2/version_service.proto

VersionService, v2
Allows clients to retrieve information about the ledger API version

GetLedgerApiVersion method, v2
Read the Ledger API version

Request: GetLedgerApiVersionRequest
Response: .com.daml.ledger.api.v1.GetLedgerApiVersionResponse
GetLedgerApiVersionRequest message, v2
Message has no fields.

Scalar Value Types
double

Java	Python	C++	C#
double	float	double	double
float

Java	Python	C++	C#
float	float	float	float
int32

Uses variable-length encoding. Inefficient for encoding negative numbers ‚Äì if your field is likely to have negative values, use sint32 instead.

Java	Python	C++	C#
int	int	int32	int
int64

Uses variable-length encoding. Inefficient for encoding negative numbers ‚Äì if your field is likely to have negative values, use sint64 instead.

Java	Python	C++	C#
long	int/long	int64	long
uint32

Uses variable-length encoding.

Java	Python	C++	C#
int	int/long	uint32	uint
uint64

Uses variable-length encoding.

Java	Python	C++	C#
long	int/long	uint64	ulong
sint32

Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s.

Java	Python	C++	C#
int	int	int32	int
sint64

Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s.

Java	Python	C++	C#
long	int/long	int64	long
fixed32

Always four bytes. More efficient than uint32 if values are often greater than 2^28.

Java	Python	C++	C#
int	int	uint32	uint
fixed64

Always eight bytes. More efficient than uint64 if values are often greater than 2^56.

Java	Python	C++	C#
long	int/long	uint64	ulong
sfixed32

Always four bytes.

Java	Python	C++	C#
int	int	int32	int
sfixed64

Always eight bytes.

Java	Python	C++	C#
long	int/long	int64	long
bool

Java	Python	C++	C#
boolean	boolean	bool	bool
string

A string must always contain UTF-8 encoded or 7-bit ASCII text.

Java	Python	C++	C#
String	str/unicode	string	string
bytes

May contain any arbitrary sequence of bytes.

Java	Python	C++	C#
ByteString	str	string	ByteString
Previous Next
Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved. Any unauthorized use, duplication or distribution is strictly prohibited. "Digital Asset" and "Daml" are Registered in the U.S. Patent and Trademark Office.

Daml Documentation
Home

Set Up Your Developer Environment

Tutorial: Write Your First Daml App

Create Daml Apps

Important Considerations When Building Applications With Daml
Write Smart Contracts with Daml
Integrate Daml with Off-Ledger Services
Build Applications
Daml Application Architecture
Parties and Users On a Daml Ledger
Access Active Contracts with the HTTP JSON API Service
HTTP JSON API Service
Run the JSON API
HTTP Status Codes
Create a New Contract
Create a Contract with a Command ID
Exercise by Contract ID
Exercise by Contract Key
Create and Exercise in the Same Transaction
Fetch Contract by Contract ID
Fetch Contract by Key
Get All Active Contracts
Get All Active Contracts Matching a Given Query
Fetch Parties by Identifiers
Fetch All Known Parties
Allocate a New Party
Create a New User
Get Authenticated User Information
Get Specific User Information
Delete Specific User
List Users
Grant User Rights
Revoke User Rights
List Authenticated User Rights
List Specific User Rights
List All DALF Packages
Download a DALF Package
Upload a DAR File
Metering Report
Streaming API
Healthcheck Endpoints
Daml-LF JSON Encoding
Query Language
Use JavaScript Client Libraries with Daml
JSON API Production Setup
Build Integration with the Ledger API
Write Off-Ledger Automation Using Daml
Handle Errors
Authorization
Explicit Contract Disclosure
Resource Management in Daml Application Design
Upgrading and Extending Daml Applications
Developer Tools
Daml Finance

Deploy Daml

Operate a Daml Ledger

Help

Reference

Early Access

Download as PDF

Developers
Products
Company
Version 
Search

In This Section
HTTP JSON API Service
Run the JSON API
Start a Daml Ledger
Start the HTTP JSON API Service
Basic
Standalone JAR
With Query Store
Access Tokens
Party-specific Requests
Using User Tokens
Using Claim Tokens
Auth via HTTP
Auth via WebSockets
HTTP Status Codes
Successful Response, HTTP Status: 200 OK
Successful Response with a Warning, HTTP Status: 200 OK
Failure, HTTP Status: 400 | 401 | 404 | 500
Examples
Create a New Contract
HTTP Request
HTTP Response
Create a Contract with a Command ID
Exercise by Contract ID
HTTP Request
HTTP Response
Exercise by Contract Key
HTTP Request
HTTP Response
Create and Exercise in the Same Transaction
HTTP Request
HTTP Response
Fetch Contract by Contract ID
HTTP Request
Contract Not Found HTTP Response
Contract Found HTTP Response
Fetch Contract by Key
HTTP Request
Contract Not Found HTTP Response
Contract Found HTTP Response
Get All Active Contracts
HTTP Request
HTTP Response
Get All Active Contracts Matching a Given Query
HTTP Request
Empty HTTP Response
Nonempty HTTP Response
Nonempty HTTP Response With Unknown Template IDs Warning
Fetch Parties by Identifiers
HTTP Response
Response With Unknown Parties Warning
Fetch All Known Parties
HTTP Response
Allocate a New Party
HTTP Request
HTTP Response
Create a New User
HTTP Request
HTTP Response
Get Authenticated User Information
HTTP Request
HTTP Response
Get Specific User Information
HTTP Request
HTTP Response
Delete Specific User
HTTP Request
HTTP Response
List Users
HTTP Request
HTTP Response
Grant User Rights
HTTP Request
HTTP Response
Revoke User Rights
HTTP Request
HTTP Response
List Authenticated User Rights
HTTP Request
HTTP Response
List Specific User Rights
HTTP Request
HTTP Response
List All DALF Packages
HTTP Request
HTTP Response
Download a DALF Package
HTTP Request
HTTP Response, status: 200 OK
HTTP Response With Error, Any Status Different from 200 OK
Upload a DAR File
HTTP Request
HTTP Response, Status: 200 OK
HTTP Response With Error
Metering Report
HTTP Response
Streaming API
Error and Warning Reporting
Error and Warning Examples
Contracts Query Stream
Fetch by Key Contracts Stream
Healthcheck Endpoints
Liveness Check
Readiness Check
HTTP JSON API Service
The JSON API provides a significantly simpler way to interact with a ledger than the Ledger API by providing basic active contract set functionality:

creating contracts,
exercising choices on contracts,
querying the current active contract set, and
retrieving all known parties.
The goal of this API is to get your distributed ledger application up and running quickly, so we have deliberately excluded complicating concerns including, but not limited to:

inspecting transactions,
asynchronous submit/completion workflows,
temporal queries (e.g. active contracts as of a certain time), and
For these and other features, use the Ledger API instead. The HTTP JSON API service is a ‚Äúproxy‚Äù, after a fashion, for that API; there is literally nothing that HTTP JSON API service can do that your own application cannot do via gRPC.

If you are using this API from JavaScript or TypeScript, we strongly recommend using the JavaScript bindings and code generator rather than invoking these endpoints directly. This will both simplify access to the endpoints described here and (with TypeScript) help to provide the correct JavaScript value format for each of your contracts, choice arguments, and choice results.

As suggested by those bindings, the primary target application for the HTTP JSON API service is a web application, where user actions translate to one or a few ledger operations. It is not intended for high-throughput, high-performance ledger automation; the Ledger API is better suited to such use cases.

We welcome feedback about the JSON API on our issue tracker, or on our forum.

Run the JSON API
Start a Daml Ledger
You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don‚Äôt have an existing ledger, you can start an in-memory sandbox:

daml new my-project --template quickstart-java
cd my-project
daml build
daml sandbox --wall-clock-time --dar ./.daml/dist/quickstart-0.0.1.dar
Start the HTTP JSON API Service
Basic
The most basic way to start the JSON API is with the command:

daml json-api --config json-api-app.conf
where a corresponding minimal config file is

{
  server {
    address = "localhost"
    port = 7575
  }
  ledger-api {
    address = "localhost"
    port = 6865
  }
}
This will start the JSON API on port 7575 and connect it to a ledger running on localhost:6865.

Note

Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a reverse proxy, such as via NGINX.

The full set of configurable options that can be specified via config file is listed below

{
  server {
    //IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.
    address = "127.0.0.1"
    //HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port.
    port = 7575
  }
  ledger-api {
    address = "127.0.0.1"
    port = 6865
    tls {
        enabled = "true"
        // the certificate to be used by the server
        cert-chain-file = "cert-chain.crt"
        // private key of the server
        private-key-file = "pvt-key.pem"
        // trust collection, which means that all client certificates will be verified using the trusted
        // certificates in this store. if omitted, the JVM default trust store is used.
        trust-collection-file = "root-ca.crt"
    }
  }

  query-store {
    base-config {
      user = "postgres"
      password = "password"
      driver = "org.postgresql.Driver"
      url = "jdbc:postgresql://localhost:5432/test?&ssl=true"

      // prefix for table names to avoid collisions, empty by default
      table-prefix = "foo"

      // max pool size for the database connection pool
      pool-size = 12
      //specifies the min idle connections for database connection pool.
      min-idle = 4
      //specifies the idle timeout for the database connection pool.
      idle-timeout = 12s
      //specifies the connection timeout for database connection pool.
      connection-timeout = 90s
    }
    // option setting how the schema should be handled.
    // Valid options are start-only, create-only, create-if-needed-and-start and create-and-start
    start-mode = "start-only"
  }



  // Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds
  package-reload-interval = 5s
  //Optional max inbound message size in bytes. Defaults to 4194304.
  max-inbound-message-size = 4194304
  //Optional max inbound message size in bytes used for uploading and downloading package updates. Defaults to the `max-inbound-message-size` setting.
  package-max-inbound-message-size = 4194304
  //Optional max cache size in entries for storing surrogate template id mappings. Defaults to None
  max-template-id-cache-entries = 1000
  //health check timeout in seconds
  health-timeout-seconds = 5

  //Optional websocket configuration parameters
  websocket-config {
    //Maximum websocket session duration
    max-duration = 120m
    //Server-side heartbeat interval duration
    heartbeat-period = 5s
    //akka stream throttle-mode one of either `shaping` or `enforcing`
    mode = "shaping"
  }

  metrics {
    //Start a metrics reporter. Must be one of "console", "csv:///PATH", "graphite://HOST[:PORT][/METRIC_PREFIX]", or "prometheus://HOST[:PORT]".
    reporter = "console"
    //Set metric reporting interval , examples : 1s, 30s, 1m, 1h
    reporting-interval = 30s
  }

  // DEV MODE ONLY (not recommended for production)
  // Allow connections without a reverse proxy providing HTTPS.
  allow-insecure-tokens = false
  // Optional static content configuration string. Contains comma-separated key-value pairs, where:
  // prefix -- URL prefix,
  // directory -- local directory that will be mapped to the URL prefix.
  // Example: "prefix=static,directory=./static-content"
  static-content {
    prefix = "static"
    directory = "static-content-dir"
  }

  auth-config {
    target-scope = "scope-must-be-the-same-as-in-the-participant"
  }
}
Note

You can also start JSON API using CLI args (example below) however this is now deprecated

daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575
Standalone JAR
The daml json-api command is great during development since it is included with the SDK and integrates with daml start and other commands. Once you are ready to deploy your application, you can download the standalone JAR from Github releases. It is much smaller than the whole SDK and easier to deploy since it only requires a JVM but no other dependencies and no installation process. The JAR accepts exactly the same command line parameters as daml json-api, so to start the standalone JAR, you can use the following command:

java -jar http-json-2.0.0.jar --config json-api-app.conf
Replace the version number 2.0.0 by the version of the SDK you are using.

With Query Store
In production setups, you should configure the HTTP JSON API service to use a PostgreSQL backend as a Query Store. The in-memory backend will call the ledger to fetch the entire active contract set for the templates in your query every time so it is generally not recommended to rely on this in production. Note that the query store is a redundant copy of on-ledger data. It is safe to reinitialize the database at any time.

To enable the PostgreSQL backend you can add the query-store config block as described.

Access Tokens
Each request to the HTTP JSON API Service must come with an access token, regardless of whether the underlying ledger requires it or not. This also includes development setups using an unsecured sandbox. The HTTP JSON API Service does not hold on to the access token, which will be only used to fulfill the request it came along with. The same token will be used to issue the request to the Ledger API.

The HTTP JSON API Service does not validate the token but may need to decode it to extract information that can be used to fill in request fields for party-specific request. How this happens depends partially on the token format you are using.

To connect to a Canton participant that uses target-scopes, the JSON API must also include target-scopes in its configuration as follows:

auth-config {
    target-scope = "scope-must-be-the-same-as-in-the-participant"
}
Party-specific Requests
Party-specific requests, i.e., command submissions and queries, are subject to additional restrictions. For command submissions the token must provide a proof that the bearer can act on behalf of at least one party (and possibly read on behalf of any number of parties). For queries the token must provide a proof that the bearer can either act and/or read of at least one party. This happens regardless of the used access token format. The following paragraphs provide guidance as to how different token formats are used by the HTTP JSON API in this regard.

Using User Tokens
If the underlying ledger supports user management (this includes Canton and the sandbox), you are recommended to use user tokens. For command submissions, the user of the bearer should have actAs rights for at least one party and readAs rights for any number of parties. Queries require the bearer‚Äôs user to have at least one actAs or readAs user right. The application id of the Ledger API request will be the user id.

Using Claim Tokens
These tokens can be used if the underlying ledger does not support user management. For command submissions, actAs must contain at least one party and readAs can contain any number of parties. Queries require at least one party in either actAs or readAs. The application id is mandatory.

Note

While the JSON API receives the token it doesn‚Äôt validate it itself. Upon receiving a token it will pass it, and all data contained within the request, on to the Ledger API‚Äôs AuthService which will then determine if the token is valid and authorized. However, the JSON API does decode the token to extract the ledger id, application id and party so it requires that you use a valid Daml ledger access token format.

For a ledger without authorization, e.g., the default configuration of Daml Sandbox, you can use https://jwt.io (or the JWT library of your choice) to generate your token. You can use an arbitrary secret here. The default ‚Äúheader‚Äù is fine. Under ‚ÄúPayload‚Äù, fill in:

{
  "https://daml.com/ledger-api": {
    "ledgerId": "sandbox",
    "applicationId": "foobar",
    "actAs": ["Alice"]
  }
}
The value of the ledgerId field has to match the ledgerId of your underlying Daml Ledger. For the Sandbox this corresponds to the participant id which by default is just sandbox.

Note

The value of applicationId will be used for commands submitted using that token.

The value for actAs is specified as a list and you provide it with the party that you want to use, such as in the example above which uses Alice for a party. actAs may include more than just one party as the JSON API supports multi-party submissions.

The party should reference an already allocated party.

Note

As mentioned above the JSON API does not validate tokens so if your ledger runs without authorization you can use an arbitrary secret.

Then the ‚ÄúEncoded‚Äù box should have your token, ready for passing to the service as described in the following sections.

Alternatively, here are two tokens you can use for testing:

{"https://daml.com/ledger-api": {"ledgerId": "sandbox", "applicationId": "HTTP-JSON-API-Gateway", "actAs": ["Alice"]}}:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJzYW5kYm94IiwiYXBwbGljYXRpb25JZCI6IkhUVFAtSlNPTi1BUEktR2F0ZXdheSIsImFjdEFzIjpbIkFsaWNlIl19fQ.FIjS4ao9yu1XYnv1ZL3t7ooPNIyQYAHY3pmzej4EMCM
{"https://daml.com/ledger-api": {"ledgerId": "sandbox", "applicationId": "HTTP-JSON-API-Gateway", "actAs": ["Bob"]}}:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJzYW5kYm94IiwiYXBwbGljYXRpb25JZCI6IkhUVFAtSlNPTi1BUEktR2F0ZXdheSIsImFjdEFzIjpbIkJvYiJdfX0.y6iwpnYt-ObtNo_FyLVxMtNTwpJF8uxzNfPELQUVKVg
Auth via HTTP
Set HTTP header Authorization: Bearer paste-jwt-here

Example:

Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk
Auth via WebSockets
WebSocket clients support a ‚Äúsubprotocols‚Äù argument (sometimes simply called ‚Äúprotocols‚Äù); this is usually in a list form but occasionally in comma-separated form. Check documentation for your WebSocket library of choice for details.

For HTTP JSON requests, you must pass two subprotocols:

daml.ws.auth
jwt.token.paste-jwt-here
Example:

jwt.token.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk
HTTP Status Codes
The JSON API reports errors using standard HTTP status codes. It divides HTTP status codes into 3 groups indicating:

success (200)
failure due to a client-side problem (400, 401, 403, 404, 409, 429)
failure due to a server-side problem (500, 503)
The JSON API can return one of the following HTTP status codes:

200 - OK
400 - Bad Request (Client Error)
401 - Unauthorized, authentication required
403 - Forbidden, insufficient permissions
404 - Not Found
409 - Conflict, contract ID or key missing or duplicated
500 - Internal Server Error
503 - Service Unavailable, ledger server is not running yet or has been shut down
504 - Gateway Timeout, transaction failed to receive its completion within the predefined timeout
When the Ledger API returns an error code, the JSON API maps it to one of the above codes according to the official gRPC to HTTP code mapping.

If a client‚Äôs HTTP GET or POST request reaches an API endpoint, the corresponding response will always contain a JSON object with a status field, and either an errors or result field. It may also contain an optional warnings and/or an optional ledgerApiError :

{
    "status": <400 | 401 | 403 | 404 | 409 | 500 | 503 | 504>,
    "errors": <JSON array of strings>, | "result": <JSON object or array>,
    ["warnings": <JSON object> ],
    ["ledgerApiError": <JSON object> ]
}
Where:

status ‚Äì a JSON number which matches the HTTP response status code returned in the HTTP header,
errors ‚Äì a JSON array of strings, each string represents one error,
result ‚Äì a JSON object or JSON array, representing one or many results,
warnings ‚Äì an optional field with a JSON object, representing one or many warnings.
ledgerApiError ‚Äì an optional field with a JSON object, representing detail of an error if it was originated from Ledger API.
See the following blog post for more details about error handling best practices: REST API Error Codes 101.

See The Ledger API error codes for more details about error codes from Ledger API.

Successful Response, HTTP Status: 200 OK
Content-Type: application/json
Content:
{
    "status": 200,
    "result": <JSON object>
}
Successful Response with a Warning, HTTP Status: 200 OK
Content-Type: application/json
Content:
{
    "status": 200,
    "result": <JSON object>,
    "warnings": <JSON object>
}
Failure, HTTP Status: 400 | 401 | 404 | 500
Content-Type: application/json
Content:
{
    "status": <400 | 401 | 404 | 500>,
    "errors": <JSON array of strings>,
    ["ledgerApiError": <JSON object> ]
}
Examples
Result with JSON Object without Warnings:

{"status": 200, "result": {...}}
Result with JSON Array and Warnings:

{"status": 200, "result": [...], "warnings": {"unknownTemplateIds": ["UnknownModule:UnknownEntity"]}}
Bad Request Error:

{"status": 400, "errors": ["JSON parser error: Unexpected character 'f' at input index 27 (line 1, position 28)"]}
Bad Request Error with Warnings:

{"status":400, "errors":["Cannot resolve any template ID from request"], "warnings":{"unknownTemplateIds":["XXX:YYY","AAA:BBB"]}}
Authentication Error:

{"status": 401, "errors": ["Authentication Required"]}
Not Found Error:

{"status": 404, "errors": ["HttpMethod(POST), uri: http://localhost:7575/v1/query1"]}
Internal Server Error:

{"status": 500, "errors": ["Cannot initialize Ledger API"]}
Create a New Contract
To create an Iou contract from the Quickstart guide:

template Iou
  with
    issuer : Party
    owner : Party
    currency : Text
    amount : Decimal
    observers : [Party]
HTTP Request
URL: /v1/create
Method: POST
Content-Type: application/json
Content:
{
  "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer",
  "payload": {
    "issuer": "Alice",
    "owner": "Alice",
    "currency": "USD",
    "amount": "999.99",
    "observers": []
  }
}
Where:

templateId is the contract template identifier, which has the following two formats: #<package name>:<module>:<entity> or <package ID>:<module>:<entity>.

The package name format supports the smart contract upgrading feature, allowing contracts with different package IDs but the same package name to be used uniformly.

Using the package ID format refers to a single package.

Previously JSON API had supported partially qualified template IDs, such as simply <module>:<entity>) as an interactive convenience which fails if there is more than one package with matching template names. Since this format was not supported for production use and will not work with smart contract upgrades, it is now unavailable.

payload field contains contract fields as defined in the Daml template and formatted according to Daml-LF JSON Encoding.

HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": {
        "observers": [],
        "agreementText": "",
        "payload": {
            "observers": [],
            "issuer": "Alice",
            "amount": "999.99",
            "currency": "USD",
            "owner": "Alice"
        },
        "signatories": [
            "Alice"
        ],
        "contractId": "#124:0",
        "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou",
        "completionOffset":"0000000000000084"
    }
}
Where:

status field matches the HTTP response status code returned in the HTTP header,
result field contains created contract details. Keep in mind that templateId in the JSON API response is always fully qualified (always contains package ID).
Create a Contract with a Command ID
When creating a new contract or exercising a choice you may specify an optional meta field. This allows you to control various extra settings used when submitting a command to the ledger. Each of these meta fields is optional.

Note

You cannot currently use commandIds anywhere else in the JSON API, but you can use it for observing the results of its commands outside the JSON API in logs or via the Ledger API‚Äôs Command Services

{
  "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer",
  "payload": {
    "observers": [],
    "issuer": "Alice",
    "amount": "999.99",
    "currency": "USD",
    "owner": "Alice"
  },
  "meta": {
    "commandId": "a unique ID",
    "actAs": ["Alice"],
    "readAs": ["PublicParty"],
    "deduplicationPeriod": {
      "durationInMillis": 10000,
      "type": "Duration"
    },
    "submissionId": "d2f941b1-ee5c-4634-9a51-1335ce6902fa"
  }
}
Where:

commandId ‚Äì optional field, a unique string identifying the command.
actAs ‚Äì a non-empty list of parties, overriding the set from the JWT user; must be a subset of the JWT user‚Äôs set.
readAs ‚Äì a list of parties, overriding the set from the JWT user; must be a subset of the JWT user‚Äôs set.
submissionId ‚Äì a string, used for deduplicating retried requests. If you do not set it, a random one will be chosen, effectively treating the request as unique and disabling deduplication.
deduplicationPeriod ‚Äì either a Duration as above, which is how far back in time prior commands will be searched for this submission, or an Offset as follows, which is the earliest ledger offset after which to search for the submission.
"deduplicationPeriod": {
  "offset": "0000000000000083",
  "type": "Offset"
}
Exercise by Contract ID
The JSON command below, demonstrates how to exercise an Iou_Transfer choice on an Iou contract:

    choice Iou_Transfer : ContractId IouTransfer
      with
        newOwner : Party
      controller owner
      do create IouTransfer with iou = this; newOwner
HTTP Request
URL: /v1/exercise
Method: POST
Content-Type: application/json
Content:
{
    "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer",
    "choiceInterfaceId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransferInterface",
    "contractId": "#124:0",
    "choice": "Iou_Transfer",
    "argument": {
        "newOwner": "Alice"
    }
}
Where:

templateId ‚Äì contract template or interface identifier, same as in create request,
choiceInterfaceId ‚Äì optional template or interface that defines the choice, same format as templateId,
contractId ‚Äì contract identifier, the value from the create response,
choice ‚Äì Daml contract choice, that is being exercised,
argument ‚Äì contract choice argument(s).
templateId and choiceInterfaceId are treated as with exercise by key. However, because contractId is always unambiguous, you may alternatively simply specify the interface ID as the templateId argument, and ignore choiceInterfaceId entirely. This isn‚Äôt true of exercise-by-key or create-and-exercise, so we suggest treating this request as if this alternative isn‚Äôt available.

HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": {
        "exerciseResult": "#201:1",
        "events": [
            {
                "archived": {
                    "contractId": "#124:0",
                    "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"
                }
            },
            {
                "created": {
                    "observers": [],
                    "agreementText": "",
                    "payload": {
                        "iou": {
                            "observers": [],
                            "issuer": "Alice",
                            "amount": "999.99",
                            "currency": "USD",
                            "owner": "Alice"
                        },
                        "newOwner": "Alice"
                    },
                    "signatories": [
                        "Alice"
                    ],
                    "contractId": "#201:1",
                    "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:IouTransfer"
                }
            }
        ],
        "completionOffset":"0000000000000083"
    }
}
Where:

status field matches the HTTP response status code returned in the HTTP header,

result field contains contract choice execution details:

exerciseResult field contains the return value of the exercised contract choice.
events contains an array of contracts that were archived and created as part of the choice execution. The array may contain: zero or many {"archived": {...}} and zero or many {"created": {...}} elements. The order of the contracts is the same as on the ledger.
completionOffset is the ledger offset of the transaction containing the exercise‚Äôs ledger changes.
Exercise by Contract Key
The JSON command below, demonstrates how to exercise the Archive choice on the Account contract with a (Party, Text) contract key defined like this:

template Account with
    owner : Party
    number : Text
    status : AccountStatus
  where
    signatory owner
    key (owner, number) : (Party, Text)
    maintainer key._1
HTTP Request
URL: /v1/exercise
Method: POST
Content-Type: application/json
Content:
{
    "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account",
    "key": {
        "_1": "Alice",
        "_2": "abc123"
    },
    "choiceInterfaceId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:AccountInterface",
    "choice": "Archive",
    "argument": {}
}
Where:

templateId ‚Äì contract template identifier, same as in create request,
key ‚Äì contract key, formatted according to the Daml-LF JSON Encoding,
choiceInterfaceId ‚Äì optional template or interface that defines the choice, same format as templateId,
choice ‚Äì Daml contract choice, that is being exercised,
argument ‚Äì contract choice argument(s), empty, because Archive does not take any.
key is always searched in relation to the templateId. The choice, on the other hand, is searched according to choiceInterfaceId; if choiceInterfaceId is not specified, templateId is its default. We recommend always specifying choiceInterfaceId when invoking an interface choice; however, if the set of Daml-LF packages on the participant only contains one choice with a given name associated with templateId, that choice will be exercised, regardless of where it is defined. If a template and one or more of the interfaces it implements declares a choice, and choiceInterfaceId is not used, the one directly defined on the choice will be exercised. If choice selection is still ambiguous given these rules, the endpoint will fail as if the choice isn‚Äôt defined.

HTTP Response
Formatted similar to Exercise by Contract ID response.

Create and Exercise in the Same Transaction
This command allows creating a contract and exercising a choice on the newly created contract in the same transaction.

HTTP Request
URL: /v1/create-and-exercise
Method: POST
Content-Type: application/json
Content:
{
  "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou",
  "payload": {
    "observers": [],
    "issuer": "Alice",
    "amount": "999.99",
    "currency": "USD",
    "owner": "Alice"
  },
  "choiceInterfaceId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:IouInterface",
  "choice": "Iou_Transfer",
  "argument": {
    "newOwner": "Bob"
  }
}
Where:

templateId ‚Äì the initial contract template identifier, in the same format as in the create request,
payload ‚Äì the initial contract fields as defined in the Daml template and formatted according to Daml-LF JSON Encoding,
choiceInterfaceId ‚Äì optional template or interface that defines the choice, same format as templateId,
choice ‚Äì Daml contract choice, that is being exercised,
argument ‚Äì contract choice argument(s).
templateId and choiceInterfaceId are treated as with exercise by key, with the exception that it is payload, not key, strictly interpreted according to templateId.

HTTP Response
Please note that the response below is for a consuming choice, so it contains:

created and archived events for the initial contract ("contractId": "#1:0"), which was created and archived right away when a consuming choice was exercised on it,
a created event for the contract that is the result of exercising the choice ("contractId": "#1:2").
Content-Type: application/json
Content:
{
  "result": {
    "exerciseResult": "#1:2",
    "events": [
      {
        "created": {
          "observers": [],
          "agreementText": "",
          "payload": {
            "observers": [],
            "issuer": "Alice",
            "amount": "999.99",
            "currency": "USD",
            "owner": "Alice"
          },
          "signatories": [
            "Alice"
          ],
          "contractId": "#1:0",
          "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:Iou"
        }
      },
      {
        "archived": {
          "contractId": "#1:0",
          "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:Iou"
        }
      },
      {
        "created": {
          "observers": [
            "Bob"
          ],
          "agreementText": "",
          "payload": {
            "iou": {
              "observers": [],
              "issuer": "Alice",
              "amount": "999.99",
              "currency": "USD",
              "owner": "Alice"
            },
            "newOwner": "Bob"
          },
          "signatories": [
            "Alice"
          ],
          "contractId": "#1:2",
          "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer"
        }
      }
    ]
  },
  "status": 200
}
Fetch Contract by Contract ID
HTTP Request
URL: /v1/fetch
Method: POST
Content-Type: application/json
Content:
application/json body:

{
  "contractId": "#201:1",
  "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer"
}
readers may be passed as with Query. templateId is optional, but you are strongly advised to always pass it explicitly to minimize the data read from the Ledger API to answer the query. It can be either a template ID or an interface ID.

Contract Not Found HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": null
}
Contract Found HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": {
        "observers": [],
        "agreementText": "",
        "payload": {
            "iou": {
                "observers": [],
                "issuer": "Alice",
                "amount": "999.99",
                "currency": "USD",
                "owner": "Alice"
            },
            "newOwner": "Alice"
        },
        "signatories": [
            "Alice"
        ],
        "contractId": "#201:1",
        "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:IouTransfer"
    }
}
Fetch Contract by Key
Show the currently active contract that matches a given key.

The websocket endpoint /v1/stream/fetch can be used to search multiple keys in the same request, or in place of iteratively invoking this endpoint to respond to changes on the ledger.

HTTP Request
URL: /v1/fetch
Method: POST
Content-Type: application/json
Content:
{
    "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account",
    "key": {
        "_1": "Alice",
        "_2": "abc123"
    }
}
readers may be passed as with Query.

Contract Not Found HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": null
}
Contract Found HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": {
        "observers": [],
        "agreementText": "",
        "payload": {
            "owner": "Alice",
            "number": "abc123",
            "status": {
                "tag": "Enabled",
                "value": "2020-01-01T00:00:01Z"
            }
        },
        "signatories": [
            "Alice"
        ],
        "key": {
            "_1": "Alice",
            "_2": "abc123"
        },
        "contractId": "#697:0",
        "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account"
    }
}
Get All Active Contracts
List all currently active contracts for all known templates.

Note

Retrieved contracts do not get persisted into a query store database. Query store is a search index and can be used to optimize search latency. See Start HTTP service for information on how to start JSON API service with a query store enabled.

Note

You can only query active contracts with the /v1/query endpoint. Archived contracts (those that were archived or consumed during an exercise operation) will not be shown in the results.

HTTP Request
URL: /v1/query
Method: GET
Content: <EMPTY>
HTTP Response
The response is the same as for the POST method below.

Get All Active Contracts Matching a Given Query
List currently active contracts that match a given query.

The websocket endpoint /v1/stream/query can be used in place of iteratively invoking this endpoint to respond to changes on the ledger.

HTTP Request
URL: /v1/query
Method: POST
Content-Type: application/json
Content:
{
    "templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"],
    "query": {"amount": 999.99},
    "readers": ["Alice"]
}
Where:

templateIds ‚Äì either an array of contract template identifiers in the same format as in the create request. It can also be an array containing a single interface identifier to search through. Mixing of template ID‚Äôs and interface ID‚Äôs, or specifying more than one interface ID is not allowed. - query ‚Äì search criteria to apply to the specified templateIds, formatted according to the Query Language.
readers ‚Äì optional non-empty list of parties to query as; must be a subset of the actAs/readAs parties in the JWT
Empty HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": []
}
Nonempty HTTP Response
Content-Type: application/json
Content:
{
    "result": [
        {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "999.99",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": [
                "Alice"
            ],
            "contractId": "#52:0",
            "templateId": "b10d22d6c2f2fae41b353315cf893ed66996ecb0abe4424ea6a81576918f658a:Iou:Iou"
        }
    ],
    "status": 200
}
Where

result contains an array of contracts, each contract formatted according to Daml-LF JSON Encoding,
status matches the HTTP status code returned in the HTTP header.
Nonempty HTTP Response With Unknown Template IDs Warning
Content-Type: application/json
Content:
{
    "warnings": {
        "unknownTemplateIds": ["UnknownModule:UnknownEntity"]
    },
    "result": [
        {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "999.99",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": [
                "Alice"
            ],
            "contractId": "#52:0",
            "templateId": "b10d22d6c2f2fae41b353315cf893ed66996ecb0abe4424ea6a81576918f658a:Iou:Iou"
        }
    ],
    "status": 200
}
Fetch Parties by Identifiers
URL: /v1/parties
Method: POST
Content-Type: application/json
Content:
["Alice", "Bob", "Dave"]
If an empty JSON array is passed: [], this endpoint returns BadRequest(400) error:

{
  "status": 400,
  "errors": [
    "JsonReaderError. Cannot read JSON: <[]>. Cause: spray.json.DeserializationException: must be a list with at least 1 element"
  ]
}
HTTP Response
Content-Type: application/json
Content:
{
  "status": 200,
  "result": [
    {
      "identifier": "Alice",
      "displayName": "Alice & Co. LLC",
      "isLocal": true
    },
    {
      "identifier": "Bob",
      "displayName": "Bob & Co. LLC",
      "isLocal": true
    },
    {
      "identifier": "Dave",
      "isLocal": true
    }
  ]
}
Please note that the order of the party objects in the response is not guaranteed to match the order of the passed party identifiers.

Where

identifier ‚Äì a stable unique identifier of a Daml party,
displayName ‚Äì optional human readable name associated with the party. Might not be unique,
isLocal ‚Äì true if party is hosted by the backing participant.
Response With Unknown Parties Warning
Content-Type: application/json
Content:
{
  "result": [
    {
      "identifier": "Alice",
      "displayName": "Alice & Co. LLC",
      "isLocal": true
    }
  ],
  "warnings": {
    "unknownParties": ["Erin"]
  },
  "status": 200
}
The result might be an empty JSON array if none of the requested parties is known.

Fetch All Known Parties
URL: /v1/parties
Method: GET
Content: <EMPTY>
HTTP Response
The response is the same as for the POST method above.

Allocate a New Party
This endpoint is a JSON API proxy for the Ledger API‚Äôs AllocatePartyRequest. For more information about party management, please refer to Provisioning Identifiers part of the Ledger API documentation.

HTTP Request
URL: /v1/parties/allocate
Method: POST
Content-Type: application/json
Content:
{
  "identifierHint": "Carol",
  "displayName": "Carol & Co. LLC"
}
Please refer to AllocateParty documentation for information about the meaning of the fields.

All fields in the request are optional, this means that an empty JSON object is a valid request to allocate a new party:

{}
HTTP Response
{
  "result": {
    "identifier": "Carol",
    "displayName": "Carol & Co. LLC",
    "isLocal": true
  },
  "status": 200
}
Create a New User
This endpoint exposes the Ledger API‚Äôs CreateUser RPC.

HTTP Request
URL: /v1/user/create
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol",
  "primaryParty": "Carol",
  "rights": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ]
}
Please refer to CreateUser RPC documentation for information about the meaning of the fields.

Only the userId fields in the request is required, this means that an JSON object containing only it is a valid request to create a new user.

HTTP Response
{
  "result": {},
  "status": 200
}
Get Authenticated User Information
This endpoint exposes the Ledger API‚Äôs GetUser RPC.

The user ID will always be filled out with the user specified via the currently used user token.

HTTP Request
URL: /v1/user
Method: GET
HTTP Response
{
  "result": {
    "userId": "carol",
    "primaryParty": "Carol"
  },
  "status": 200
}
Get Specific User Information
This endpoint exposes the Ledger API‚Äôs GetUser RPC.

HTTP Request
URL: /v1/user
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol"
}
Please refer to GetUser RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": {
    "userId": "carol",
    "primaryParty": "Carol"
  },
  "status": 200
}
Delete Specific User
This endpoint exposes the Ledger API‚Äôs DeleteUser RPC.

HTTP Request
URL: /v1/user/delete
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol"
}
Please refer to DeleteUser RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": {},
  "status": 200
}
List Users
This endpoint exposes the Ledger API‚Äôs ListUsers RPC.

HTTP Request
URL: /v1/users
Method: GET
HTTP Response
{
  "result": [
    {
        "userId": "carol",
        "primaryParty": "Carol"
    },
    {
        "userId": "bob",
        "primaryParty": "Bob"
    }
  ],
  "status": 200
}
Grant User Rights
This endpoint exposes the Ledger API‚Äôs GrantUserRights RPC.

HTTP Request
URL: /v1/user/rights/grant
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol",
  "rights": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ]
}
Please refer to GrantUserRights RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ],
  "status": 200
}
Returns the rights that were newly granted.

Revoke User Rights
This endpoint exposes the Ledger API‚Äôs RevokeUserRights RPC.

HTTP Request
URL: /v1/user/rights/revoke
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol",
  "rights": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ]
}
Please refer to RevokeUserRights RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ],
  "status": 200
}
Returns the rights that were actually granted.

List Authenticated User Rights
This endpoint exposes the Ledger API‚Äôs ListUserRights RPC.

The user ID will always be filled out with the user specified via the currently used user token.

HTTP Request
URL: /v1/user/rights
Method: GET
HTTP Response
{
  "result": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ],
  "status": 200
}
List Specific User Rights
This endpoint exposes the Ledger API‚Äôs ListUserRights RPC.

HTTP Request
URL: /v1/user/rights
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol"
}
Please refer to ListUserRights RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ],
  "status": 200
}
List All DALF Packages
HTTP Request
URL: /v1/packages
Method: GET
Content: <EMPTY>
HTTP Response
{
  "result": [
    "c1f1f00558799eec139fb4f4c76f95fb52fa1837a5dd29600baa1c8ed1bdccfd",
    "733e38d36a2759688a4b2c4cec69d48e7b55ecc8dedc8067b815926c917a182a",
    "bfcd37bd6b84768e86e432f5f6c33e25d9e7724a9d42e33875ff74f6348e733f",
    "40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7",
    "8a7806365bbd98d88b4c13832ebfa305f6abaeaf32cfa2b7dd25c4fa489b79fb"
  ],
  "status": 200
}
Where result is the JSON array containing the package IDs of all loaded DALFs.

Download a DALF Package
HTTP Request
URL: /v1/packages/<package ID>
Method: GET
Content: <EMPTY>
Note that the desired package ID is specified in the URL.

HTTP Response, status: 200 OK
Transfer-Encoding: chunked
Content-Type: application/octet-stream
Content: <DALF bytes>
The content (body) of the HTTP response contains raw DALF package bytes, without any encoding. Note that the package ID specified in the URL is actually the SHA-256 hash of the downloaded DALF package and can be used to validate the integrity of the downloaded content.

HTTP Response With Error, Any Status Different from 200 OK
Any status different from 200 OK will be in the format specified below.

Content-Type: application/json
Content:
{
    "errors": [
        "io.grpc.StatusRuntimeException: NOT_FOUND"
    ],
    "status": 500
}
Upload a DAR File
HTTP Request
URL: /v1/packages
Method: POST
Content-Type: application/octet-stream
Content: <DAR bytes>
The content (body) of the HTTP request contains raw DAR file bytes, without any encoding.

HTTP Response, Status: 200 OK
Content-Type: application/json
Content:
{
    "result": 1,
    "status": 200
}
HTTP Response With Error
Content-Type: application/json
Content:
{
    "errors": [
        "io.grpc.StatusRuntimeException: INVALID_ARGUMENT: Invalid argument: Invalid DAR: package-upload, content: [}]"
    ],
    "status": 500
}
Metering Report
For a description of participant metering, the parameters, and the report format see the Participant Metering.

URL: /v1/metering-report
Method: POST
Content-Type: application/json
Content:
{
  "from": "2022-01-01",
  "to": "2022-02-01",
  "application": "some-application"
}
HTTP Response
Content-Type: application/json
Content:
{
  "status": 200,
  "result": {
    "participant": "some-participant",
    "request": {
      "from": "2022-01-01T00:00:00Z",
      "to": "2022-02-01T00:00:00Z"
    },
    "final": true,
    "applications": [
      {
        "application": "some-application",
        "events": 42
      }
    ]
  }
}
Streaming API
Two subprotocols must be passed with every request, as described in Auth via WebSockets.

JavaScript/Node.js example demonstrating how to establish Streaming API connection:

const wsProtocol = "daml.ws.auth";
const tokenPrefix = "jwt.token.";
const jwt =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdp";
const subprotocols = [`${tokenPrefix}${jwt}`, wsProtocol];

const ws = new WebSocket("ws://localhost:7575/v1/stream/query", subprotocols);

ws.addEventListener("open", function open() {
  ws.send(JSON.stringify({templateIds: ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"]}));
});

ws.addEventListener("message", function incoming(data) {
  console.log(data);
});
Please note that Streaming API does not allow multiple requests over the same WebSocket connection. The server returns an error and disconnects if second request received over the same WebSocket connection.

Error and Warning Reporting
Errors and warnings reported as part of the regular on-message flow: ws.addEventListener("message", ...).

Streaming API error messages formatted the same way as synchronous API errors.

Streaming API reports only one type of warnings ‚Äì unknown template IDs, which is formatted as:

{"warnings":{"unknownTemplateIds":<JSON Array of template ID strings>>}}
Error and Warning Examples
{"warnings": {"unknownTemplateIds": ["UnknownModule:UnknownEntity"]}}

{
  "errors":["JsonReaderError. Cannot read JSON: <{\"templateIds\":[]}>. Cause: spray.json.DeserializationException: search requires at least one item in 'templateIds'"],
  "status":400
}

{
  "errors":["Multiple requests over the same WebSocket connection are not allowed."],
  "status":400
}

{
  "errors":["Could not resolve any template ID from request."],
  "status":400
}
Contracts Query Stream
URL: /v1/stream/query
Scheme: ws
Protocol: WebSocket
List currently active contracts that match a given query, with continuous updates.

Simpler use-cases that do not require continuous updates should use the simpler /v1/query endpoint instead.

application/json body must be sent first, formatted according to the Query Language:

{"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"]}
Multiple queries may be specified in an array, for overlapping or different sets of template IDs.:

[
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "query": {"amount": {"%lte": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:OtherIou:OtherIou"], "query": {"amount": {"%gt": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"]}
]
Only one interface ID can be provided in templateIds. An interface ID can be used in all queries:

[
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"], "query": {"amount": {"%lte": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"], "query": {"amount": {"%gt": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"]}
]
Mixing of template ID‚Äôs and interface ID‚Äôs or specifying more than one interface ID across queries is not allowed. BadRequest(400) error will be returned.:

[
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "query": {"amount": {"%lte": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"], "query": {"amount": {"%gt": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"]}
]
Queries have two ways to specify an offset.

An offset, a string supplied by an earlier query output message, may optionally be specified alongside each query itself:

[
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "query": {"amount": {"%lte": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "query": {"amount": {"%gt": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "offset": "5609"}
]
If specified, the stream will include only contract creations and archivals after the response body that included that offset. Queries with no offset will begin with all active contracts for that query, as usual.

If an offset is specified before the queries, as a separate body, it will be used as a default offset for all queries that do not include an offset themselves:

{"offset": "4307"}
For example, if this message preceded the above 3-query example, it would be as if "4307" had been specified for the first two queries, while "5609" would be used for the third query.

If any offset has been pruned, the websocket will immediately fail with code 1011 and message internal error.

The output is a series of JSON documents, each payload formatted according to Daml-LF JSON Encoding:

{
    "events": [{
        "created": {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "999.99",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": ["Alice"],
            "contractId": "#1:0",
            "templateId": "eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou"
        },
        "matchedQueries": [1, 2]
    }]
}
where matchedQueries indicates the 0-based indices into the request list of queries that matched this contract.

Every events block following the end of contracts that existed when the request started includes an offset. The stream is guaranteed to send an offset immediately at the beginning of this ‚Äúlive‚Äù data, which may or may not contain any events; if it does not contain events and no events were emitted before, it may be null if there was no transaction on the ledger or a string representing the current ledger end; otherwise, it will be a string. For example, you might use it to turn off an initial ‚Äúloading‚Äù indicator:

{
    "events": [],
    "offset": "2"
}
Note

Events in the following ‚Äúlive‚Äù data may include events that precede this offset if an earlier per-query offset was specified.

This has been done with the intent of allowing to use per-query offset s to efficiently use a single connection to multiplex various requests. To give an example of how this would work, let‚Äôs say that there are two contract templates, A and B . Your application first queries for A s without specifying an offset. Then some client-side interaction requires the application to do the same for B s. The application can save the latest observed offset for the previous query, which let‚Äôs say is 42, and issue a new request that queries for all B s without specifying an offset and all A s from 42. While this happens on the client, a few more A s and B s are created and the new request is issued once the latest offset is 47. The response to this will contain a message with all active B s, followed by the message reporting the offset 47, followed by a stream of live updates that contains new A s starting from 42 and new B s starting from 47 .

To keep the stream alive, you‚Äôll occasionally see messages like this, which can be safely ignored if you do not need to capture the last seen ledger offset:

{"events":[],"offset":"5609"}
where offset is the last seen ledger offset.

After submitting an Iou_Split exercise, which creates two contracts and archives the one above, the same stream will eventually produce:

{
    "events": [{
        "archived": {
            "contractId": "#1:0",
            "templateId": "eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou"
        }
    }, {
        "created": {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "42.42",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": ["Alice"],
            "contractId": "#2:1",
            "templateId": "eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou"
        },
        "matchedQueries": [0, 2]
    }, {
        "created": {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "957.57",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": ["Alice"],
            "contractId": "#2:2",
            "templateId": "eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou"
        },
        "matchedQueries": [1, 2]
    }],
    "offset": "3"
}
If any template IDs are found not to resolve, the first element of the stream will report them:

{"warnings": {"unknownTemplateIds": ["UnknownModule:UnknownEntity"]}}
and the stream will continue, provided that at least one template ID resolved properly.

Aside from "created" and "archived" elements, "error" elements may appear, which contain a string describing the error. The stream will continue in these cases, rather than terminating.

Some notes on behavior:

Each result array means ‚Äúthis is what would have changed if you just polled /v1/query iteratively.‚Äù In particular, just as polling search can ‚Äúmiss‚Äù contracts (as a create and archive can be paired between polls), such contracts may or may not appear in any result object.
No archived ever contains a contract ID occurring within a created in the same array. So, for example, supposing you are keeping an internal map of active contracts keyed by contract ID, you can apply the created first or the archived first, forwards, backwards, or in random order, and be guaranteed to get the same results.
Within a given array, if an archived and created refer to contracts with the same template ID and contract key, the archived is guaranteed to occur before the created.
Except in cases of #3, within a single response array, the order of created and archived is undefined and does not imply that any element occurred ‚Äúbefore‚Äù or ‚Äúafter‚Äù any other one.
You will almost certainly receive contract IDs in archived that you never received a created for. These are contracts that query filtered out, but for which the server no longer is aware of that. You can safely ignore these. However, such ‚Äúphantom archives‚Äù are guaranteed to represent an actual archival on the ledger, so if you are keeping a more global dataset outside the context of this specific search, you can use that archival information as you wish.
Fetch by Key Contracts Stream
URL: /v1/stream/fetch
Scheme: ws
Protocol: WebSocket
List currently active contracts that match one of the given {templateId, key} pairs, with continuous updates.

Simpler use-cases that search for only a single key and do not require continuous updates should use the simpler /v1/fetch endpoint instead.

application/json body must be sent first, formatted according to the following rule:

[
    {"templateId": "<template ID 1>", "key": <key 1>},
    {"templateId": "<template ID 2>", "key": <key 2>},
    ...
    {"templateId": "<template ID N>", "key": <key N>}
]
Where:

templateId ‚Äì contract template identifier, same as in create request,
key ‚Äì contract key, formatted according to the Daml-LF JSON Encoding,
Example:

[
    {"templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account", "key": {"_1": "Alice", "_2": "abc123"}},
    {"templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account", "key": {"_1": "Alice", "_2": "def345"}}
]
The output stream has the same format as the output from the Contracts Query Stream. We further guarantee that for every archived event appearing on the stream there has been a matching created event earlier in the stream, except in the case of missing contractIdAtOffset fields in the case described below.

You may supply optional offset s for the stream, exactly as with query streams. However, you should supply with each {templateId, key} pair a contractIdAtOffset, which is the contract ID currently associated with that pair at the point of the given offset, or null if no contract ID was associated with the pair at that offset. For example, with the above keys, if you had one "abc123" contract but no "def345" contract, you might specify:

[
    {"templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account", "key": {"_1": "Alice", "_2": "abc123"},
     "contractIdAtOffset": "#1:0"},
    {"templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account", "key": {"_1": "Alice", "_2": "def345"},
     "contractIdAtOffset": null}
]
If every contractIdAtOffset is specified, as is so in the example above, you will not receive any archived events for contracts created before the offset unless those contracts are identified in a contractIdAtOffset. By contrast, if any contractIdAtOffset is missing, archived event filtering will be disabled, and you will receive ‚Äúphantom archives‚Äù as with query streams.

Healthcheck Endpoints
The HTTP JSON API provides two healthcheck endpoints for integration with schedulers like Kubernetes.

Liveness Check
URL: /livez
Method: GET
A status code of 200 indicates a successful liveness check.

This is an unauthenticated endpoint intended to be used as a liveness probe.

Readiness Check
URL: /readyz
Method: GET
A status code of 200 indicates a successful readiness check.

This is an unauthenticated endpoint intended to be used as a readiness probe. It validates both the ledger connection as well as the database connection.

Previous Next
Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved. Any unauthorized use, duplication or distribution is strictly prohibited. "Digital Asset" and "Daml" are Registered in the U.S. Patent and Trademark Office.


Daml Documentation
Home

Set Up Your Developer Environment

Tutorial: Write Your First Daml App

Create Daml Apps

Important Considerations When Building Applications With Daml
Write Smart Contracts with Daml
Integrate Daml with Off-Ledger Services
Resource Management in Daml Application Design
Managing Latency and Throughput
Avoid Contention Issues
Managing Active Contract Set (ACS) Size
Problem Definition
Relational Databases
HTTP JSON API Service
Upgrading and Extending Daml Applications
Developer Tools
Daml Finance

Deploy Daml

Operate a Daml Ledger

Help

Reference

Early Access

Download as PDF

Developers
Products
Company
Version 
Search

In This Section
Managing Active Contract Set (ACS) Size
Problem Definition
Relational Databases
Solutions
HTTP JSON API Service
Managing Active Contract Set (ACS) Size
Problem Definition
The Active Contract Set (ACS) size makes up the load related to the number of active contracts in the system at any one time. It means the totality of all the contracts that have been created but not yet archived. ACS size may come from a deliberate Daml workflow design, but the size may also be unexpected when insufficient care is given to supporting and auxiliary contract lifetimes.

Tip

See the documentation on Daml contracts for more information.

In Daml systems, ACS size can reach orders of magnitude higher than synonymous loads in common database or blockchain systems. When the ACS size is in the high 100s GBs or TBs, local database access performance may deteriorate. We will look at potential issues around large ACS size and possible solutions.

Relational Databases
Large ACS can have a negative impact on many aspects of system performance in relational databases. The following points focus on PostgreSQL as the underlying database; the details differ in the case of Oracle but the results are similar.

Large ACS size directly affects the resource consumption and performance of a Ledger API client application dealing with a large data set that may not fit into the memory or the application database.
ACS size directly affects the speed at which the ACS can be transmitted from the Ledger API server using the ActiveContractService. In extreme cases, it could take hours to transfer the complete set requested by the application due to the limits imposed by the gRPC channel capacity and the speed of storage queries.
Increased latency is a less direct impact which shows up wherever a query is issued to the database index to make progress. Large ACS size means that the corresponding indices are also large, and at a certain point they will no longer fit into the shared-buffer space. It then takes increasingly longer for the database engine to produce query results. This affects activities such as contract lookups during the command submission, transaction tree streaming, or pointwise transaction lookups.
Large ACS size may affect the speed at which the database underpinning the participant ingests new transactions. Normally, as new updates pour in the write-ahead log commits the table and index changes immediately. Those updates come in two shapes; full-page writes or differential writes. With large volumes, many are full-page writes.
Finally, many dirty pages also translate into prolonged and expensive flushes to the disk as part of the checkpointing process.
Solutions
Pay attention to the lifetime of the contracts. Make sure that the supporting and auxiliary contracts don‚Äôt clutter the ACS and archive them as soon as it is practical to do so.
Set up a frequent pruning schedule. Be aware that pruning is only effective if there are archived contracts available for pruning. If all contracts are still active, pruning has limited success. Refer to our pruning documentation for more information.
Implement an ODS in your ledger client application to limit reliance on read access to the ACS. Do this whenever you notice that the time to initialize the application from the ACS exceeds your pain level.
Monitor database performance.
Monitor the disk read and write activity. Look for sudden changes in the operation patterns. For instance, a sudden increase in the disk‚Äôs read activity may be a sign of indices no longer fitting into the shared buffers.
Observe the performance of the database queries. Check our monitoring documentation for query metrics that can assist. You may also consider setting up a log_min_duration_statement parameter in the PostgreSQL configuration.
Set up autovacuum on the PostgreSQL database. Note that, after pruning, a lot of dead tuples will need removing.
HTTP JSON API Service
We recommend using a relational database and dedicated compute resources to manage large ACS size when using the HTTP JSON API and refer the reader to the above considerations.

Tip

See the HTTP JSON API service documentation on managing high load in the query store and server scaling and redundancy for more information.

Previous Next
Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved. Any unauthorized use, duplication or distribution is strictly prohibited. "Digital Asset" and "Daml" are Registered in the U.S. Patent and Trademark Office.


Daml Documentation
Home

Set Up Your Developer Environment

Tutorial: Write Your First Daml App

Create Daml Apps

Daml Finance

Deploy Daml

Operate a Daml Ledger

Help

Reference

Glossary of Concepts
Daml Example Applications
Daml Language References
Daml Language Cheat Sheet
Language Reference
Overview: Template Structure
Reference: Templates
Reference: Choices
Choice Name
Controllers
Choice Observers
Preconsuming Choices
Postconsuming Choices
Non-consuming Choices
Choice Arguments
Choice Body
Reference: Updates
Reference: Data types
Reference: Built-in functions
Reference: Expressions
Reference: Functions
Reference: File structure
Reference: Packages
Reference: Contract keys
Reference: Exceptions
Reference: Interfaces
The Standard Library
Daml Script Library
Daml Trigger Library
Daml Ledger References
Test Evidence
Early Access

Download as PDF

Developers
Products
Company
Version 
Search

In This Section
Reference: Choices
Choice Name
Controllers
Choice Observers
Contract Consumption
Preconsuming Choices
Postconsuming Choices
Non-consuming Choices
Return Type
Choice Arguments
Choice Body
Reference: Choices
This page gives reference information on choices. For information on the high-level structure of a choice, see Overview: Template Structure.

Choice Name
    choice ExampleChoice
      : () -- replace () with the actual return type
choice keyword
The name of the choice. Must begin with a capital letter.
Must be unique in the module. Different templates defined in the same module cannot share a choice name.
Controllers
      controller exampleParty
controller keyword

The controller is a comma-separated list of values, where each value is either a party or a collection of parties.

The conjunction of all the parties are required to authorize when this choice is exercised.

Warning

You must make sure that the controller parties are observers (or signatories) of the contract, otherwise they cannot see the contract (and therefore cannot exercise the choice).

Choice Observers
Choice observers can be attached to a choice using the observer keyword. The choice observers are a list of parties who are not stakeholders but who see all the consequences of the action.

    choice NameOfChoiceWithObserver
      : () -- replace () with the actual return type
      with
        party : Party -- parameters here
      observer party -- optional specification of choice observers
      controller exampleParty
      do
        return () -- replace this line with the choice body
Contract Consumption
If no qualifier is present, choices are consuming: the contract is archived before the evaluation of the choice body and both the controllers and all contract stakeholders see all consequences of the action.

Preconsuming Choices
    preconsuming choice ExamplePreconsumingChoice
      : () -- replace () with the actual return type
preconsuming keyword. Optional.
Makes a choice pre-consuming: the contract is archived before the body of the exercise is executed.
The create arguments of the contract can still be used in the body of the exercise, but cannot be fetched by its contract id.
The archival behavior is analogous to the consuming default behavior.
Only the controllers and signatories of the contract see all consequences of the action. Other stakeholders merely see an archive action.
Can be thought as a non-consuming choice that implicitly archives the contract before anything else happens
Postconsuming Choices
    postconsuming choice ExamplePostconsumingChoice
      : () -- replace () with the actual return type
postconsuming keyword. Optional.
Makes a choice post-consuming: the contract is archived after the body of the exercise is executed.
The create arguments of the contract can still be used in the body of the exercise as well as the contract id for fetching it.
Only the controllers and signatories of the contract see all consequences of the action. Other stakeholders merely see an archive action.
Can be thought as a non-consuming choice that implicitly archives the contract after the choice has been exercised
Non-consuming Choices
    nonconsuming choice ExampleNonconsumingChoice
      : () -- replace () with the actual return type
nonconsuming keyword. Optional.
Makes a choice non-consuming: that is, exercising the choice does not archive the contract.
Only the controllers and signatories of the contract see all consequences of the action.
Useful in the many situations when you want to be able to exercise a choice more than once.
Return Type
Return type is written immediately after choice name.
All choices have a return type. A contract returning nothing should be marked as returning a ‚Äúunit‚Äù, ie ().
If a contract is/contracts are created in the choice body, usually you would return the contract ID(s) (which have the type ContractId <name of template>). This is returned when the choice is exercised, and can be used in a variety of ways.
Choice Arguments
      with
        exampleParameter : Text
with keyword.
Choice arguments are similar in structure to Template Parameters: a record type.
A choice argument can‚Äôt have the same name as any parameter to the template the choice is in.
Optional - only if you need extra information passed in to exercise the choice.
Choice Body
Introduced with do
The logic in this section is what is executed when the choice gets exercised.
The choice body contains Update expressions. For detail on this, see Reference: Updates.
By default, the last expression in the choice is returned. You can return multiple updates in tuple form or in a custom data type. To return something that isn‚Äôt of type Update, use the return keyword.
Previous Next
Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved. Any unauthorized use, duplication or distribution is strictly prohibited. "Digital Asset" and "Daml" are Registered in the U.S. Patent and Trademark Office.


Daml Documentation
Home

Set Up Your Developer Environment

Tutorial: Write Your First Daml App

Create Daml Apps

Important Considerations When Building Applications With Daml
Write Smart Contracts with Daml
Integrate Daml with Off-Ledger Services
Build Applications
Daml Application Architecture
Parties and Users On a Daml Ledger
Access Active Contracts with the HTTP JSON API Service
HTTP JSON API Service
Run the JSON API
HTTP Status Codes
Create a New Contract
Create a Contract with a Command ID
Exercise by Contract ID
Exercise by Contract Key
Create and Exercise in the Same Transaction
Fetch Contract by Contract ID
Fetch Contract by Key
Get All Active Contracts
Get All Active Contracts Matching a Given Query
Fetch Parties by Identifiers
Fetch All Known Parties
Allocate a New Party
Create a New User
Get Authenticated User Information
Get Specific User Information
Delete Specific User
List Users
Grant User Rights
Revoke User Rights
List Authenticated User Rights
List Specific User Rights
List All DALF Packages
Download a DALF Package
Upload a DAR File
Metering Report
Streaming API
Healthcheck Endpoints
Daml-LF JSON Encoding
Query Language
Use JavaScript Client Libraries with Daml
JSON API Production Setup
Build Integration with the Ledger API
Write Off-Ledger Automation Using Daml
Handle Errors
Authorization
Explicit Contract Disclosure
Resource Management in Daml Application Design
Upgrading and Extending Daml Applications
Developer Tools
Daml Finance

Deploy Daml

Operate a Daml Ledger

Help

Reference

Early Access

Download as PDF

Developers
Products
Company
Version 
Search

In This Section
HTTP JSON API Service
Run the JSON API
Start a Daml Ledger
Start the HTTP JSON API Service
Basic
Standalone JAR
With Query Store
Access Tokens
Party-specific Requests
Using User Tokens
Using Claim Tokens
Auth via HTTP
Auth via WebSockets
HTTP Status Codes
Successful Response, HTTP Status: 200 OK
Successful Response with a Warning, HTTP Status: 200 OK
Failure, HTTP Status: 400 | 401 | 404 | 500
Examples
Create a New Contract
HTTP Request
HTTP Response
Create a Contract with a Command ID
Exercise by Contract ID
HTTP Request
HTTP Response
Exercise by Contract Key
HTTP Request
HTTP Response
Create and Exercise in the Same Transaction
HTTP Request
HTTP Response
Fetch Contract by Contract ID
HTTP Request
Contract Not Found HTTP Response
Contract Found HTTP Response
Fetch Contract by Key
HTTP Request
Contract Not Found HTTP Response
Contract Found HTTP Response
Get All Active Contracts
HTTP Request
HTTP Response
Get All Active Contracts Matching a Given Query
HTTP Request
Empty HTTP Response
Nonempty HTTP Response
Nonempty HTTP Response With Unknown Template IDs Warning
Fetch Parties by Identifiers
HTTP Response
Response With Unknown Parties Warning
Fetch All Known Parties
HTTP Response
Allocate a New Party
HTTP Request
HTTP Response
Create a New User
HTTP Request
HTTP Response
Get Authenticated User Information
HTTP Request
HTTP Response
Get Specific User Information
HTTP Request
HTTP Response
Delete Specific User
HTTP Request
HTTP Response
List Users
HTTP Request
HTTP Response
Grant User Rights
HTTP Request
HTTP Response
Revoke User Rights
HTTP Request
HTTP Response
List Authenticated User Rights
HTTP Request
HTTP Response
List Specific User Rights
HTTP Request
HTTP Response
List All DALF Packages
HTTP Request
HTTP Response
Download a DALF Package
HTTP Request
HTTP Response, status: 200 OK
HTTP Response With Error, Any Status Different from 200 OK
Upload a DAR File
HTTP Request
HTTP Response, Status: 200 OK
HTTP Response With Error
Metering Report
HTTP Response
Streaming API
Error and Warning Reporting
Error and Warning Examples
Contracts Query Stream
Fetch by Key Contracts Stream
Healthcheck Endpoints
Liveness Check
Readiness Check
HTTP JSON API Service
The JSON API provides a significantly simpler way to interact with a ledger than the Ledger API by providing basic active contract set functionality:

creating contracts,
exercising choices on contracts,
querying the current active contract set, and
retrieving all known parties.
The goal of this API is to get your distributed ledger application up and running quickly, so we have deliberately excluded complicating concerns including, but not limited to:

inspecting transactions,
asynchronous submit/completion workflows,
temporal queries (e.g. active contracts as of a certain time), and
For these and other features, use the Ledger API instead. The HTTP JSON API service is a ‚Äúproxy‚Äù, after a fashion, for that API; there is literally nothing that HTTP JSON API service can do that your own application cannot do via gRPC.

If you are using this API from JavaScript or TypeScript, we strongly recommend using the JavaScript bindings and code generator rather than invoking these endpoints directly. This will both simplify access to the endpoints described here and (with TypeScript) help to provide the correct JavaScript value format for each of your contracts, choice arguments, and choice results.

As suggested by those bindings, the primary target application for the HTTP JSON API service is a web application, where user actions translate to one or a few ledger operations. It is not intended for high-throughput, high-performance ledger automation; the Ledger API is better suited to such use cases.

We welcome feedback about the JSON API on our issue tracker, or on our forum.

Run the JSON API
Start a Daml Ledger
You can run the JSON API alongside any ledger exposing the gRPC Ledger API you want. If you don‚Äôt have an existing ledger, you can start an in-memory sandbox:

daml new my-project --template quickstart-java
cd my-project
daml build
daml sandbox --wall-clock-time --dar ./.daml/dist/quickstart-0.0.1.dar
Start the HTTP JSON API Service
Basic
The most basic way to start the JSON API is with the command:

daml json-api --config json-api-app.conf
where a corresponding minimal config file is

{
  server {
    address = "localhost"
    port = 7575
  }
  ledger-api {
    address = "localhost"
    port = 6865
  }
}
This will start the JSON API on port 7575 and connect it to a ledger running on localhost:6865.

Note

Your JSON API service should never be exposed to the internet. When running in production the JSON API should be behind a reverse proxy, such as via NGINX.

The full set of configurable options that can be specified via config file is listed below

{
  server {
    //IP address that HTTP JSON API service listens on. Defaults to 127.0.0.1.
    address = "127.0.0.1"
    //HTTP JSON API service port number. A port number of 0 will let the system pick an ephemeral port.
    port = 7575
  }
  ledger-api {
    address = "127.0.0.1"
    port = 6865
    tls {
        enabled = "true"
        // the certificate to be used by the server
        cert-chain-file = "cert-chain.crt"
        // private key of the server
        private-key-file = "pvt-key.pem"
        // trust collection, which means that all client certificates will be verified using the trusted
        // certificates in this store. if omitted, the JVM default trust store is used.
        trust-collection-file = "root-ca.crt"
    }
  }

  query-store {
    base-config {
      user = "postgres"
      password = "password"
      driver = "org.postgresql.Driver"
      url = "jdbc:postgresql://localhost:5432/test?&ssl=true"

      // prefix for table names to avoid collisions, empty by default
      table-prefix = "foo"

      // max pool size for the database connection pool
      pool-size = 12
      //specifies the min idle connections for database connection pool.
      min-idle = 4
      //specifies the idle timeout for the database connection pool.
      idle-timeout = 12s
      //specifies the connection timeout for database connection pool.
      connection-timeout = 90s
    }
    // option setting how the schema should be handled.
    // Valid options are start-only, create-only, create-if-needed-and-start and create-and-start
    start-mode = "start-only"
  }



  // Optional interval to poll for package updates. Examples: 500ms, 5s, 10min, 1h, 1d. Defaults to 5 seconds
  package-reload-interval = 5s
  //Optional max inbound message size in bytes. Defaults to 4194304.
  max-inbound-message-size = 4194304
  //Optional max inbound message size in bytes used for uploading and downloading package updates. Defaults to the `max-inbound-message-size` setting.
  package-max-inbound-message-size = 4194304
  //Optional max cache size in entries for storing surrogate template id mappings. Defaults to None
  max-template-id-cache-entries = 1000
  //health check timeout in seconds
  health-timeout-seconds = 5

  //Optional websocket configuration parameters
  websocket-config {
    //Maximum websocket session duration
    max-duration = 120m
    //Server-side heartbeat interval duration
    heartbeat-period = 5s
    //akka stream throttle-mode one of either `shaping` or `enforcing`
    mode = "shaping"
  }

  metrics {
    //Start a metrics reporter. Must be one of "console", "csv:///PATH", "graphite://HOST[:PORT][/METRIC_PREFIX]", or "prometheus://HOST[:PORT]".
    reporter = "console"
    //Set metric reporting interval , examples : 1s, 30s, 1m, 1h
    reporting-interval = 30s
  }

  // DEV MODE ONLY (not recommended for production)
  // Allow connections without a reverse proxy providing HTTPS.
  allow-insecure-tokens = false
  // Optional static content configuration string. Contains comma-separated key-value pairs, where:
  // prefix -- URL prefix,
  // directory -- local directory that will be mapped to the URL prefix.
  // Example: "prefix=static,directory=./static-content"
  static-content {
    prefix = "static"
    directory = "static-content-dir"
  }

  auth-config {
    target-scope = "scope-must-be-the-same-as-in-the-participant"
  }
}
Note

You can also start JSON API using CLI args (example below) however this is now deprecated

daml json-api --ledger-host localhost --ledger-port 6865 --http-port 7575
Standalone JAR
The daml json-api command is great during development since it is included with the SDK and integrates with daml start and other commands. Once you are ready to deploy your application, you can download the standalone JAR from Github releases. It is much smaller than the whole SDK and easier to deploy since it only requires a JVM but no other dependencies and no installation process. The JAR accepts exactly the same command line parameters as daml json-api, so to start the standalone JAR, you can use the following command:

java -jar http-json-2.0.0.jar --config json-api-app.conf
Replace the version number 2.0.0 by the version of the SDK you are using.

With Query Store
In production setups, you should configure the HTTP JSON API service to use a PostgreSQL backend as a Query Store. The in-memory backend will call the ledger to fetch the entire active contract set for the templates in your query every time so it is generally not recommended to rely on this in production. Note that the query store is a redundant copy of on-ledger data. It is safe to reinitialize the database at any time.

To enable the PostgreSQL backend you can add the query-store config block as described.

Access Tokens
Each request to the HTTP JSON API Service must come with an access token, regardless of whether the underlying ledger requires it or not. This also includes development setups using an unsecured sandbox. The HTTP JSON API Service does not hold on to the access token, which will be only used to fulfill the request it came along with. The same token will be used to issue the request to the Ledger API.

The HTTP JSON API Service does not validate the token but may need to decode it to extract information that can be used to fill in request fields for party-specific request. How this happens depends partially on the token format you are using.

To connect to a Canton participant that uses target-scopes, the JSON API must also include target-scopes in its configuration as follows:

auth-config {
    target-scope = "scope-must-be-the-same-as-in-the-participant"
}
Party-specific Requests
Party-specific requests, i.e., command submissions and queries, are subject to additional restrictions. For command submissions the token must provide a proof that the bearer can act on behalf of at least one party (and possibly read on behalf of any number of parties). For queries the token must provide a proof that the bearer can either act and/or read of at least one party. This happens regardless of the used access token format. The following paragraphs provide guidance as to how different token formats are used by the HTTP JSON API in this regard.

Using User Tokens
If the underlying ledger supports user management (this includes Canton and the sandbox), you are recommended to use user tokens. For command submissions, the user of the bearer should have actAs rights for at least one party and readAs rights for any number of parties. Queries require the bearer‚Äôs user to have at least one actAs or readAs user right. The application id of the Ledger API request will be the user id.

Using Claim Tokens
These tokens can be used if the underlying ledger does not support user management. For command submissions, actAs must contain at least one party and readAs can contain any number of parties. Queries require at least one party in either actAs or readAs. The application id is mandatory.

Note

While the JSON API receives the token it doesn‚Äôt validate it itself. Upon receiving a token it will pass it, and all data contained within the request, on to the Ledger API‚Äôs AuthService which will then determine if the token is valid and authorized. However, the JSON API does decode the token to extract the ledger id, application id and party so it requires that you use a valid Daml ledger access token format.

For a ledger without authorization, e.g., the default configuration of Daml Sandbox, you can use https://jwt.io (or the JWT library of your choice) to generate your token. You can use an arbitrary secret here. The default ‚Äúheader‚Äù is fine. Under ‚ÄúPayload‚Äù, fill in:

{
  "https://daml.com/ledger-api": {
    "ledgerId": "sandbox",
    "applicationId": "foobar",
    "actAs": ["Alice"]
  }
}
The value of the ledgerId field has to match the ledgerId of your underlying Daml Ledger. For the Sandbox this corresponds to the participant id which by default is just sandbox.

Note

The value of applicationId will be used for commands submitted using that token.

The value for actAs is specified as a list and you provide it with the party that you want to use, such as in the example above which uses Alice for a party. actAs may include more than just one party as the JSON API supports multi-party submissions.

The party should reference an already allocated party.

Note

As mentioned above the JSON API does not validate tokens so if your ledger runs without authorization you can use an arbitrary secret.

Then the ‚ÄúEncoded‚Äù box should have your token, ready for passing to the service as described in the following sections.

Alternatively, here are two tokens you can use for testing:

{"https://daml.com/ledger-api": {"ledgerId": "sandbox", "applicationId": "HTTP-JSON-API-Gateway", "actAs": ["Alice"]}}:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJzYW5kYm94IiwiYXBwbGljYXRpb25JZCI6IkhUVFAtSlNPTi1BUEktR2F0ZXdheSIsImFjdEFzIjpbIkFsaWNlIl19fQ.FIjS4ao9yu1XYnv1ZL3t7ooPNIyQYAHY3pmzej4EMCM
{"https://daml.com/ledger-api": {"ledgerId": "sandbox", "applicationId": "HTTP-JSON-API-Gateway", "actAs": ["Bob"]}}:

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJzYW5kYm94IiwiYXBwbGljYXRpb25JZCI6IkhUVFAtSlNPTi1BUEktR2F0ZXdheSIsImFjdEFzIjpbIkJvYiJdfX0.y6iwpnYt-ObtNo_FyLVxMtNTwpJF8uxzNfPELQUVKVg
Auth via HTTP
Set HTTP header Authorization: Bearer paste-jwt-here

Example:

Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk
Auth via WebSockets
WebSocket clients support a ‚Äúsubprotocols‚Äù argument (sometimes simply called ‚Äúprotocols‚Äù); this is usually in a list form but occasionally in comma-separated form. Check documentation for your WebSocket library of choice for details.

For HTTP JSON requests, you must pass two subprotocols:

daml.ws.auth
jwt.token.paste-jwt-here
Example:

jwt.token.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdpk
HTTP Status Codes
The JSON API reports errors using standard HTTP status codes. It divides HTTP status codes into 3 groups indicating:

success (200)
failure due to a client-side problem (400, 401, 403, 404, 409, 429)
failure due to a server-side problem (500, 503)
The JSON API can return one of the following HTTP status codes:

200 - OK
400 - Bad Request (Client Error)
401 - Unauthorized, authentication required
403 - Forbidden, insufficient permissions
404 - Not Found
409 - Conflict, contract ID or key missing or duplicated
500 - Internal Server Error
503 - Service Unavailable, ledger server is not running yet or has been shut down
504 - Gateway Timeout, transaction failed to receive its completion within the predefined timeout
When the Ledger API returns an error code, the JSON API maps it to one of the above codes according to the official gRPC to HTTP code mapping.

If a client‚Äôs HTTP GET or POST request reaches an API endpoint, the corresponding response will always contain a JSON object with a status field, and either an errors or result field. It may also contain an optional warnings and/or an optional ledgerApiError :

{
    "status": <400 | 401 | 403 | 404 | 409 | 500 | 503 | 504>,
    "errors": <JSON array of strings>, | "result": <JSON object or array>,
    ["warnings": <JSON object> ],
    ["ledgerApiError": <JSON object> ]
}
Where:

status ‚Äì a JSON number which matches the HTTP response status code returned in the HTTP header,
errors ‚Äì a JSON array of strings, each string represents one error,
result ‚Äì a JSON object or JSON array, representing one or many results,
warnings ‚Äì an optional field with a JSON object, representing one or many warnings.
ledgerApiError ‚Äì an optional field with a JSON object, representing detail of an error if it was originated from Ledger API.
See the following blog post for more details about error handling best practices: REST API Error Codes 101.

See The Ledger API error codes for more details about error codes from Ledger API.

Successful Response, HTTP Status: 200 OK
Content-Type: application/json
Content:
{
    "status": 200,
    "result": <JSON object>
}
Successful Response with a Warning, HTTP Status: 200 OK
Content-Type: application/json
Content:
{
    "status": 200,
    "result": <JSON object>,
    "warnings": <JSON object>
}
Failure, HTTP Status: 400 | 401 | 404 | 500
Content-Type: application/json
Content:
{
    "status": <400 | 401 | 404 | 500>,
    "errors": <JSON array of strings>,
    ["ledgerApiError": <JSON object> ]
}
Examples
Result with JSON Object without Warnings:

{"status": 200, "result": {...}}
Result with JSON Array and Warnings:

{"status": 200, "result": [...], "warnings": {"unknownTemplateIds": ["UnknownModule:UnknownEntity"]}}
Bad Request Error:

{"status": 400, "errors": ["JSON parser error: Unexpected character 'f' at input index 27 (line 1, position 28)"]}
Bad Request Error with Warnings:

{"status":400, "errors":["Cannot resolve any template ID from request"], "warnings":{"unknownTemplateIds":["XXX:YYY","AAA:BBB"]}}
Authentication Error:

{"status": 401, "errors": ["Authentication Required"]}
Not Found Error:

{"status": 404, "errors": ["HttpMethod(POST), uri: http://localhost:7575/v1/query1"]}
Internal Server Error:

{"status": 500, "errors": ["Cannot initialize Ledger API"]}
Create a New Contract
To create an Iou contract from the Quickstart guide:

template Iou
  with
    issuer : Party
    owner : Party
    currency : Text
    amount : Decimal
    observers : [Party]
HTTP Request
URL: /v1/create
Method: POST
Content-Type: application/json
Content:
{
  "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer",
  "payload": {
    "issuer": "Alice",
    "owner": "Alice",
    "currency": "USD",
    "amount": "999.99",
    "observers": []
  }
}
Where:

templateId is the contract template identifier, which has the following two formats: #<package name>:<module>:<entity> or <package ID>:<module>:<entity>.

The package name format supports the smart contract upgrading feature, allowing contracts with different package IDs but the same package name to be used uniformly.

Using the package ID format refers to a single package.

Previously JSON API had supported partially qualified template IDs, such as simply <module>:<entity>) as an interactive convenience which fails if there is more than one package with matching template names. Since this format was not supported for production use and will not work with smart contract upgrades, it is now unavailable.

payload field contains contract fields as defined in the Daml template and formatted according to Daml-LF JSON Encoding.

HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": {
        "observers": [],
        "agreementText": "",
        "payload": {
            "observers": [],
            "issuer": "Alice",
            "amount": "999.99",
            "currency": "USD",
            "owner": "Alice"
        },
        "signatories": [
            "Alice"
        ],
        "contractId": "#124:0",
        "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou",
        "completionOffset":"0000000000000084"
    }
}
Where:

status field matches the HTTP response status code returned in the HTTP header,
result field contains created contract details. Keep in mind that templateId in the JSON API response is always fully qualified (always contains package ID).
Create a Contract with a Command ID
When creating a new contract or exercising a choice you may specify an optional meta field. This allows you to control various extra settings used when submitting a command to the ledger. Each of these meta fields is optional.

Note

You cannot currently use commandIds anywhere else in the JSON API, but you can use it for observing the results of its commands outside the JSON API in logs or via the Ledger API‚Äôs Command Services

{
  "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer",
  "payload": {
    "observers": [],
    "issuer": "Alice",
    "amount": "999.99",
    "currency": "USD",
    "owner": "Alice"
  },
  "meta": {
    "commandId": "a unique ID",
    "actAs": ["Alice"],
    "readAs": ["PublicParty"],
    "deduplicationPeriod": {
      "durationInMillis": 10000,
      "type": "Duration"
    },
    "submissionId": "d2f941b1-ee5c-4634-9a51-1335ce6902fa"
  }
}
Where:

commandId ‚Äì optional field, a unique string identifying the command.
actAs ‚Äì a non-empty list of parties, overriding the set from the JWT user; must be a subset of the JWT user‚Äôs set.
readAs ‚Äì a list of parties, overriding the set from the JWT user; must be a subset of the JWT user‚Äôs set.
submissionId ‚Äì a string, used for deduplicating retried requests. If you do not set it, a random one will be chosen, effectively treating the request as unique and disabling deduplication.
deduplicationPeriod ‚Äì either a Duration as above, which is how far back in time prior commands will be searched for this submission, or an Offset as follows, which is the earliest ledger offset after which to search for the submission.
"deduplicationPeriod": {
  "offset": "0000000000000083",
  "type": "Offset"
}
Exercise by Contract ID
The JSON command below, demonstrates how to exercise an Iou_Transfer choice on an Iou contract:

    choice Iou_Transfer : ContractId IouTransfer
      with
        newOwner : Party
      controller owner
      do create IouTransfer with iou = this; newOwner
HTTP Request
URL: /v1/exercise
Method: POST
Content-Type: application/json
Content:
{
    "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer",
    "choiceInterfaceId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransferInterface",
    "contractId": "#124:0",
    "choice": "Iou_Transfer",
    "argument": {
        "newOwner": "Alice"
    }
}
Where:

templateId ‚Äì contract template or interface identifier, same as in create request,
choiceInterfaceId ‚Äì optional template or interface that defines the choice, same format as templateId,
contractId ‚Äì contract identifier, the value from the create response,
choice ‚Äì Daml contract choice, that is being exercised,
argument ‚Äì contract choice argument(s).
templateId and choiceInterfaceId are treated as with exercise by key. However, because contractId is always unambiguous, you may alternatively simply specify the interface ID as the templateId argument, and ignore choiceInterfaceId entirely. This isn‚Äôt true of exercise-by-key or create-and-exercise, so we suggest treating this request as if this alternative isn‚Äôt available.

HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": {
        "exerciseResult": "#201:1",
        "events": [
            {
                "archived": {
                    "contractId": "#124:0",
                    "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"
                }
            },
            {
                "created": {
                    "observers": [],
                    "agreementText": "",
                    "payload": {
                        "iou": {
                            "observers": [],
                            "issuer": "Alice",
                            "amount": "999.99",
                            "currency": "USD",
                            "owner": "Alice"
                        },
                        "newOwner": "Alice"
                    },
                    "signatories": [
                        "Alice"
                    ],
                    "contractId": "#201:1",
                    "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:IouTransfer"
                }
            }
        ],
        "completionOffset":"0000000000000083"
    }
}
Where:

status field matches the HTTP response status code returned in the HTTP header,

result field contains contract choice execution details:

exerciseResult field contains the return value of the exercised contract choice.
events contains an array of contracts that were archived and created as part of the choice execution. The array may contain: zero or many {"archived": {...}} and zero or many {"created": {...}} elements. The order of the contracts is the same as on the ledger.
completionOffset is the ledger offset of the transaction containing the exercise‚Äôs ledger changes.
Exercise by Contract Key
The JSON command below, demonstrates how to exercise the Archive choice on the Account contract with a (Party, Text) contract key defined like this:

template Account with
    owner : Party
    number : Text
    status : AccountStatus
  where
    signatory owner
    key (owner, number) : (Party, Text)
    maintainer key._1
HTTP Request
URL: /v1/exercise
Method: POST
Content-Type: application/json
Content:
{
    "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account",
    "key": {
        "_1": "Alice",
        "_2": "abc123"
    },
    "choiceInterfaceId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:AccountInterface",
    "choice": "Archive",
    "argument": {}
}
Where:

templateId ‚Äì contract template identifier, same as in create request,
key ‚Äì contract key, formatted according to the Daml-LF JSON Encoding,
choiceInterfaceId ‚Äì optional template or interface that defines the choice, same format as templateId,
choice ‚Äì Daml contract choice, that is being exercised,
argument ‚Äì contract choice argument(s), empty, because Archive does not take any.
key is always searched in relation to the templateId. The choice, on the other hand, is searched according to choiceInterfaceId; if choiceInterfaceId is not specified, templateId is its default. We recommend always specifying choiceInterfaceId when invoking an interface choice; however, if the set of Daml-LF packages on the participant only contains one choice with a given name associated with templateId, that choice will be exercised, regardless of where it is defined. If a template and one or more of the interfaces it implements declares a choice, and choiceInterfaceId is not used, the one directly defined on the choice will be exercised. If choice selection is still ambiguous given these rules, the endpoint will fail as if the choice isn‚Äôt defined.

HTTP Response
Formatted similar to Exercise by Contract ID response.

Create and Exercise in the Same Transaction
This command allows creating a contract and exercising a choice on the newly created contract in the same transaction.

HTTP Request
URL: /v1/create-and-exercise
Method: POST
Content-Type: application/json
Content:
{
  "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou",
  "payload": {
    "observers": [],
    "issuer": "Alice",
    "amount": "999.99",
    "currency": "USD",
    "owner": "Alice"
  },
  "choiceInterfaceId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:IouInterface",
  "choice": "Iou_Transfer",
  "argument": {
    "newOwner": "Bob"
  }
}
Where:

templateId ‚Äì the initial contract template identifier, in the same format as in the create request,
payload ‚Äì the initial contract fields as defined in the Daml template and formatted according to Daml-LF JSON Encoding,
choiceInterfaceId ‚Äì optional template or interface that defines the choice, same format as templateId,
choice ‚Äì Daml contract choice, that is being exercised,
argument ‚Äì contract choice argument(s).
templateId and choiceInterfaceId are treated as with exercise by key, with the exception that it is payload, not key, strictly interpreted according to templateId.

HTTP Response
Please note that the response below is for a consuming choice, so it contains:

created and archived events for the initial contract ("contractId": "#1:0"), which was created and archived right away when a consuming choice was exercised on it,
a created event for the contract that is the result of exercising the choice ("contractId": "#1:2").
Content-Type: application/json
Content:
{
  "result": {
    "exerciseResult": "#1:2",
    "events": [
      {
        "created": {
          "observers": [],
          "agreementText": "",
          "payload": {
            "observers": [],
            "issuer": "Alice",
            "amount": "999.99",
            "currency": "USD",
            "owner": "Alice"
          },
          "signatories": [
            "Alice"
          ],
          "contractId": "#1:0",
          "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:Iou"
        }
      },
      {
        "archived": {
          "contractId": "#1:0",
          "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:Iou"
        }
      },
      {
        "created": {
          "observers": [
            "Bob"
          ],
          "agreementText": "",
          "payload": {
            "iou": {
              "observers": [],
              "issuer": "Alice",
              "amount": "999.99",
              "currency": "USD",
              "owner": "Alice"
            },
            "newOwner": "Bob"
          },
          "signatories": [
            "Alice"
          ],
          "contractId": "#1:2",
          "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer"
        }
      }
    ]
  },
  "status": 200
}
Fetch Contract by Contract ID
HTTP Request
URL: /v1/fetch
Method: POST
Content-Type: application/json
Content:
application/json body:

{
  "contractId": "#201:1",
  "templateId": "a3b788b4dc18dc060bfb82366ae6dc055b1e361d646d5cfdb1b729607e344336:Iou:IouTransfer"
}
readers may be passed as with Query. templateId is optional, but you are strongly advised to always pass it explicitly to minimize the data read from the Ledger API to answer the query. It can be either a template ID or an interface ID.

Contract Not Found HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": null
}
Contract Found HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": {
        "observers": [],
        "agreementText": "",
        "payload": {
            "iou": {
                "observers": [],
                "issuer": "Alice",
                "amount": "999.99",
                "currency": "USD",
                "owner": "Alice"
            },
            "newOwner": "Alice"
        },
        "signatories": [
            "Alice"
        ],
        "contractId": "#201:1",
        "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:IouTransfer"
    }
}
Fetch Contract by Key
Show the currently active contract that matches a given key.

The websocket endpoint /v1/stream/fetch can be used to search multiple keys in the same request, or in place of iteratively invoking this endpoint to respond to changes on the ledger.

HTTP Request
URL: /v1/fetch
Method: POST
Content-Type: application/json
Content:
{
    "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account",
    "key": {
        "_1": "Alice",
        "_2": "abc123"
    }
}
readers may be passed as with Query.

Contract Not Found HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": null
}
Contract Found HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": {
        "observers": [],
        "agreementText": "",
        "payload": {
            "owner": "Alice",
            "number": "abc123",
            "status": {
                "tag": "Enabled",
                "value": "2020-01-01T00:00:01Z"
            }
        },
        "signatories": [
            "Alice"
        ],
        "key": {
            "_1": "Alice",
            "_2": "abc123"
        },
        "contractId": "#697:0",
        "templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account"
    }
}
Get All Active Contracts
List all currently active contracts for all known templates.

Note

Retrieved contracts do not get persisted into a query store database. Query store is a search index and can be used to optimize search latency. See Start HTTP service for information on how to start JSON API service with a query store enabled.

Note

You can only query active contracts with the /v1/query endpoint. Archived contracts (those that were archived or consumed during an exercise operation) will not be shown in the results.

HTTP Request
URL: /v1/query
Method: GET
Content: <EMPTY>
HTTP Response
The response is the same as for the POST method below.

Get All Active Contracts Matching a Given Query
List currently active contracts that match a given query.

The websocket endpoint /v1/stream/query can be used in place of iteratively invoking this endpoint to respond to changes on the ledger.

HTTP Request
URL: /v1/query
Method: POST
Content-Type: application/json
Content:
{
    "templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"],
    "query": {"amount": 999.99},
    "readers": ["Alice"]
}
Where:

templateIds ‚Äì either an array of contract template identifiers in the same format as in the create request. It can also be an array containing a single interface identifier to search through. Mixing of template ID‚Äôs and interface ID‚Äôs, or specifying more than one interface ID is not allowed. - query ‚Äì search criteria to apply to the specified templateIds, formatted according to the Query Language.
readers ‚Äì optional non-empty list of parties to query as; must be a subset of the actAs/readAs parties in the JWT
Empty HTTP Response
Content-Type: application/json
Content:
{
    "status": 200,
    "result": []
}
Nonempty HTTP Response
Content-Type: application/json
Content:
{
    "result": [
        {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "999.99",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": [
                "Alice"
            ],
            "contractId": "#52:0",
            "templateId": "b10d22d6c2f2fae41b353315cf893ed66996ecb0abe4424ea6a81576918f658a:Iou:Iou"
        }
    ],
    "status": 200
}
Where

result contains an array of contracts, each contract formatted according to Daml-LF JSON Encoding,
status matches the HTTP status code returned in the HTTP header.
Nonempty HTTP Response With Unknown Template IDs Warning
Content-Type: application/json
Content:
{
    "warnings": {
        "unknownTemplateIds": ["UnknownModule:UnknownEntity"]
    },
    "result": [
        {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "999.99",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": [
                "Alice"
            ],
            "contractId": "#52:0",
            "templateId": "b10d22d6c2f2fae41b353315cf893ed66996ecb0abe4424ea6a81576918f658a:Iou:Iou"
        }
    ],
    "status": 200
}
Fetch Parties by Identifiers
URL: /v1/parties
Method: POST
Content-Type: application/json
Content:
["Alice", "Bob", "Dave"]
If an empty JSON array is passed: [], this endpoint returns BadRequest(400) error:

{
  "status": 400,
  "errors": [
    "JsonReaderError. Cannot read JSON: <[]>. Cause: spray.json.DeserializationException: must be a list with at least 1 element"
  ]
}
HTTP Response
Content-Type: application/json
Content:
{
  "status": 200,
  "result": [
    {
      "identifier": "Alice",
      "displayName": "Alice & Co. LLC",
      "isLocal": true
    },
    {
      "identifier": "Bob",
      "displayName": "Bob & Co. LLC",
      "isLocal": true
    },
    {
      "identifier": "Dave",
      "isLocal": true
    }
  ]
}
Please note that the order of the party objects in the response is not guaranteed to match the order of the passed party identifiers.

Where

identifier ‚Äì a stable unique identifier of a Daml party,
displayName ‚Äì optional human readable name associated with the party. Might not be unique,
isLocal ‚Äì true if party is hosted by the backing participant.
Response With Unknown Parties Warning
Content-Type: application/json
Content:
{
  "result": [
    {
      "identifier": "Alice",
      "displayName": "Alice & Co. LLC",
      "isLocal": true
    }
  ],
  "warnings": {
    "unknownParties": ["Erin"]
  },
  "status": 200
}
The result might be an empty JSON array if none of the requested parties is known.

Fetch All Known Parties
URL: /v1/parties
Method: GET
Content: <EMPTY>
HTTP Response
The response is the same as for the POST method above.

Allocate a New Party
This endpoint is a JSON API proxy for the Ledger API‚Äôs AllocatePartyRequest. For more information about party management, please refer to Provisioning Identifiers part of the Ledger API documentation.

HTTP Request
URL: /v1/parties/allocate
Method: POST
Content-Type: application/json
Content:
{
  "identifierHint": "Carol",
  "displayName": "Carol & Co. LLC"
}
Please refer to AllocateParty documentation for information about the meaning of the fields.

All fields in the request are optional, this means that an empty JSON object is a valid request to allocate a new party:

{}
HTTP Response
{
  "result": {
    "identifier": "Carol",
    "displayName": "Carol & Co. LLC",
    "isLocal": true
  },
  "status": 200
}
Create a New User
This endpoint exposes the Ledger API‚Äôs CreateUser RPC.

HTTP Request
URL: /v1/user/create
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol",
  "primaryParty": "Carol",
  "rights": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ]
}
Please refer to CreateUser RPC documentation for information about the meaning of the fields.

Only the userId fields in the request is required, this means that an JSON object containing only it is a valid request to create a new user.

HTTP Response
{
  "result": {},
  "status": 200
}
Get Authenticated User Information
This endpoint exposes the Ledger API‚Äôs GetUser RPC.

The user ID will always be filled out with the user specified via the currently used user token.

HTTP Request
URL: /v1/user
Method: GET
HTTP Response
{
  "result": {
    "userId": "carol",
    "primaryParty": "Carol"
  },
  "status": 200
}
Get Specific User Information
This endpoint exposes the Ledger API‚Äôs GetUser RPC.

HTTP Request
URL: /v1/user
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol"
}
Please refer to GetUser RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": {
    "userId": "carol",
    "primaryParty": "Carol"
  },
  "status": 200
}
Delete Specific User
This endpoint exposes the Ledger API‚Äôs DeleteUser RPC.

HTTP Request
URL: /v1/user/delete
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol"
}
Please refer to DeleteUser RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": {},
  "status": 200
}
List Users
This endpoint exposes the Ledger API‚Äôs ListUsers RPC.

HTTP Request
URL: /v1/users
Method: GET
HTTP Response
{
  "result": [
    {
        "userId": "carol",
        "primaryParty": "Carol"
    },
    {
        "userId": "bob",
        "primaryParty": "Bob"
    }
  ],
  "status": 200
}
Grant User Rights
This endpoint exposes the Ledger API‚Äôs GrantUserRights RPC.

HTTP Request
URL: /v1/user/rights/grant
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol",
  "rights": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ]
}
Please refer to GrantUserRights RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ],
  "status": 200
}
Returns the rights that were newly granted.

Revoke User Rights
This endpoint exposes the Ledger API‚Äôs RevokeUserRights RPC.

HTTP Request
URL: /v1/user/rights/revoke
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol",
  "rights": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ]
}
Please refer to RevokeUserRights RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ],
  "status": 200
}
Returns the rights that were actually granted.

List Authenticated User Rights
This endpoint exposes the Ledger API‚Äôs ListUserRights RPC.

The user ID will always be filled out with the user specified via the currently used user token.

HTTP Request
URL: /v1/user/rights
Method: GET
HTTP Response
{
  "result": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ],
  "status": 200
}
List Specific User Rights
This endpoint exposes the Ledger API‚Äôs ListUserRights RPC.

HTTP Request
URL: /v1/user/rights
Method: POST
Content-Type: application/json
Content:
{
  "userId": "carol"
}
Please refer to ListUserRights RPC documentation for information about the meaning of the fields.

HTTP Response
{
  "result": [
    {
      "type": "CanActAs",
      "party": "Carol"
    },
    {
      "type": "CanReadAs",
      "party": "Alice"
    },
    {
      "type": "CanReadAs",
      "party": "Bob"
    },
    {
      "type": "ParticipantAdmin"
    }
  ],
  "status": 200
}
List All DALF Packages
HTTP Request
URL: /v1/packages
Method: GET
Content: <EMPTY>
HTTP Response
{
  "result": [
    "c1f1f00558799eec139fb4f4c76f95fb52fa1837a5dd29600baa1c8ed1bdccfd",
    "733e38d36a2759688a4b2c4cec69d48e7b55ecc8dedc8067b815926c917a182a",
    "bfcd37bd6b84768e86e432f5f6c33e25d9e7724a9d42e33875ff74f6348e733f",
    "40f452260bef3f29dede136108fc08a88d5a5250310281067087da6f0baddff7",
    "8a7806365bbd98d88b4c13832ebfa305f6abaeaf32cfa2b7dd25c4fa489b79fb"
  ],
  "status": 200
}
Where result is the JSON array containing the package IDs of all loaded DALFs.

Download a DALF Package
HTTP Request
URL: /v1/packages/<package ID>
Method: GET
Content: <EMPTY>
Note that the desired package ID is specified in the URL.

HTTP Response, status: 200 OK
Transfer-Encoding: chunked
Content-Type: application/octet-stream
Content: <DALF bytes>
The content (body) of the HTTP response contains raw DALF package bytes, without any encoding. Note that the package ID specified in the URL is actually the SHA-256 hash of the downloaded DALF package and can be used to validate the integrity of the downloaded content.

HTTP Response With Error, Any Status Different from 200 OK
Any status different from 200 OK will be in the format specified below.

Content-Type: application/json
Content:
{
    "errors": [
        "io.grpc.StatusRuntimeException: NOT_FOUND"
    ],
    "status": 500
}
Upload a DAR File
HTTP Request
URL: /v1/packages
Method: POST
Content-Type: application/octet-stream
Content: <DAR bytes>
The content (body) of the HTTP request contains raw DAR file bytes, without any encoding.

HTTP Response, Status: 200 OK
Content-Type: application/json
Content:
{
    "result": 1,
    "status": 200
}
HTTP Response With Error
Content-Type: application/json
Content:
{
    "errors": [
        "io.grpc.StatusRuntimeException: INVALID_ARGUMENT: Invalid argument: Invalid DAR: package-upload, content: [}]"
    ],
    "status": 500
}
Metering Report
For a description of participant metering, the parameters, and the report format see the Participant Metering.

URL: /v1/metering-report
Method: POST
Content-Type: application/json
Content:
{
  "from": "2022-01-01",
  "to": "2022-02-01",
  "application": "some-application"
}
HTTP Response
Content-Type: application/json
Content:
{
  "status": 200,
  "result": {
    "participant": "some-participant",
    "request": {
      "from": "2022-01-01T00:00:00Z",
      "to": "2022-02-01T00:00:00Z"
    },
    "final": true,
    "applications": [
      {
        "application": "some-application",
        "events": 42
      }
    ]
  }
}
Streaming API
Two subprotocols must be passed with every request, as described in Auth via WebSockets.

JavaScript/Node.js example demonstrating how to establish Streaming API connection:

const wsProtocol = "daml.ws.auth";
const tokenPrefix = "jwt.token.";
const jwt =
  "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwczovL2RhbWwuY29tL2xlZGdlci1hcGkiOnsibGVkZ2VySWQiOiJNeUxlZGdlciIsImFwcGxpY2F0aW9uSWQiOiJIVFRQLUpTT04tQVBJLUdhdGV3YXkiLCJhY3RBcyI6WyJBbGljZSJdfX0.34zzF_fbWv7p60r5s1kKzwndvGdsJDX-W4Xhm4oVdp";
const subprotocols = [`${tokenPrefix}${jwt}`, wsProtocol];

const ws = new WebSocket("ws://localhost:7575/v1/stream/query", subprotocols);

ws.addEventListener("open", function open() {
  ws.send(JSON.stringify({templateIds: ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"]}));
});

ws.addEventListener("message", function incoming(data) {
  console.log(data);
});
Please note that Streaming API does not allow multiple requests over the same WebSocket connection. The server returns an error and disconnects if second request received over the same WebSocket connection.

Error and Warning Reporting
Errors and warnings reported as part of the regular on-message flow: ws.addEventListener("message", ...).

Streaming API error messages formatted the same way as synchronous API errors.

Streaming API reports only one type of warnings ‚Äì unknown template IDs, which is formatted as:

{"warnings":{"unknownTemplateIds":<JSON Array of template ID strings>>}}
Error and Warning Examples
{"warnings": {"unknownTemplateIds": ["UnknownModule:UnknownEntity"]}}

{
  "errors":["JsonReaderError. Cannot read JSON: <{\"templateIds\":[]}>. Cause: spray.json.DeserializationException: search requires at least one item in 'templateIds'"],
  "status":400
}

{
  "errors":["Multiple requests over the same WebSocket connection are not allowed."],
  "status":400
}

{
  "errors":["Could not resolve any template ID from request."],
  "status":400
}
Contracts Query Stream
URL: /v1/stream/query
Scheme: ws
Protocol: WebSocket
List currently active contracts that match a given query, with continuous updates.

Simpler use-cases that do not require continuous updates should use the simpler /v1/query endpoint instead.

application/json body must be sent first, formatted according to the Query Language:

{"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"]}
Multiple queries may be specified in an array, for overlapping or different sets of template IDs.:

[
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "query": {"amount": {"%lte": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:OtherIou:OtherIou"], "query": {"amount": {"%gt": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"]}
]
Only one interface ID can be provided in templateIds. An interface ID can be used in all queries:

[
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"], "query": {"amount": {"%lte": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"], "query": {"amount": {"%gt": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"]}
]
Mixing of template ID‚Äôs and interface ID‚Äôs or specifying more than one interface ID across queries is not allowed. BadRequest(400) error will be returned.:

[
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "query": {"amount": {"%lte": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"], "query": {"amount": {"%gt": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Ifc:Ifc"]}
]
Queries have two ways to specify an offset.

An offset, a string supplied by an earlier query output message, may optionally be specified alongside each query itself:

[
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "query": {"amount": {"%lte": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "query": {"amount": {"%gt": 50}}},
    {"templateIds": ["11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Iou:Iou"], "offset": "5609"}
]
If specified, the stream will include only contract creations and archivals after the response body that included that offset. Queries with no offset will begin with all active contracts for that query, as usual.

If an offset is specified before the queries, as a separate body, it will be used as a default offset for all queries that do not include an offset themselves:

{"offset": "4307"}
For example, if this message preceded the above 3-query example, it would be as if "4307" had been specified for the first two queries, while "5609" would be used for the third query.

If any offset has been pruned, the websocket will immediately fail with code 1011 and message internal error.

The output is a series of JSON documents, each payload formatted according to Daml-LF JSON Encoding:

{
    "events": [{
        "created": {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "999.99",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": ["Alice"],
            "contractId": "#1:0",
            "templateId": "eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou"
        },
        "matchedQueries": [1, 2]
    }]
}
where matchedQueries indicates the 0-based indices into the request list of queries that matched this contract.

Every events block following the end of contracts that existed when the request started includes an offset. The stream is guaranteed to send an offset immediately at the beginning of this ‚Äúlive‚Äù data, which may or may not contain any events; if it does not contain events and no events were emitted before, it may be null if there was no transaction on the ledger or a string representing the current ledger end; otherwise, it will be a string. For example, you might use it to turn off an initial ‚Äúloading‚Äù indicator:

{
    "events": [],
    "offset": "2"
}
Note

Events in the following ‚Äúlive‚Äù data may include events that precede this offset if an earlier per-query offset was specified.

This has been done with the intent of allowing to use per-query offset s to efficiently use a single connection to multiplex various requests. To give an example of how this would work, let‚Äôs say that there are two contract templates, A and B . Your application first queries for A s without specifying an offset. Then some client-side interaction requires the application to do the same for B s. The application can save the latest observed offset for the previous query, which let‚Äôs say is 42, and issue a new request that queries for all B s without specifying an offset and all A s from 42. While this happens on the client, a few more A s and B s are created and the new request is issued once the latest offset is 47. The response to this will contain a message with all active B s, followed by the message reporting the offset 47, followed by a stream of live updates that contains new A s starting from 42 and new B s starting from 47 .

To keep the stream alive, you‚Äôll occasionally see messages like this, which can be safely ignored if you do not need to capture the last seen ledger offset:

{"events":[],"offset":"5609"}
where offset is the last seen ledger offset.

After submitting an Iou_Split exercise, which creates two contracts and archives the one above, the same stream will eventually produce:

{
    "events": [{
        "archived": {
            "contractId": "#1:0",
            "templateId": "eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou"
        }
    }, {
        "created": {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "42.42",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": ["Alice"],
            "contractId": "#2:1",
            "templateId": "eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou"
        },
        "matchedQueries": [0, 2]
    }, {
        "created": {
            "observers": [],
            "agreementText": "",
            "payload": {
                "observers": [],
                "issuer": "Alice",
                "amount": "957.57",
                "currency": "USD",
                "owner": "Alice"
            },
            "signatories": ["Alice"],
            "contractId": "#2:2",
            "templateId": "eb3b150383a979d6765b8570a17dd24ae8d8b63418ee5fd20df20ad2a1c13976:Iou:Iou"
        },
        "matchedQueries": [1, 2]
    }],
    "offset": "3"
}
If any template IDs are found not to resolve, the first element of the stream will report them:

{"warnings": {"unknownTemplateIds": ["UnknownModule:UnknownEntity"]}}
and the stream will continue, provided that at least one template ID resolved properly.

Aside from "created" and "archived" elements, "error" elements may appear, which contain a string describing the error. The stream will continue in these cases, rather than terminating.

Some notes on behavior:

Each result array means ‚Äúthis is what would have changed if you just polled /v1/query iteratively.‚Äù In particular, just as polling search can ‚Äúmiss‚Äù contracts (as a create and archive can be paired between polls), such contracts may or may not appear in any result object.
No archived ever contains a contract ID occurring within a created in the same array. So, for example, supposing you are keeping an internal map of active contracts keyed by contract ID, you can apply the created first or the archived first, forwards, backwards, or in random order, and be guaranteed to get the same results.
Within a given array, if an archived and created refer to contracts with the same template ID and contract key, the archived is guaranteed to occur before the created.
Except in cases of #3, within a single response array, the order of created and archived is undefined and does not imply that any element occurred ‚Äúbefore‚Äù or ‚Äúafter‚Äù any other one.
You will almost certainly receive contract IDs in archived that you never received a created for. These are contracts that query filtered out, but for which the server no longer is aware of that. You can safely ignore these. However, such ‚Äúphantom archives‚Äù are guaranteed to represent an actual archival on the ledger, so if you are keeping a more global dataset outside the context of this specific search, you can use that archival information as you wish.
Fetch by Key Contracts Stream
URL: /v1/stream/fetch
Scheme: ws
Protocol: WebSocket
List currently active contracts that match one of the given {templateId, key} pairs, with continuous updates.

Simpler use-cases that search for only a single key and do not require continuous updates should use the simpler /v1/fetch endpoint instead.

application/json body must be sent first, formatted according to the following rule:

[
    {"templateId": "<template ID 1>", "key": <key 1>},
    {"templateId": "<template ID 2>", "key": <key 2>},
    ...
    {"templateId": "<template ID N>", "key": <key N>}
]
Where:

templateId ‚Äì contract template identifier, same as in create request,
key ‚Äì contract key, formatted according to the Daml-LF JSON Encoding,
Example:

[
    {"templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account", "key": {"_1": "Alice", "_2": "abc123"}},
    {"templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account", "key": {"_1": "Alice", "_2": "def345"}}
]
The output stream has the same format as the output from the Contracts Query Stream. We further guarantee that for every archived event appearing on the stream there has been a matching created event earlier in the stream, except in the case of missing contractIdAtOffset fields in the case described below.

You may supply optional offset s for the stream, exactly as with query streams. However, you should supply with each {templateId, key} pair a contractIdAtOffset, which is the contract ID currently associated with that pair at the point of the given offset, or null if no contract ID was associated with the pair at that offset. For example, with the above keys, if you had one "abc123" contract but no "def345" contract, you might specify:

[
    {"templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account", "key": {"_1": "Alice", "_2": "abc123"},
     "contractIdAtOffset": "#1:0"},
    {"templateId": "11c8f3ace75868d28136adc5cfc1de265a9ee5ad73fe8f2db97510e3631096a2:Account:Account", "key": {"_1": "Alice", "_2": "def345"},
     "contractIdAtOffset": null}
]
If every contractIdAtOffset is specified, as is so in the example above, you will not receive any archived events for contracts created before the offset unless those contracts are identified in a contractIdAtOffset. By contrast, if any contractIdAtOffset is missing, archived event filtering will be disabled, and you will receive ‚Äúphantom archives‚Äù as with query streams.

Healthcheck Endpoints
The HTTP JSON API provides two healthcheck endpoints for integration with schedulers like Kubernetes.

Liveness Check
URL: /livez
Method: GET
A status code of 200 indicates a successful liveness check.

This is an unauthenticated endpoint intended to be used as a liveness probe.

Readiness Check
URL: /readyz
Method: GET
A status code of 200 indicates a successful readiness check.

This is an unauthenticated endpoint intended to be used as a readiness probe. It validates both the ledger connection as well as the database connection.

Previous Next
Copyright (c) 2026 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved. Any unauthorized use, duplication or distribution is strictly prohibited. "Digital Asset" and "Daml" are Registered in the U.S. Patent and Trademark Office.
