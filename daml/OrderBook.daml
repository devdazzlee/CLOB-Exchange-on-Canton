module OrderBook where

import qualified Order
import Trade
import UserAccount
import qualified DA.Map as Map
import DA.Assert
import DA.Time
import DA.List
import DA.Text

-- Helper function to fetch orders with their contract IDs
fetchOrderPairs : [ContractId Order.Order] -> Update [(ContractId Order.Order, Order.Order)]
fetchOrderPairs cids = if null cids then
  return []
  else do
    let cid = head cids
    let rest = tail cids
    order <- fetch cid
    restPairs <- fetchOrderPairs rest
    let pair = (cid, order)
    return ([pair] ++ restPairs)

-- Helper function to compare buy orders (PRICE-TIME PRIORITY)
-- Priority: 1) Market orders first, 2) Highest price, 3) Earliest timestamp (FIFO)
compareBuyOrders : (ContractId Order.Order, Order.Order) -> (ContractId Order.Order, Order.Order) -> Ordering
compareBuyOrders (_, a) (_, b) = case (a.price, b.price) of
  (None, Some _) -> GT  -- Market orders have highest priority
  (Some _, None) -> LT
  (None, None) -> 
    -- Both market orders: earlier timestamp first (FIFO)
    if a.timestamp < b.timestamp then GT else if a.timestamp > b.timestamp then LT else EQ
  (Some pa, Some pb) -> 
    -- Both limit orders: higher price first, then earlier timestamp (FIFO)
    if pa > pb then GT 
    else if pa < pb then LT 
    else if a.timestamp < b.timestamp then GT  -- Same price: earlier timestamp first
    else if a.timestamp > b.timestamp then LT
    else EQ

-- Helper function to compare sell orders (PRICE-TIME PRIORITY)
-- Priority: 1) Market orders first, 2) Lowest price, 3) Earliest timestamp (FIFO)
compareSellOrders : (ContractId Order.Order, Order.Order) -> (ContractId Order.Order, Order.Order) -> Ordering
compareSellOrders (_, a) (_, b) = case (a.price, b.price) of
  (None, Some _) -> GT  -- Market orders have highest priority
  (Some _, None) -> LT
  (None, None) -> 
    -- Both market orders: earlier timestamp first (FIFO)
    if a.timestamp < b.timestamp then GT else if a.timestamp > b.timestamp then LT else EQ
  (Some pa, Some pb) -> 
    -- Both limit orders: lower price first, then earlier timestamp (FIFO)
    if pa < pb then GT 
    else if pa > pb then LT 
    else if a.timestamp < b.timestamp then GT  -- Same price: earlier timestamp first
    else if a.timestamp > b.timestamp then LT
    else EQ

-- Helper function to check if two orders can match
canOrdersMatch : Order.Order -> Order.Order -> Bool
canOrdersMatch buyOrder sellOrder = case buyOrder.price of
  Some buyPrice -> case sellOrder.price of
    Some sellPrice -> buyPrice >= sellPrice
    None -> True
  None -> True

-- Helper function to determine trade price
determineTradePrice : Order.Order -> Order.Order -> Decimal
determineTradePrice buyOrder sellOrder = case buyOrder.price of
  Some bp -> case sellOrder.price of
    Some sp -> (bp + sp) / 2.0
    None -> bp
  None -> case sellOrder.price of
    Some sp -> sp
    None -> 0.0

-- Helper function to parse trading pair (e.g., "BTC/USDT" -> ("BTC", "USDT"))
-- Manual implementation since splitOn may not be available
parseTradingPair : Text -> (Text, Text)
parseTradingPair pair = 
  -- For now, handle common cases manually
  -- In production, this should be more robust
  if pair == "BTC/USDT" then ("BTC", "USDT")
  else if pair == "ETH/USDT" then ("ETH", "USDT")
  else if pair == "SOL/USDT" then ("SOL", "USDT")
  else ("UNKNOWN", "UNKNOWN")  -- Fallback for other pairs

-- Helper function to match first compatible pair
-- Returns: lastTradePrice (most recent trade price, or None if no trades)
matchFirstPair : Text -> Optional (Map.Map Party (ContractId UserAccount.UserAccount)) -> [(ContractId Order.Order, Order.Order)] -> [(ContractId Order.Order, Order.Order)] -> Update (Optional Decimal)
matchFirstPair tradingPair userAccountsOpt buyList sellList = 
  if null buyList || null sellList then
    return None
  else do
    let (buyCid, buyOrder) = head buyList
    let buyRest : [(ContractId Order.Order, Order.Order)] = tail buyList
    let (sellCid, sellOrder) = head sellList
    let sellRest : [(ContractId Order.Order, Order.Order)] = tail sellList
    -- Check if orders can match
    let canMatch = canOrdersMatch buyOrder sellOrder
    
    if canMatch then do
      let buyRemaining = buyOrder.quantity - buyOrder.filled
      let sellRemaining = sellOrder.quantity - sellOrder.filled
      let tradeQuantity = min buyRemaining sellRemaining
      
      -- Determine trade price (use limit order price if available, otherwise market order)
      let tradePrice = determineTradePrice buyOrder sellOrder
      
      -- Parse trading pair to get base and quote tokens
      let (baseToken, quoteToken) = parseTradingPair tradingPair
      
      -- Update balances if UserAccount contracts exist
      -- Buyer: receives baseToken, pays quoteToken (tradeQuantity * tradePrice)
      -- Seller: receives quoteToken (tradeQuantity * tradePrice), pays baseToken
      buyerAccountCidOpt <- case userAccountsOpt of
        Some accounts -> case Map.lookup buyOrder.owner accounts of
            Some buyerCid -> do
              _ <- exercise buyerCid UserAccount.UpdateAfterTrade with
                baseToken = baseToken
                quoteToken = quoteToken
                baseAmount = tradeQuantity  -- Buyer receives base token
                quoteAmount = -(tradeQuantity * tradePrice)  -- Buyer pays quote token
              return (Some buyerCid)
            None -> return None
        None -> return None
      
      sellerAccountCidOpt <- case userAccountsOpt of
        Some accounts -> case Map.lookup sellOrder.owner accounts of
            Some sellerCid -> do
              _ <- exercise sellerCid UserAccount.UpdateAfterTrade with
                baseToken = baseToken
                quoteToken = quoteToken
                baseAmount = -tradeQuantity  -- Seller pays base token
                quoteAmount = tradeQuantity * tradePrice  -- Seller receives quote token
              return (Some sellerCid)
            None -> return None
        None -> return None
      
      -- Fill both orders
      _ <- exercise buyCid Order.FillOrder with fillQuantity = tradeQuantity
      _ <- exercise sellCid Order.FillOrder with fillQuantity = tradeQuantity
      
      -- Create trade record
      now <- getTime
      let tradeIdText = buyOrder.orderId <> "-" <> sellOrder.orderId <> "-" <> show now
      _ <- create Trade with
        tradeId = tradeIdText
        buyer = buyOrder.owner
        seller = sellOrder.owner
        tradingPair = tradingPair
        price = tradePrice
        quantity = tradeQuantity
        timestamp = now
        buyOrderId = buyOrder.orderId
        sellOrderId = sellOrder.orderId
      
      -- Fetch updated orders to check if they're filled
      updatedBuy <- fetch buyCid
      updatedSell <- fetch sellCid
      
      -- UTXO HANDLING: Merge UTXOs after partial fills to prevent fragmentation
      -- If orders are partially filled, merge remaining UTXOs for both parties
      let buyRemaining = updatedBuy.quantity - updatedBuy.filled
      let sellRemaining = updatedSell.quantity - updatedSell.filled
      
      -- Merge UTXOs for buyer if order is partially filled (remaining quantity > 0)
      _ <- if buyRemaining > 0.0 then
        case userAccountsOpt of
          Some accounts -> case Map.lookup buyOrder.owner accounts of
            Some buyerAccountCid -> do
              -- Merge quote token UTXOs (for BUY orders, quote token was partially used)
              _ <- exercise buyerAccountCid UserAccount.MergeBalances
              return ()
            None -> return ()
          None -> return ()
      else return ()
      
      -- Merge UTXOs for seller if order is partially filled (remaining quantity > 0)
      _ <- if sellRemaining > 0.0 then
        case userAccountsOpt of
          Some accounts -> case Map.lookup sellOrder.owner accounts of
            Some sellerAccountCid -> do
              -- Merge base token UTXOs (for SELL orders, base token was partially used)
              _ <- exercise sellerAccountCid UserAccount.MergeBalances
              return ()
            None -> return ()
          None -> return ()
      else return ()
      
      -- Continue matching if orders are still open
      let nextBuyPair = (buyCid, updatedBuy)
      let nextSellPair = (sellCid, updatedSell)
      let nextBuys = if updatedBuy.filled >= updatedBuy.quantity then buyRest else ([nextBuyPair] ++ buyRest)
      let nextSells = if updatedSell.filled >= updatedSell.quantity then sellRest else ([nextSellPair] ++ sellRest)
      
      nextPrice <- matchFirstPair tradingPair userAccountsOpt nextBuys nextSells
      -- Return the most recent trade price (this trade takes precedence over subsequent trades)
      return (Some tradePrice)
    else
      return None

-- Order book template for managing buy and sell orders for a trading pair
-- IMPORTANT: This is a GLOBAL order book - one per trading pair, shared by all users
-- All users interact with the same OrderBook for each trading pair
-- 
-- VISIBILITY MODEL: The OrderBook uses fetchByKey for discovery. Once a user places an order,
-- they become an observer (via the activeUsers list which grows with each order).
-- However, since DAML doesn't allow observer [Party] directly, we rely on:
-- 1. Backend provides OrderBook contract IDs to users (queried as operator)
-- 2. Users can exercise AddOrder using the contract ID (they become observers of new instances)
-- 3. Contract key ensures exactly one OrderBook per trading pair
template OrderBook
  with
    tradingPair : Text
    buyOrders : [ContractId Order.Order]
    sellOrders : [ContractId Order.Order]
    lastPrice : Optional Decimal
    operator : Party
    activeUsers : [Party]  -- Track all parties who have placed orders (for querying/filtering)
    userAccounts : Optional (Map.Map Party (ContractId UserAccount.UserAccount))  -- Map of party to UserAccount contract ID for balance updates
  where
    signatory operator
    -- Make OrderBook visible to all users who have placed orders
    -- DAML supports observer [Party] syntax - all parties in activeUsers become observers
    observer activeUsers
    
    -- NOTE: Contract keys are not supported in this DAML/Canton version
    -- Uniqueness of OrderBook per trading pair is enforced by:
    -- 1. Backend logic (operator creates only one OrderBook per pair)
    -- 2. Frontend queries for existing OrderBooks before creating new ones

    -- Add a new order to the order book
    -- IMPORTANT: Since controller is `owner`, the owner must be able to see this contract
    -- to exercise this choice. Users discover OrderBook via backend (operator query)
    -- or by using fetchByKey with the trading pair.
    choice AddOrder : ContractId Order.Order
      with
        orderId : Text
        owner : Party
        orderType : Text
        orderMode : Text
        price : Optional Decimal
        quantity : Decimal
      controller owner
      do
        now <- getTime
        orderCid <- create Order.Order with
            orderId = orderId
            owner = owner
            orderType = orderType
            orderMode = orderMode
            tradingPair = tradingPair
            price = price
            quantity = quantity
            filled = 0.0 : Decimal
            status = "OPEN"
            timestamp = now
            operator = operator
        
        let updatedBuyOrders = if orderType == "BUY" then buyOrders ++ [orderCid] else buyOrders
        let updatedSellOrders = if orderType == "SELL" then sellOrders ++ [orderCid] else sellOrders
        
        -- Add owner to activeUsers list if not already present
        -- This makes the OrderBook visible to the user (they become an observer via observer activeUsers clause)
        -- All users who place orders become observers and can see the global OrderBook
        let updatedActiveUsers = if owner `elem` activeUsers then activeUsers else activeUsers ++ [owner]
        
        currentAccounts <- case userAccounts of
          Some accounts -> return accounts
          None -> return (Map.empty : Map.Map Party (ContractId UserAccount.UserAccount))
        
        orderBookCid <- create this with
          buyOrders = updatedBuyOrders
          sellOrders = updatedSellOrders
          lastPrice = None  -- Initialize with None for new order books
          activeUsers = updatedActiveUsers
          userAccounts = Some currentAccounts  -- Preserve user accounts map
        
        -- UTXO HANDLING: Merge UTXOs before placing order to ensure sufficient balance
        -- This prevents UTXO fragmentation issues when placing orders
        -- Determine which token needs merging based on order type
        let (baseToken, quoteToken) = parseTradingPair tradingPair
        let tokenToMerge = if orderType == "BUY" then quoteToken else baseToken
        
        -- Merge UTXOs if UserAccount exists
        _ <- case userAccounts of
          Some accounts -> case Map.lookup owner accounts of
            Some userAccountCid -> do
            -- Exercise MergeBalances to consolidate UTXOs before order placement
            -- This ensures the user can use their full balance for the order
            _ <- exercise userAccountCid UserAccount.MergeBalances
            return ()
          None -> return ()  -- No UserAccount, skip UTXO merge
        
        -- Try to match orders immediately
        exercise orderBookCid MatchOrders
        
        return orderCid

    -- Match compatible buy and sell orders
    choice MatchOrders : ()
      controller operator
      do
        -- Get active buy and sell orders with their contract IDs
        buyOrderPairs <- fetchOrderPairs buyOrders
        sellOrderPairs <- fetchOrderPairs sellOrders
        
        -- Filter only open orders
        let activeBuys = filter (\(_, o) -> o.status == "OPEN") buyOrderPairs
        let activeSells = filter (\(_, o) -> o.status == "OPEN") sellOrderPairs
        
        -- Sort buy orders by price (highest first) and sell orders by price (lowest first)
        let sortedBuys = sortBy compareBuyOrders activeBuys
        let sortedSells = sortBy compareSellOrders activeSells
        
        -- Match orders - try to match first buy with first sell
        matchedPrice <- matchFirstPair tradingPair userAccounts sortedBuys sortedSells
        
        -- Update order book by fetching current status of all orders
        updatedBuyPairs <- fetchOrderPairs buyOrders
        updatedSellPairs <- fetchOrderPairs sellOrders
        
        -- Keep only open orders
        let remainingBuys = filter (\(_, o) -> o.status == "OPEN") updatedBuyPairs
        let remainingSells = filter (\(_, o) -> o.status == "OPEN") updatedSellPairs
        
        let remainingBuyCids = map (\(cid, _) -> cid) remainingBuys
        let remainingSellCids = map (\(cid, _) -> cid) remainingSells
        
        -- Update lastPrice if a trade occurred
        newLastPrice <- case matchedPrice of
            Some p -> return (Some p)
            None -> return lastPrice
        
        currentAccounts <- case userAccounts of
          Some accounts -> return accounts
          None -> return (Map.empty : Map.Map Party (ContractId UserAccount.UserAccount))
        
        _ <- create this with
          buyOrders = remainingBuyCids
          sellOrders = remainingSellCids
          lastPrice = newLastPrice
          activeUsers = activeUsers  -- Preserve active users (observers) so OrderBook remains visible
          userAccounts = Some currentAccounts  -- Preserve user accounts map
        return ()

    -- Remove a cancelled or filled order from the book
    choice RemoveOrder : ()
      with
        orderCid : ContractId Order.Order
      controller operator
      do
        order <- fetch orderCid
        assert (order.status == "FILLED" || order.status == "CANCELLED")
        
        let updatedBuyOrders = filter (\cid -> cid /= orderCid) buyOrders
        let updatedSellOrders = filter (\cid -> cid /= orderCid) sellOrders
        
        currentAccounts <- case userAccounts of
          Some accounts -> return accounts
          None -> return (Map.empty : Map.Map Party (ContractId UserAccount.UserAccount))
        
        _ <- create this with
          buyOrders = updatedBuyOrders
          sellOrders = updatedSellOrders
          activeUsers = activeUsers  -- Preserve active users (observers) so OrderBook remains visible
          userAccounts = Some currentAccounts  -- Preserve user accounts map
        return ()

    -- Cancel an order (called by order owner)
    -- This choice allows users to cancel their own orders and removes them from the OrderBook
    -- UTXO HANDLING: After cancellation, triggers UTXO merge for the user account
    choice CancelOrderFromBook : ()
      with
        orderCid : ContractId Order.Order
        orderOwner : Party  -- The owner of the order (must match order.owner)
      controller orderOwner
      do
        order <- fetch orderCid
        assert (order.owner == orderOwner)  -- Only owner can cancel
        assert (order.status == "OPEN")  -- Only open orders can be cancelled
        
        -- Cancel the order
        _ <- exercise orderCid Order.CancelOrder
        
        -- UTXO HANDLING: Merge UTXOs after cancellation
        -- Determine which token needs merging based on order type
        let (baseToken, quoteToken) = parseTradingPair tradingPair
        let tokenToMerge = if order.orderType == "BUY" then quoteToken else baseToken
        
        -- Trigger UTXO merge if UserAccount exists
        _ <- case userAccounts of
          Some accounts -> case Map.lookup orderOwner accounts of
            Some userAccountCid -> do
            -- Exercise MergeBalances to consolidate UTXOs
            -- This helps prevent UTXO fragmentation after order cancellation
            _ <- exercise userAccountCid UserAccount.MergeBalances
            return ()
          None -> return ()  -- No UserAccount, skip UTXO merge
          None -> return ()  -- No userAccounts map, skip UTXO merge
        
        -- Remove from OrderBook
        let updatedBuyOrders = filter (\cid -> cid /= orderCid) buyOrders
        let updatedSellOrders = filter (\cid -> cid /= orderCid) sellOrders
        
        currentAccounts <- case userAccounts of
          Some accounts -> return accounts
          None -> return (Map.empty : Map.Map Party (ContractId UserAccount.UserAccount))
        
        _ <- create this with
          buyOrders = updatedBuyOrders
          sellOrders = updatedSellOrders
          activeUsers = activeUsers
          userAccounts = Some currentAccounts  -- Preserve user accounts map
        return ()

    -- Update userAccounts map (add a new UserAccount contract ID)
    -- This allows the matching engine to update balances after trades
    choice UpdateUserAccount : ()
      with
        party : Party
        userAccountCid : ContractId UserAccount.UserAccount
      controller operator
      do
        -- Add or update the user account in the map
        currentAccounts <- case userAccounts of
          Some accounts -> return accounts
          None -> return (Map.empty : Map.Map Party (ContractId UserAccount.UserAccount))
        let updatedUserAccounts = Map.insert party userAccountCid currentAccounts
        _ <- create this with userAccounts = Some updatedUserAccounts
        return ()
