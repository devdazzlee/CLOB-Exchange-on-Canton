module OrderBook where

import Order
import UserAccount
import Trade
import DA.Assert
import DA.Time
import DA.List

-- Helper function to fetch orders with their contract IDs
fetchOrderPairs : [ContractId Order] -> Update [(ContractId Order, Order)]
fetchOrderPairs cids = if null cids then
  return []
  else do
    let cid = head cids
    let rest = tail cids
    order <- fetch cid
    restPairs <- fetchOrderPairs rest
    let pair = (cid, order)
    return ([pair] ++ restPairs)

-- Helper function to compare buy orders (highest price first)
compareBuyOrders : (ContractId Order, Order) -> (ContractId Order, Order) -> Ordering
compareBuyOrders (_, a) (_, b) = case (a.price, b.price) of
  (Some pa, Some pb) -> if pa > pb then GT else if pa < pb then LT else EQ
  (None, Some _) -> GT  -- Market orders have priority
  (Some _, None) -> LT
  (None, None) -> EQ

-- Helper function to compare sell orders (lowest price first)
compareSellOrders : (ContractId Order, Order) -> (ContractId Order, Order) -> Ordering
compareSellOrders (_, a) (_, b) = case a.price of
  Some pa -> case b.price of
    Some pb -> if pa < pb then GT else if pa > pb then LT else EQ
    None -> LT
  None -> case b.price of
    Some _ -> GT
    None -> EQ

-- Helper function to check if two orders can match
canOrdersMatch : Order -> Order -> Bool
canOrdersMatch buyOrder sellOrder = case buyOrder.price of
  Some buyPrice -> case sellOrder.price of
    Some sellPrice -> buyPrice >= sellPrice
    None -> True
  None -> True

-- Helper function to determine trade price
determineTradePrice : Order -> Order -> Decimal
determineTradePrice buyOrder sellOrder = case buyOrder.price of
  Some bp -> case sellOrder.price of
    Some sp -> (bp + sp) / 2.0
    None -> bp
  None -> case sellOrder.price of
    Some sp -> sp
    None -> 0.0

-- Helper function to match first compatible pair
-- Returns: lastTradePrice (most recent trade price, or None if no trades)
matchFirstPair : Text -> [(ContractId Order, Order)] -> [(ContractId Order, Order)] -> Update (Optional Decimal)
matchFirstPair tradingPair buyList sellList = 
  if null buyList || null sellList then
    return None
  else do
    let (buyCid, buyOrder) = head buyList
    let buyRest : [(ContractId Order, Order)] = tail buyList
    let (sellCid, sellOrder) = head sellList
    let sellRest : [(ContractId Order, Order)] = tail sellList
    -- Check if orders can match
    let canMatch = canOrdersMatch buyOrder sellOrder
    
    if canMatch then do
      let buyRemaining = buyOrder.quantity - buyOrder.filled
      let sellRemaining = sellOrder.quantity - sellOrder.filled
      let tradeQuantity = min buyRemaining sellRemaining
      
      -- Determine trade price (use limit order price if available, otherwise market order)
      let tradePrice = determineTradePrice buyOrder sellOrder
      
      -- Fill both orders
      _ <- exercise buyCid FillOrder with fillQuantity = tradeQuantity
      _ <- exercise sellCid FillOrder with fillQuantity = tradeQuantity
      
      -- Create trade record
      now <- getTime
      let tradeIdText = buyOrder.orderId <> "-" <> sellOrder.orderId <> "-" <> show now
      _ <- create Trade with
        tradeId = tradeIdText
        buyer = buyOrder.owner
        seller = sellOrder.owner
        tradingPair = tradingPair
        price = tradePrice
        quantity = tradeQuantity
        timestamp = now
        buyOrderId = buyOrder.orderId
        sellOrderId = sellOrder.orderId
      
      -- Fetch updated orders to check if they're filled
      updatedBuy <- fetch buyCid
      updatedSell <- fetch sellCid
      
      -- Continue matching if orders are still open
      let nextBuyPair = (buyCid, updatedBuy)
      let nextSellPair = (sellCid, updatedSell)
      let nextBuys = if updatedBuy.filled >= updatedBuy.quantity then buyRest else ([nextBuyPair] ++ buyRest)
      let nextSells = if updatedSell.filled >= updatedSell.quantity then sellRest else ([nextSellPair] ++ sellRest)
      
      nextPrice <- matchFirstPair tradingPair nextBuys nextSells
      -- Return the most recent trade price (this trade takes precedence over subsequent trades)
      return (Some tradePrice)
    else
      return None

-- Order book template for managing buy and sell orders for a trading pair
template OrderBook
  with
    tradingPair : Text
    buyOrders : [ContractId Order]
    sellOrders : [ContractId Order]
    lastPrice : Optional Decimal
    operator : Party
  where
    signatory operator

    -- Add a new order to the order book
    choice AddOrder : ContractId Order
      with
        orderId : Text
        owner : Party
        orderType : Text
        orderMode : Text
        price : Optional Decimal
        quantity : Decimal
      controller owner
      do
        now <- getTime
        orderCid <- create Order with
            orderId = orderId
            owner = owner
            orderType = orderType
            orderMode = orderMode
            tradingPair = tradingPair
            price = price
            quantity = quantity
            filled = 0.0 : Decimal
            status = "OPEN"
            timestamp = now
            operator = operator
        
        let updatedBuyOrders = if orderType == "BUY" then buyOrders ++ [orderCid] else buyOrders
        let updatedSellOrders = if orderType == "SELL" then sellOrders ++ [orderCid] else sellOrders
        
        orderBookCid <- create this with
          buyOrders = updatedBuyOrders
          sellOrders = updatedSellOrders
          lastPrice = None  -- Initialize with None for new order books
        
        -- Try to match orders immediately
        exercise orderBookCid MatchOrders
        
        return orderCid

    -- Match compatible buy and sell orders
    choice MatchOrders : ()
      controller operator
      do
        -- Get active buy and sell orders with their contract IDs
        buyOrderPairs <- fetchOrderPairs buyOrders
        sellOrderPairs <- fetchOrderPairs sellOrders
        
        -- Filter only open orders
        let activeBuys = filter (\(_, o) -> o.status == "OPEN") buyOrderPairs
        let activeSells = filter (\(_, o) -> o.status == "OPEN") sellOrderPairs
        
        -- Sort buy orders by price (highest first) and sell orders by price (lowest first)
        let sortedBuys = sortBy compareBuyOrders activeBuys
        let sortedSells = sortBy compareSellOrders activeSells
        
        -- Match orders - try to match first buy with first sell
        matchedPrice <- matchFirstPair tradingPair sortedBuys sortedSells
        
        -- Update order book by fetching current status of all orders
        updatedBuyPairs <- fetchOrderPairs buyOrders
        updatedSellPairs <- fetchOrderPairs sellOrders
        
        -- Keep only open orders
        let remainingBuys = filter (\(_, o) -> o.status == "OPEN") updatedBuyPairs
        let remainingSells = filter (\(_, o) -> o.status == "OPEN") updatedSellPairs
        
        let remainingBuyCids = map (\(cid, _) -> cid) remainingBuys
        let remainingSellCids = map (\(cid, _) -> cid) remainingSells
        
        -- Update lastPrice if a trade occurred
        newLastPrice <- case matchedPrice of
            Some p -> return (Some p)
            None -> return lastPrice
        
        _ <- create this with
          buyOrders = remainingBuyCids
          sellOrders = remainingSellCids
          lastPrice = newLastPrice
        return ()

    -- Remove a cancelled or filled order from the book
    choice RemoveOrder : ()
      with
        orderCid : ContractId Order
      controller operator
      do
        order <- fetch orderCid
        assert (order.status == "FILLED" || order.status == "CANCELLED")
        
        let updatedBuyOrders = filter (\cid -> cid /= orderCid) buyOrders
        let updatedSellOrders = filter (\cid -> cid /= orderCid) sellOrders
        
        _ <- create this with
          buyOrders = updatedBuyOrders
          sellOrders = updatedSellOrders
        return ()
