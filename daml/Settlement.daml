-- | Settlement.daml - Delivery vs Payment (DvP) atomic settlement
--
-- This enables atomic swaps: buyer gets tokens, seller gets payment,
-- or the entire transaction rolls back. No partial state.
--
-- Flow:
--   1. Matching engine finds crossing orders
--   2. Creates SettlementInstruction with both locked Holdings
--   3. Operator executes settlement atomically
--   4. Holdings are transferred, Trade contract created
--
-- AllocationRecord:
--   Fallback for when the Splice Allocation Factory API is unavailable.
--   Tracks locked funds on the CLOB exchange's own Canton contracts.
--   Primary path uses the SDK's Allocation Factory; this is the direct fallback.
--
module Settlement where

import Instrument (InstrumentId)
import Holding
import DA.Action (when)

-- | Settlement status
data SettlementStatus 
  = SettlementPending
  | SettlementExecuted
  | SettlementFailed Text
  | SettlementCancelled
  deriving (Eq, Show)

-- | Allocation status for AllocationRecord
data AllocationStatus
  = AllocationPending     -- Funds locked, awaiting match
  | AllocationExecuted    -- Match found, funds transferred
  | AllocationCancelled   -- Order cancelled, funds returned
  deriving (Eq, Show)

-- | Settlement leg - one side of the trade
data SettlementLeg = SettlementLeg
  with
    party : Party
    instrumentId : InstrumentId
    amount : Decimal
    holdingCid : ContractId Holding
  deriving (Eq, Show)

-- | SettlementInstruction - Pending atomic settlement
--
-- Created by matching engine when orders cross.
-- Holds references to both parties' locked holdings.
template SettlementInstruction
  with
    operator : Party
    buyer : Party
    seller : Party
    baseInstrumentId : InstrumentId     -- What's being bought (e.g., cBTC)
    quoteInstrumentId : InstrumentId    -- What's being paid (e.g., USDT)
    baseAmount : Decimal                 -- Amount of base (e.g., 0.5 BTC)
    quoteAmount : Decimal                -- Amount of quote (e.g., 25,000 USDT)
    price : Decimal                      -- Trade price
    buyerHoldingCid : ContractId Holding  -- Buyer's locked USDT
    sellerHoldingCid : ContractId Holding -- Seller's locked BTC
    buyOrderId : Text
    sellOrderId : Text
    timestamp : Time
    status : SettlementStatus
  where
    signatory operator
    observer buyer, seller

    -- Execute the settlement atomically
    choice Settlement_Execute : (ContractId Holding, ContractId Holding, ContractId Trade)
      controller operator
      do
        -- Fetch both holdings to verify they exist and are locked
        buyerHolding <- fetch buyerHoldingCid
        sellerHolding <- fetch sellerHoldingCid
        
        -- Verify holdings are properly locked
        assertMsg "Buyer holding not locked" (buyerHolding.lock /= None)
        assertMsg "Seller holding not locked" (sellerHolding.lock /= None)
        
        -- Verify amounts match
        assertMsg "Buyer holding insufficient" (buyerHolding.amount >= quoteAmount)
        assertMsg "Seller holding insufficient" (sellerHolding.amount >= baseAmount)
        
        -- Execute atomic swap:
        -- 1. Transfer base (e.g., BTC) from seller to buyer
        -- 2. Transfer quote (e.g., USDT) from buyer to seller
        
        -- Archive old holdings
        archive buyerHoldingCid
        archive sellerHoldingCid
        
        -- Create new holdings for buyer (receives base token)
        buyerNewHolding <- create Holding with
          owner = buyer
          instrumentId = baseInstrumentId
          amount = baseAmount
          lock = None
          custodian = operator
        
        -- Create new holdings for seller (receives quote token)
        sellerNewHolding <- create Holding with
          owner = seller
          instrumentId = quoteInstrumentId
          amount = quoteAmount
          lock = None
          custodian = operator
        
        -- Handle any remainder (partial fills)
        -- If buyer had more locked than needed, return change
        when (buyerHolding.amount > quoteAmount) do
          _ <- create Holding with
            owner = buyer
            instrumentId = quoteInstrumentId
            amount = buyerHolding.amount - quoteAmount
            lock = None
            custodian = operator
          return ()
        
        -- If seller had more locked than needed, return change
        when (sellerHolding.amount > baseAmount) do
          _ <- create Holding with
            owner = seller
            instrumentId = baseInstrumentId
            amount = sellerHolding.amount - baseAmount
            lock = None
            custodian = operator
          return ()
        
        -- Create trade record
        trade <- create Trade with
          tradeId = buyOrderId <> "-" <> sellOrderId <> "-" <> show timestamp
          operator = operator
          buyer = buyer
          seller = seller
          baseInstrumentId = baseInstrumentId
          quoteInstrumentId = quoteInstrumentId
          baseAmount = baseAmount
          quoteAmount = quoteAmount
          price = price
          buyOrderId = buyOrderId
          sellOrderId = sellOrderId
          timestamp = timestamp
        
        return (buyerNewHolding, sellerNewHolding, trade)

    -- Cancel settlement (returns locked funds)
    choice Settlement_Cancel : ()
      with
        reason : Text
      controller operator
      do
        -- Unlock both holdings
        buyerHolding <- fetch buyerHoldingCid
        sellerHolding <- fetch sellerHoldingCid
        
        archive buyerHoldingCid
        archive sellerHoldingCid
        
        -- Return unlocked holdings
        _ <- create buyerHolding with lock = None
        _ <- create sellerHolding with lock = None
        
        return ()

-- | Trade - Record of an executed trade
-- 
-- ACS Optimization: Trade contracts remain active for history queries.
-- The operator can archive old trades via ArchiveTrade to keep the
-- Active Contract Set lean. Archived trades should first be persisted
-- to the file-backed cache (cantonUpdateStream.js) before archival.
template Trade
  with
    tradeId : Text
    operator : Party
    buyer : Party
    seller : Party
    baseInstrumentId : InstrumentId
    quoteInstrumentId : InstrumentId
    baseAmount : Decimal
    quoteAmount : Decimal
    price : Decimal
    buyOrderId : Text
    sellOrderId : Text
    timestamp : Time
  where
    signatory operator
    observer buyer, seller

    -- Archive this trade record to free ACS space.
    -- Call ONLY after the trade has been persisted to off-ledger storage
    -- (file cache, database, etc.) to avoid data loss.
    choice ArchiveTrade : ()
      controller operator
      do return ()

-- | Batch settlement for multiple trades
template BatchSettlement
  with
    operator : Party
    settlements : [ContractId SettlementInstruction]
    timestamp : Time
  where
    signatory operator

    -- Execute all settlements atomically
    choice BatchSettlement_Execute : [ContractId Trade]
      controller operator
      do
        -- Execute each settlement
        results <- forA settlements \settlementCid -> do
          (_, _, tradeCid) <- exercise settlementCid Settlement_Execute
          return tradeCid
        return results

-- =============================================================================
-- ALLOCATION RECORD — Fallback for when Splice Allocation Factory is unavailable
-- =============================================================================

-- | AllocationRecord — tracks locked funds for an exchange order.
--
-- Created by the backend (via canton-sdk-client.js _createDirectAllocation)
-- when the Splice Allocation Factory API is unavailable.
--
-- Primary path: SDK's Allocation Factory API (creates native Splice Allocations)
-- Fallback path: This template (creates AllocationRecord on the exchange's own contracts)
--
-- Flow:
--   1. ORDER PLACEMENT: Backend creates AllocationRecord (funds conceptually locked)
--   2. MATCH TIME:      Exchange exercises ExecuteAllocation (no user key needed)
--   3. CANCELLATION:    Backend exercises CancelAllocation (funds returned)
--
-- Fields match what canton-sdk-client.js sends in _createDirectAllocation:
--   allocationId, orderId, sender, receiver, executor, amount, instrument,
--   holdingCids, status, createdAt, operator
--
template AllocationRecord
  with
    allocationId : Text       -- Unique allocation ID (e.g., "alloc-order-123")
    orderId : Text            -- The exchange order ID this allocation belongs to
    sender : Party            -- The order placer (funds locked from this party)
    receiver : Text           -- The counterparty (empty string if unknown at order time)
    executor : Party          -- The exchange party (settles at match time with its own key)
    amount : Text             -- Amount allocated (Decimal as string)
    instrument : Text         -- Token symbol (e.g., "CC", "CBTC", "USDT")
    holdingCids : [Text]      -- References to the holding UTXOs backing this allocation
    status : Text             -- "PENDING", "EXECUTED", "CANCELLED"
    createdAt : Text          -- ISO timestamp of creation
    operator : Party          -- Exchange operator (same as executor in most cases)
  where
    signatory operator
    observer sender, executor

    -- Execute the allocation — transfer funds from sender to receiver.
    -- Called by the exchange (executor) at MATCH TIME.
    -- NO user key needed — the exchange acts as executor.
    choice ExecuteAllocation : ContractId AllocationRecord
      controller executor
      do
        assertMsg "Allocation not in PENDING status" (status == "PENDING")
        create this with status = "EXECUTED"

    -- Cancel the allocation — release locked funds back to sender.
    -- Called when an order is cancelled. Either sender or executor can cancel.
    choice CancelAllocation : ContractId AllocationRecord
      controller executor
      do
        assertMsg "Allocation not in PENDING status" (status == "PENDING")
        create this with status = "CANCELLED"

    -- Sender can also cancel their own allocation (e.g., user cancels order)
    choice SenderCancelAllocation : ContractId AllocationRecord
      controller sender
      do
        assertMsg "Allocation not in PENDING status" (status == "PENDING")
        create this with status = "CANCELLED"

    -- Archive a completed allocation to free ACS space.
    -- Only EXECUTED or CANCELLED allocations can be archived.
    choice ArchiveAllocation : ()
      controller operator
      do
        assertMsg "Can only archive completed allocations" (status == "EXECUTED" || status == "CANCELLED")
