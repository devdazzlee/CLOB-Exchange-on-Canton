/**
 * Order Service ‚Äî Canton JSON Ledger API v2 + Allocation-Based Settlement
 * 
 * Uses the correct Canton APIs:
 * - POST /v2/commands/submit-and-wait-for-transaction ‚Äî Place/Cancel orders
 * - POST /v2/state/active-contracts ‚Äî Query orders
 * 
 * Balance checks use the Canton Wallet SDK (listHoldingUtxos).
 * 
 * Settlement is Allocation-based:
 * - At ORDER PLACEMENT: creates an Allocation (exchange = executor, funds locked)
 * - At MATCH TIME: exchange executes Allocation with its OWN key (no user key needed)
 * - At CANCEL: Allocation_Cancel releases locked funds back to sender
 * 
 * Why Allocations (not TransferInstruction):
 * - TransferInstruction requires user's private key at SETTLEMENT time
 * - With external parties, backend has no user keys ‚Üí TransferInstruction breaks
 * - Allocation: User signs ONCE at order time, exchange settles with its own key
 * 
 * @see https://docs.sync.global/app_dev/api/splice-api-token-allocation-v1/
 * @see https://docs.digitalasset.com/integrate/devnet/token-standard/index.html
 */

const Decimal = require('decimal.js');
const config = require('../config');
const cantonService = require('./cantonService');
const tokenProvider = require('./tokenProvider');
const { ValidationError, NotFoundError } = require('../utils/errors');
const { v4: uuidv4 } = require('uuid');
const { getReadModelService } = require('./readModelService');
const { getCantonSDKClient } = require('./canton-sdk-client');

// Configure Decimal for financial precision
Decimal.set({ precision: 20, rounding: Decimal.ROUND_DOWN });

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// BALANCE RESERVATION TRACKER
// Prevents overselling by tracking how much balance is "spoken for" by
// open orders that haven't settled yet. The Canton SDK's soft balance check
// only sees the on-chain available balance ‚Äî it doesn't know about pending
// orders in the order book that will require those funds at settlement time.
//
// Key: "partyId::asset" ‚Üí total reserved amount (Decimal)
// Updated on: order placement (+), cancellation (-), settlement fill (-)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const _reservations = new Map();    // "partyId::asset" ‚Üí Decimal amount
const _orderReservations = new Map(); // "orderId" ‚Üí { partyId, asset, amount, allocationContractId }

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// GLOBAL OPEN ORDER REGISTRY
// 
// Canton's party-based access control means the operator may NOT see orders
// created through other backend instances (e.g. Vercel) if those instances
// used a different operator party or a code path that didn't include the
// operator as a stakeholder.
//
// This registry is populated when user-specific order queries return OPEN
// orders. The OrderBookService merges these into the global order book view.
//
// Key: contractId ‚Üí { orderId, owner, tradingPair, orderType, price, quantity, filled, status, timestamp }
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const _globalOpenOrders = new Map();

function registerOpenOrders(orders) {
  if (!Array.isArray(orders)) return;
  // Collect current contractIds for this batch to detect stale entries
  for (const order of orders) {
    if (order.status === 'OPEN' && order.contractId) {
      _globalOpenOrders.set(order.contractId, {
        contractId: order.contractId,
        orderId: order.orderId,
        owner: order.owner,
        tradingPair: order.tradingPair,
        orderType: order.orderType,
        orderMode: order.orderMode,
        price: order.price,
        quantity: order.quantity,
        filled: order.filled || '0',
        remaining: parseFloat(order.quantity || 0) - parseFloat(order.filled || 0),
        status: 'OPEN',
        timestamp: order.timestamp,
      });
    }
  }
  // Remove orders that are no longer OPEN (their status changed to FILLED/CANCELLED)
  for (const order of orders) {
    if (order.status !== 'OPEN' && order.contractId && _globalOpenOrders.has(order.contractId)) {
      _globalOpenOrders.delete(order.contractId);
    }
  }
}

function getGlobalOpenOrders() {
  return [..._globalOpenOrders.values()];
}

function _reservationKey(partyId, asset) {
  return `${partyId}::${asset}`;
}

function getReservedBalance(partyId, asset) {
  const key = _reservationKey(partyId, asset);
  return _reservations.get(key) || new Decimal(0);
}

function addReservation(orderId, partyId, asset, amount, allocationContractId = null) {
  const key = _reservationKey(partyId, asset);
  const current = _reservations.get(key) || new Decimal(0);
  _reservations.set(key, current.plus(new Decimal(amount)));
  _orderReservations.set(orderId, {
    partyId,
    asset,
    amount: new Decimal(amount).toString(),
    allocationContractId,
  });
  console.log(`[BalanceReservation] ‚ûï Reserved ${amount} ${asset} for ${orderId} (total reserved: ${_reservations.get(key).toString()}, allocation: ${allocationContractId ? allocationContractId.substring(0, 30) + '...' : 'none'})`);
}

function releaseReservation(orderId) {
  const reservation = _orderReservations.get(orderId);
  if (!reservation) return;

  const key = _reservationKey(reservation.partyId, reservation.asset);
  const current = _reservations.get(key) || new Decimal(0);
  const newAmount = Decimal.max(current.minus(new Decimal(reservation.amount)), new Decimal(0));
  _reservations.set(key, newAmount);
  _orderReservations.delete(orderId);
  console.log(`[BalanceReservation] ‚ûñ Released ${reservation.amount} ${reservation.asset} for ${orderId} (total reserved: ${newAmount.toString()})`);
}

function releasePartialReservation(orderId, filledAmount) {
  const reservation = _orderReservations.get(orderId);
  if (!reservation) return;

  const key = _reservationKey(reservation.partyId, reservation.asset);
  const current = _reservations.get(key) || new Decimal(0);
  const releaseAmt = Decimal.min(new Decimal(filledAmount), new Decimal(reservation.amount));
  const newReserved = Decimal.max(current.minus(releaseAmt), new Decimal(0));
  _reservations.set(key, newReserved);

  // Update the order's remaining reservation
  const remaining = Decimal.max(new Decimal(reservation.amount).minus(releaseAmt), new Decimal(0));
  if (remaining.lte(0)) {
    _orderReservations.delete(orderId);
  } else {
    reservation.amount = remaining.toString();
  }
  console.log(`[BalanceReservation] ‚ûñ Partially released ${filledAmount} ${reservation.asset} for ${orderId} (remaining reservation: ${remaining.toString()})`);
}

/**
 * Get the allocation contract ID stored for an order's reservation.
 */
function getAllocationContractIdForOrder(orderId) {
  const reservation = _orderReservations.get(orderId);
  return reservation?.allocationContractId || null;
}

function setAllocationContractIdForOrder(orderId, allocationContractId) {
  const reservation = _orderReservations.get(orderId);
  if (!reservation) return;
  reservation.allocationContractId = allocationContractId || null;
}

class OrderService {
  constructor() {
    console.log('[OrderService] Initialized with Canton JSON API v2 + Allocation-based settlement');
  }

  _templateIdToString(templateId) {
    if (typeof templateId === 'string') return templateId;
    if (templateId && typeof templateId === 'object' && templateId.packageId && templateId.moduleName && templateId.entityName) {
      return `${templateId.packageId}:${templateId.moduleName}:${templateId.entityName}`;
    }
    return '';
  }

  _extractAllocationCidFromExecuteResult(result) {
    const isCidLike = (value) => typeof value === 'string' && value.length > 20;
    const visited = new Set();
    const stack = [result];

    while (stack.length > 0) {
      const current = stack.pop();
      if (!current || typeof current !== 'object') continue;
      if (visited.has(current)) continue;
      visited.add(current);

      if (isCidLike(current.allocationCid)) return current.allocationCid;
      if (isCidLike(current.allocationContractId)) return current.allocationContractId;

      if (Array.isArray(current)) {
        for (const item of current) stack.push(item);
      } else {
        for (const key of Object.keys(current)) {
          stack.push(current[key]);
        }
      }
    }
    return null;
  }

  _extractOrderRefFromAllocationPayload(payload) {
    if (!payload || typeof payload !== 'object') return null;
    return (
      payload?.settlement?.settlementRef?.id ||
      payload?.allocation?.settlement?.settlementRef?.id ||
      payload?.settlementRef?.id ||
      payload?.allocation?.settlementRef?.id ||
      payload?.transferLegId ||
      payload?.allocation?.transferLegId ||
      payload?.output?.allocation?.settlement?.settlementRef?.id ||
      payload?.output?.allocation?.transferLegId ||
      null
    );
  }

  async _findAllocationCidForOrder(orderId, partyId, token) {
    if (!orderId) return null;
    const operatorPartyId = config.canton.operatorPartyId;
    const parties = [...new Set([partyId, operatorPartyId].filter(Boolean))];

    // 1) First attempt: use SDK pending-allocation view (narrow, deterministic, and fast).
    try {
      const sdkClient = getCantonSDKClient();
      if (sdkClient?.isReady?.()) {
        for (const party of parties) {
          const pending = await sdkClient.fetchPendingAllocations(party);
          for (const row of Array.isArray(pending) ? pending : []) {
            const contractId = row?.contractId || row?.activeContract?.createdEvent?.contractId || null;
            const payload =
              row?.activeContract?.createdEvent?.createArgument ||
              row?.payload ||
              row?.createArgument ||
              {};
            const ref = this._extractOrderRefFromAllocationPayload(payload);
            if (ref === orderId && contractId) {
              console.log(`[OrderService] ‚úÖ Found allocation via SDK pending view for ${orderId}: ${contractId.substring(0, 30)}...`);
              return contractId;
            }
          }
        }
      }
    } catch (sdkErr) {
      console.warn(`[OrderService] SDK pending-allocation lookup failed: ${sdkErr.message}`);
    }

    // 2) Fallback: raw ACS query. Retry briefly for eventual-consistency lag after execute.
    const attempts = 4;
    for (let attempt = 1; attempt <= attempts; attempt++) {
    for (const party of parties) {
      try {
        const contracts = await cantonService.queryActiveContracts({
          party,
          templateIds: [],
          verbose: true,
        }, token);

        for (const contract of Array.isArray(contracts) ? contracts : []) {
          const templateId = this._templateIdToString(contract.templateId || contract.identifier);
          if (!templateId.includes('Allocation')) continue;

          const payload = contract.payload || contract.createArgument || {};
          const settlementRefId = this._extractOrderRefFromAllocationPayload(payload);

          if (settlementRefId === orderId && contract.contractId) {
            console.log(`[OrderService] ‚úÖ Found allocation for order ${orderId}: ${contract.contractId.substring(0, 30)}...`);
            return contract.contractId;
          }

          // Defensive fallback: token-standard payloads can vary across package versions.
          // If the payload references the orderId anywhere, treat this as the matching allocation.
          if (contract.contractId && JSON.stringify(payload).includes(orderId)) {
            console.log(`[OrderService] ‚úÖ Found allocation via payload scan for order ${orderId}: ${contract.contractId.substring(0, 30)}...`);
            return contract.contractId;
          }
        }
      } catch (err) {
        console.warn(`[OrderService] Allocation lookup failed for party ${party.substring(0, 20)}...: ${err.message}`);
      }
    }
      if (attempt < attempts) {
        await new Promise((resolve) => setTimeout(resolve, 500));
      }
    }

    return null;
  }

  /**
   * Calculate amount to lock for an order (uses Decimal for precision).
   * BUY order: lock quote currency (e.g., CBTC for CC/CBTC pair)
   * SELL order: lock base currency (e.g., CC for CC/CBTC pair)
   * 
   * For MARKET orders, use estimatedPrice (from order book) 
   * with a 5% slippage buffer to ensure sufficient funds.
   */
  calculateLockAmount(tradingPair, orderType, price, quantity, orderMode = 'LIMIT', estimatedPrice = null) {
    const [baseAsset, quoteAsset] = tradingPair.split('/');
    const qty = new Decimal(quantity);

    if (orderType.toUpperCase() === 'BUY') {
      let prc;
      if (orderMode.toUpperCase() === 'MARKET') {
        prc = new Decimal(estimatedPrice || '0').times('1.05'); // 5% slippage buffer
      } else {
        prc = new Decimal(price || '0');
      }
      
      return {
        asset: quoteAsset,
        amount: prc.times(qty).toNumber()
      };
    } else {
      return {
        asset: baseAsset,
        amount: qty.toNumber()
      };
    }
  }

  /**
   * Check available balance via Canton Wallet SDK before order placement.
   * 
   * @returns {Object} { verified: true, availableBalance, asset }
   */
  async checkBalanceForOrder(token, partyId, operatorPartyId, asset, amount, orderId) {
    console.log(`[OrderService] SDK: Checking ${amount} ${asset} balance for order ${orderId}`);
    
    const sdkClient = getCantonSDKClient();
    
    if (!sdkClient.isReady()) {
      console.warn(`[OrderService] ‚ö†Ô∏è Canton SDK not ready ‚Äî skipping balance check (order will proceed)`);
      return { verified: false, availableBalance: 0, asset };
    }

    try {
      const balance = await sdkClient.getBalance(partyId, asset);
      const availableBalance = parseFloat(balance.available || '0');

      // Deduct balance already reserved by other open orders (prevents overselling)
      const reserved = getReservedBalance(partyId, asset);
      const effectiveAvailable = new Decimal(availableBalance).minus(reserved);
      
      if (effectiveAvailable.lt(new Decimal(amount))) {
        throw new ValidationError(
          `Insufficient ${asset} balance. On-chain available: ${availableBalance}, ` +
          `Reserved by open orders: ${reserved.toString()}, ` +
          `Effective available: ${effectiveAvailable.toString()}, ` +
          `Required: ${amount}`
        );
      }
      console.log(`[OrderService] ‚úÖ Balance check passed: ${availableBalance} ${asset} on-chain, ${reserved.toString()} reserved, ${effectiveAvailable.toString()} effective (need ${amount})`);
      
      return {
        verified: true,
        availableBalance: effectiveAvailable.toNumber(),
        asset,
      };
    } catch (err) {
      if (err instanceof ValidationError) throw err;
      console.warn(`[OrderService] ‚ö†Ô∏è Balance check failed (proceeding anyway): ${err.message}`);
      return { verified: false, availableBalance: 0, asset };
    }
  }

  /**
   * Cancel the Allocation associated with an order being cancelled.
   * 
   * With Allocation-based settlement, each order has an Allocation contract
   * that locks the user's holdings. Cancelling the Allocation releases
   * the locked funds back to the user.
   * 
   * @param {string} orderId - Order ID (for looking up the allocation)
   * @param {string} allocationContractId - The Allocation contract ID (from order creation)
   * @param {string} partyId - The order owner (sender in the allocation)
   */
  async cancelAllocationForOrder(orderId, allocationContractId, partyId) {
    console.log(`[OrderService] üîì Cancelling Allocation for order ${orderId}`);

    // Find the allocationContractId from the reservation if not provided
    if (!allocationContractId) {
      allocationContractId = getAllocationContractIdForOrder(orderId);
    }

    if (!allocationContractId) {
      console.log(`[OrderService] No allocationContractId for order ${orderId} ‚Äî nothing to cancel`);
      return;
    }
    
    const executorPartyId = config.canton.operatorPartyId;
    const sdkClient = getCantonSDKClient();

    try {
      // cancelAllocation now works with or without SDK (has direct API fallback)
      await sdkClient.cancelAllocation(allocationContractId, partyId, executorPartyId);
      console.log(`[OrderService] ‚úÖ Allocation cancelled for order ${orderId} ‚Äî funds released`);
    } catch (cancelErr) {
      console.warn(`[OrderService] ‚ö†Ô∏è Could not cancel Allocation: ${cancelErr.message}`);
      // Don't throw ‚Äî order cancellation should still proceed
    }
  }

  /**
   * Place order using Canton JSON Ledger API v2.
   * 
   * Flow:
   * 1. Check balance via Canton SDK
   * 2. Create Allocation (exchange = executor, funds locked)
   * 3. Create Order contract on Canton
   * 4. Trigger matching engine
   * 
   * The Allocation ensures funds are locked at order time.
   * The exchange can settle at match time with its own key.
   */
  async placeOrder(orderData) {
    const {
      partyId,
      tradingPair,
      orderType, // BUY | SELL
      orderMode, // LIMIT | MARKET | STOP_LOSS
      price,
      quantity,
      timeInForce = 'GTC',
      stopPrice = null, // For STOP_LOSS orders
    } = orderData;

    // Validation
    if (!partyId || !tradingPair || !orderType || !orderMode || !quantity) {
      throw new ValidationError('Missing required fields: partyId, tradingPair, orderType, orderMode, quantity');
    }

    // Validate standard order types
    if (orderMode === 'LIMIT' && !price) {
      throw new ValidationError('Price is required for LIMIT orders');
    }

    // Validate stop-loss orders
    if (orderMode === 'STOP_LOSS') {
      if (!stopPrice) {
        throw new ValidationError('stopPrice is required for STOP_LOSS orders');
      }
      const sp = parseFloat(stopPrice);
      if (isNaN(sp) || sp <= 0) {
        throw new ValidationError('stopPrice must be a positive number');
      }

      // Validate stop-loss price direction
      try {
        const { getOrderBookService } = require('./orderBookService');
        const orderBookService = getOrderBookService();
        const orderBook = await orderBookService.getOrderBook(tradingPair);
        
        // Get current market price for validation
        const buys = orderBook.buyOrders || [];
        const sells = orderBook.sellOrders || [];
        let currentPrice = null;
        
        if (buys.length > 0 && sells.length > 0) {
          const bestBid = parseFloat(buys.sort((a, b) => parseFloat(b.price) - parseFloat(a.price))[0].price);
          const bestAsk = parseFloat(sells.sort((a, b) => parseFloat(a.price) - parseFloat(b.price))[0].price);
          currentPrice = (bestBid + bestAsk) / 2;
        } else if (buys.length > 0) {
          currentPrice = parseFloat(buys[0].price);
        } else if (sells.length > 0) {
          currentPrice = parseFloat(sells[0].price);
        }

        if (currentPrice) {
          // SELL stop loss must be below current price
          if (orderType.toUpperCase() === 'SELL' && new Decimal(stopPrice).gte(new Decimal(currentPrice))) {
            throw new ValidationError(
              `SELL stop loss stopPrice (${stopPrice}) must be below current market price (${currentPrice.toFixed(4)})`
            );
          }
          // BUY stop loss must be above current price
          if (orderType.toUpperCase() === 'BUY' && new Decimal(stopPrice).lte(new Decimal(currentPrice))) {
            throw new ValidationError(
              `BUY stop loss stopPrice (${stopPrice}) must be above current market price (${currentPrice.toFixed(4)})`
            );
          }
        }
      } catch (err) {
        if (err instanceof ValidationError) throw err;
        console.warn('[OrderService] Could not validate stop price against market:', err.message);
        // Continue ‚Äî validation is best-effort
      }
    }

    // Validate quantity is positive
    const qty = parseFloat(quantity);
    if (isNaN(qty) || qty <= 0) {
      throw new ValidationError('Quantity must be a positive number');
    }

    // For limit orders, validate price
    if (orderMode === 'LIMIT') {
      const prc = parseFloat(price);
      if (isNaN(prc) || prc <= 0) {
        throw new ValidationError('Price must be a positive number for limit orders');
      }
    }

    console.log('[OrderService] Placing order via Canton:', {
      partyId,
      tradingPair,
      orderType,
      orderMode,
      price,
      quantity,
      stopPrice: stopPrice || 'N/A',
    });

    // Get service token
    const token = await tokenProvider.getServiceToken();
    const packageId = config.canton.packageIds.clobExchange;
    const operatorPartyId = config.canton.operatorPartyId;

    if (!packageId) {
      throw new Error('CLOB_EXCHANGE_PACKAGE_ID is not configured');
    }

    // Generate unique order ID
    const orderId = `order-${Date.now()}-${uuidv4().substring(0, 8)}`;

    // For MARKET orders, get estimated price from order book (query Canton directly)
    let estimatedPrice = null;
    if (orderMode.toUpperCase() === 'MARKET') {
      try {
        const { getOrderBookService } = require('./orderBookService');
        const orderBookService = getOrderBookService();
        const orderBook = await orderBookService.getOrderBook(tradingPair);
        
        if (orderType.toUpperCase() === 'BUY') {
          const sells = orderBook.sellOrders || [];
          if (sells.length > 0) {
            const sortedSells = sells.sort((a, b) => parseFloat(a.price) - parseFloat(b.price));
            estimatedPrice = parseFloat(sortedSells[0].price);
            console.log(`[OrderService] MARKET BUY estimated price: ${estimatedPrice} (best ask from ${sells.length} sell orders)`);
          }
        } else {
          const buys = orderBook.buyOrders || [];
          if (buys.length > 0) {
            const sortedBuys = buys.sort((a, b) => parseFloat(b.price) - parseFloat(a.price));
            estimatedPrice = parseFloat(sortedBuys[0].price);
            console.log(`[OrderService] MARKET SELL estimated price: ${estimatedPrice} (best bid from ${buys.length} buy orders)`);
          }
        }
      } catch (err) {
        console.warn('[OrderService] Could not get order book for price estimation:', err.message);
      }
      
      if (orderType.toUpperCase() === 'BUY' && !estimatedPrice) {
        throw new ValidationError('No sell orders available in the market. Please use LIMIT order or wait for sellers.');
      }
      if (orderType.toUpperCase() === 'SELL' && !estimatedPrice) {
        throw new ValidationError('No buy orders available in the market. Please use LIMIT order or wait for buyers.');
      }
    }

    // For STOP_LOSS orders, use stopPrice for lock amount calculation
    // (funds must be locked NOW, even though the order triggers later)
    let effectivePrice = price;
    let effectiveOrderMode = orderMode;
    if (orderMode === 'STOP_LOSS') {
      // Use stop price for balance calculation
      effectivePrice = stopPrice;
      effectiveOrderMode = 'LIMIT'; // Lock based on stop price
    }

    // Calculate what needs to be locked
    const lockInfo = this.calculateLockAmount(tradingPair, orderType, effectivePrice, quantity, effectiveOrderMode, estimatedPrice);
    console.log(`[OrderService] Order will lock ${lockInfo.amount} ${lockInfo.asset}`);

    // ========= CHECK BALANCE VIA CANTON SDK =========
    let balanceCheck = null;
    try {
      balanceCheck = await this.checkBalanceForOrder(
        token, 
        partyId, 
        operatorPartyId,
        lockInfo.asset, 
        lockInfo.amount,
        orderId
      );
      if (balanceCheck.verified) {
        console.log(`[OrderService] ‚úÖ Balance verified: ${balanceCheck.availableBalance} ${lockInfo.asset} available`);
      } else {
        console.warn(`[OrderService] ‚ö†Ô∏è Balance check skipped (SDK not ready) ‚Äî order will proceed`);
      }
    } catch (balanceError) {
      console.error(`[OrderService] Balance check failed:`, balanceError.message);
      throw new ValidationError(`Insufficient ${lockInfo.asset} balance. Required: ${lockInfo.amount}`);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // STEP A: Balance verified ‚Äî reserve locked amount in memory
    // For external parties, the actual Allocation authorization is done
    // in the interactive order-placement transaction prepared below.
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let allocationContractId = null;

    // ‚ïê‚ïê‚ïê RESERVE BALANCE to prevent overselling ‚ïê‚ïê‚ïê
    addReservation(orderId, partyId, lockInfo.asset, lockInfo.amount, allocationContractId);

    // Determine initial order status
    // STOP_LOSS orders start as 'PENDING_TRIGGER' ‚Äî NOT added to active order book
    const initialStatus = orderMode === 'STOP_LOSS' ? 'PENDING_TRIGGER' : 'OPEN';

    // Create Order contract on Canton
    const timestamp = new Date().toISOString();

    // All parties are external (Confirmation permission).
    // Use interactive submission: prepare ‚Üí user signs in browser ‚Üí execute.
    console.log(`[OrderService] Preparing allocation via interactive submission (step 1/2)`);

    const sdkClient = getCantonSDKClient();
    const allocationPrep = await sdkClient.buildAllocationInteractiveCommand(
      partyId,
      operatorPartyId,
      String(lockInfo.amount),
      lockInfo.asset,
      operatorPartyId,
      orderId
    );

    const readAs = [...new Set([operatorPartyId, partyId, ...(allocationPrep.readAs || [])])];
    const disclosedContracts = allocationPrep.disclosedContracts || [];
    const synchronizerId = allocationPrep.synchronizerId || config.canton.synchronizerId;

    const prepareResult = await cantonService.prepareInteractiveSubmission({
      token,
      actAsParty: [partyId],
      commands: [allocationPrep.command],
      readAs,
      synchronizerId,
      disclosedContracts,
    });
    
    if (!prepareResult.preparedTransaction || !prepareResult.preparedTransactionHash) {
      throw new Error('Prepare returned incomplete result: missing preparedTransaction or preparedTransactionHash');
    }
    
    console.log(`[OrderService] ‚úÖ Allocation prepared (step 1/2). Hash to sign: ${prepareResult.preparedTransactionHash.substring(0, 40)}...`);
    
    return {
      requiresSignature: true,
      step: 'ALLOCATION_PREPARED',
      orderId,
      tradingPair,
      orderType: orderType.toUpperCase(),
      orderMode: orderMode.toUpperCase(),
      price: orderMode.toUpperCase() === 'LIMIT' && price ? price.toString() : (stopPrice ? stopPrice.toString() : null),
      quantity: quantity.toString(),
      stopPrice: stopPrice || null,
      preparedTransaction: prepareResult.preparedTransaction,
      preparedTransactionHash: prepareResult.preparedTransactionHash,
      hashingSchemeVersion: prepareResult.hashingSchemeVersion,
      partyId,
      lockInfo,
      stage: 'ALLOCATION_PREPARED',
    };
  }

  /**
   * Place order with UTXO handling (wrapper for placeOrder)
   */
  async placeOrderWithUTXOHandling(
    partyId,
    tradingPair,
    orderType,
    orderMode,
    quantity,
    price,
    orderBookContractId = null,
    userAccountContractId = null
  ) {
    return this.placeOrder({
      partyId,
      tradingPair,
      orderType,
      orderMode,
      price,
      quantity
    });
  }

  /**
   * Place order with allocation (now default behavior)
   */
  async placeOrderWithAllocation(
    partyId,
    tradingPair,
    orderType,
    orderMode,
    quantity,
    price,
    orderBookContractId,
    allocationCid
  ) {
    return this.placeOrder({
      partyId,
      tradingPair,
      orderType,
      orderMode,
      price,
      quantity
    });
  }

  /**
   * STEP 2: Execute a prepared order placement with the user's signature
   * 
   * Called after the frontend signs the preparedTransactionHash from placeOrder()
   * 
   * @param {string} preparedTransaction - Opaque blob from prepare step
   * @param {string} partyId - The external party that signed
   * @param {string} signatureBase64 - User's Ed25519 signature of preparedTransactionHash
   * @param {string} signedBy - Public key fingerprint that signed
   * @param {string|number} hashingSchemeVersion - From prepare response
   * @param {object} orderMeta - { orderId, tradingPair, orderType, orderMode, price, quantity, stopPrice, lockInfo }
   * @returns {Object} Order result with contractId
   */
  async executeOrderPlacement(preparedTransaction, partyId, signatureBase64, signedBy, hashingSchemeVersion, orderMeta = {}) {
    const token = await tokenProvider.getServiceToken();
    const operatorPartyId = config.canton.operatorPartyId;
    
    try {
      console.log(`[OrderService] EXECUTE order placement for ${partyId.substring(0, 30)}...`);
      
      const partySignatures = {
        signatures: [
          {
            party: partyId,
            signatures: [{
              format: 'SIGNATURE_FORMAT_RAW',
              signature: signatureBase64,
              signedBy: signedBy,
              signingAlgorithmSpec: 'SIGNING_ALGORITHM_SPEC_ED25519'
            }]
          }
        ]
      };
      
      const result = await cantonService.executeInteractiveSubmission({
        preparedTransaction,
        partySignatures,
        hashingSchemeVersion,
      }, token);
      
      const stage = orderMeta?.stage || 'ALLOCATION_PREPARED';

      // Extract created contract IDs from executed transaction
      let contractId = null;
      let allocationContractId = null;
      if (result.transaction?.events) {
        for (const event of result.transaction.events) {
          const created = event.created || event.CreatedEvent;
          const templateId = this._templateIdToString(created?.templateId);
          if (!created?.contractId) continue;
          if (!contractId && templateId.includes(':Order:Order')) {
            contractId = created.contractId;
          }
          if (!allocationContractId && templateId.includes('Allocation')) {
            allocationContractId = created.contractId;
          }
        }
      }

      // Some allocation factory executions return allocationCid only in exercise-result payload,
      // not as a top-level CreatedEvent. Extract it from the full execute response shape.
      if (!allocationContractId) {
        allocationContractId = this._extractAllocationCidFromExecuteResult(result);
      }
      
      if (orderMeta.orderId && allocationContractId) {
        setAllocationContractIdForOrder(orderMeta.orderId, allocationContractId);
        console.log(`[OrderService] ‚úÖ Allocation linked to order ${orderMeta.orderId}: ${allocationContractId.substring(0, 30)}...`);
      }

      // Step 1: allocation executed. Prepare Step 2: order create.
      if (stage === 'ALLOCATION_PREPARED') {
        const packageId = config.canton.packageIds.clobExchange;
        let effectiveAllocationCid = orderMeta.allocationContractId || allocationContractId;
        if (!effectiveAllocationCid) {
          effectiveAllocationCid = await this._findAllocationCidForOrder(orderMeta.orderId, partyId, token);
        }
        if (!packageId) {
          throw new Error('CLOB_EXCHANGE_PACKAGE_ID is not configured');
        }
        if (!effectiveAllocationCid) {
          throw new Error('Allocation execute succeeded but allocationContractId is missing for order create step');
        }

        const orderStatus = orderMeta.orderMode === 'STOP_LOSS' ? 'PENDING_TRIGGER' : 'OPEN';
        const orderCreateArgs = {
          orderId: orderMeta.orderId,
          owner: partyId,
          orderType: orderMeta.orderType,
          orderMode: orderMeta.orderMode,
          tradingPair: orderMeta.tradingPair,
          price: orderMeta.price ? String(orderMeta.price) : null,
          quantity: String(orderMeta.quantity),
          filled: '0.0',
          status: orderStatus,
          timestamp: new Date().toISOString(),
          operator: operatorPartyId,
          allocationCid: effectiveAllocationCid,
          stopPrice: orderMeta.stopPrice || null,
        };

        const orderPrepareResult = await cantonService.prepareInteractiveSubmission({
          token,
          actAsParty: [partyId],
          commands: [{
            CreateCommand: {
              templateId: `${packageId}:Order:Order`,
              createArguments: orderCreateArgs,
            },
          }],
          readAs: [operatorPartyId, partyId],
          synchronizerId: config.canton.synchronizerId,
        });

        if (!orderPrepareResult.preparedTransaction || !orderPrepareResult.preparedTransactionHash) {
          throw new Error('Order create prepare returned incomplete result');
        }

        console.log(`[OrderService] ‚úÖ Order create prepared (step 2/2) for ${orderMeta.orderId}`);
        return {
          requiresSignature: true,
          step: 'ORDER_CREATE_PREPARED',
          orderId: orderMeta.orderId,
          preparedTransaction: orderPrepareResult.preparedTransaction,
          preparedTransactionHash: orderPrepareResult.preparedTransactionHash,
          hashingSchemeVersion: orderPrepareResult.hashingSchemeVersion,
          partyId,
          orderMeta: {
            ...orderMeta,
            stage: 'ORDER_CREATE_PREPARED',
            allocationContractId: effectiveAllocationCid,
          },
        };
      }

      if (!contractId) {
        contractId = result.transaction?.updateId || result.updateId || `${orderMeta.orderId}-pending`;
      }

      console.log(`[OrderService] ‚úÖ Order placed via interactive submission: ${orderMeta.orderId} (${contractId?.substring(0, 20)}...)`);
      
      // Register in tracking systems
      const finalAllocationCid = orderMeta.allocationContractId || allocationContractId || null;
      const orderRecord = {
        contractId,
        orderId: orderMeta.orderId,
        owner: partyId,
        tradingPair: orderMeta.tradingPair,
        orderType: orderMeta.orderType,
        orderMode: orderMeta.orderMode,
        price: orderMeta.price,
        stopPrice: orderMeta.stopPrice || null,
        quantity: orderMeta.quantity,
        filled: '0',
        status: orderMeta.orderMode === 'STOP_LOSS' ? 'PENDING_TRIGGER' : 'OPEN',
        timestamp: new Date().toISOString(),
        lockId: null,
        lockedAmount: orderMeta.lockInfo?.amount || '0',
        lockedAsset: orderMeta.lockInfo?.asset || '',
        allocationContractId: finalAllocationCid,
      };
      
      // Register in global open orders registry
      if (orderRecord.status === 'OPEN') {
        registerOpenOrders([orderRecord]);
      }
      
      const readModel = getReadModelService();
      if (readModel) {
        readModel.addOrder({
          ...orderRecord,
          quantity: parseFloat(orderRecord.quantity),
          filled: 0,
          operator: operatorPartyId,
        });
      }
      
      // Broadcast via WebSocket
      if (global.broadcastWebSocket && orderRecord.status === 'OPEN') {
        global.broadcastWebSocket(`orderbook:${orderMeta.tradingPair}`, {
          type: 'NEW_ORDER',
          orderId: orderMeta.orderId,
          contractId: contractId,
          owner: partyId,
          orderType: orderMeta.orderType,
          orderMode: orderMeta.orderMode,
          price: orderMeta.price,
          quantity: orderMeta.quantity,
          remaining: orderMeta.quantity,
          tradingPair: orderMeta.tradingPair,
          timestamp: new Date().toISOString()
        });
      }
      
      // Trigger matching engine for OPEN orders
      if (orderRecord.status === 'OPEN') {
        try {
          const { getMatchingEngine } = require('./matching-engine');
          const matchingEngine = getMatchingEngine();
          if (matchingEngine) {
            console.log(`[OrderService] Triggering matching for ${orderMeta.tradingPair}`);
            matchingEngine.triggerMatchingCycle(orderMeta.tradingPair).catch(err => {
              console.warn(`[OrderService] ‚ö†Ô∏è Matching cycle error: ${err.message}`);
            });
          }
        } catch (matchErr) {
          console.warn('[OrderService] Could not trigger matching:', matchErr.message);
        }
      }
      
      return {
        success: true,
        usedInteractiveSubmission: true,
        orderId: orderMeta.orderId,
        contractId,
        status: orderRecord.status,
        tradingPair: orderMeta.tradingPair,
        orderType: orderMeta.orderType,
        orderMode: orderMeta.orderMode,
        price: orderMeta.price,
        stopPrice: orderMeta.stopPrice || null,
        quantity: orderMeta.quantity,
        filled: '0',
        remaining: orderMeta.quantity,
        allocationContractId: finalAllocationCid,
        timestamp: new Date().toISOString()
      };
      
    } catch (error) {
      console.error('[OrderService] Failed to execute order placement:', error.message);
      
      // Release reservation on failure
      if (orderMeta.orderId && orderMeta.stage !== 'ORDER_CREATE_PREPARED') {
        releaseReservation(orderMeta.orderId);
      }
      throw error;
    }
  }

  /**
   * Cancel order: cancels the Allocation (releases locked funds),
   * then exercises CancelOrder on Canton to archive the Order contract.
   */
  async cancelOrder(orderContractId, partyId, tradingPair = null) {
    if (!orderContractId || !partyId) {
      throw new ValidationError('Order contract ID and party ID are required');
    }

    console.log(`[OrderService] Cancelling order: ${orderContractId} for party: ${partyId}`);

    const token = await tokenProvider.getServiceToken();
    const packageId = config.canton.packageIds.clobExchange;
    const operatorPartyId = config.canton.operatorPartyId;

    if (!packageId) {
      throw new Error('CLOB_EXCHANGE_PACKAGE_ID is not configured');
    }

    // First, get the order details to know what was locked
    let orderDetails = null;
    try {
      const legacyPackageId = config.canton.packageIds?.legacy;
      const templateIdsToQuery = [`${packageId}:Order:Order`];
      if (legacyPackageId && legacyPackageId !== packageId) {
        templateIdsToQuery.push(`${legacyPackageId}:Order:Order`);
      }
      const contracts = await cantonService.queryActiveContracts({
        party: partyId,
        templateIds: templateIdsToQuery,
        pageSize: 200
      }, token);
      
      const matchingContract = (Array.isArray(contracts) ? contracts : [])
        .find(c => c.contractId === orderContractId);
      
      if (matchingContract) {
        const payload = matchingContract.payload || matchingContract.createArgument || {};
        orderDetails = {
          contractId: orderContractId,
          orderId: payload.orderId,
          owner: payload.owner,
          tradingPair: payload.tradingPair,
          orderType: payload.orderType,
          orderMode: payload.orderMode,
          price: payload.price?.Some || payload.price,
          quantity: payload.quantity,
          filled: payload.filled || '0',
          status: payload.status,
          timestamp: payload.timestamp,
          allocationCid: payload.allocationCid || null
        };
        console.log(`[OrderService] Found order details: ${orderDetails.orderId}, allocationCid: ${orderDetails.allocationCid?.substring(0, 30) || 'none'}...`);
      } else {
        console.warn(`[OrderService] Order ${orderContractId.substring(0, 30)}... not found in active contracts`);
      }
    } catch (e) {
      console.warn('[OrderService] Could not fetch order details before cancel:', e.message);
    }

    // ‚ïê‚ïê‚ïê Cancel the Allocation ‚Äî release locked funds via Allocation_Cancel ‚ïê‚ïê‚ïê
    const orderId_cancel = orderDetails?.orderId;
    if (orderId_cancel) {
      const allocationCid = orderDetails?.allocationCid || getAllocationContractIdForOrder(orderId_cancel);
      if (allocationCid) {
        try {
          await this.cancelAllocationForOrder(orderId_cancel, allocationCid, partyId);
          console.log(`[OrderService] ‚úÖ Allocation cancelled ‚Äî funds released`);
        } catch (allocCancelErr) {
          console.warn('[OrderService] Could not cancel Allocation:', allocCancelErr.message);
          // Continue with cancellation even if allocation cancel fails
      }
    } else {
        console.log(`[OrderService] No allocationCid for order ‚Äî skipping Allocation cancel`);
      }
    }

    // Unregister stop-loss if this was a stop-loss order
    if (orderDetails?.orderMode === 'STOP_LOSS' || orderDetails?.status === 'PENDING_TRIGGER') {
      try {
        const { getStopLossService } = require('./stopLossService');
        const stopLossService = getStopLossService();
        stopLossService.unregisterStopLoss(orderContractId);
        console.log(`[OrderService] ‚úÖ Stop-loss unregistered for cancelled order`);
      } catch (slErr) {
        console.warn(`[OrderService] ‚ö†Ô∏è Could not unregister stop-loss: ${slErr.message}`);
      }
    }

    // CancelOrder is controlled by "owner" ‚Äî external parties need interactive submission.
    console.log(`[OrderService] Preparing CancelOrder for interactive signing`);
    
    const prepareResult = await cantonService.prepareInteractiveSubmission({
      token,
      actAsParty: [partyId],
      templateId: `${packageId}:Order:Order`,
      contractId: orderContractId,
      choice: 'CancelOrder',
      choiceArgument: {},
      readAs: [operatorPartyId, partyId],
    });
    
    if (!prepareResult.preparedTransaction || !prepareResult.preparedTransactionHash) {
      throw new Error('Prepare returned incomplete result for CancelOrder');
    }
    
    console.log(`[OrderService] ‚úÖ CancelOrder prepared. Hash to sign: ${prepareResult.preparedTransactionHash.substring(0, 40)}...`);
    
    return {
      requiresSignature: true,
      step: 'PREPARED',
      action: 'CANCEL',
      orderContractId,
      orderId: orderDetails?.orderId,
      tradingPair: orderDetails?.tradingPair || tradingPair,
      preparedTransaction: prepareResult.preparedTransaction,
      preparedTransactionHash: prepareResult.preparedTransactionHash,
      hashingSchemeVersion: prepareResult.hashingSchemeVersion,
      partyId,
      orderDetails,
    };
  }

  /**
   * Cancel order with UTXO handling (wrapper)
   */
  async cancelOrderWithUTXOHandling(
    partyId,
    tradingPair,
    orderType,
    orderContractId,
    orderBookContractId = null,
    userAccountContractId = null
  ) {
    return this.cancelOrder(orderContractId, partyId);
  }

  /**
   * STEP 2: Execute a prepared order cancellation with the user's signature
   * 
   * Called after the frontend signs the preparedTransactionHash from cancelOrder()
   * 
   * @param {string} preparedTransaction - Opaque blob from prepare step
   * @param {string} partyId - The external party that signed
   * @param {string} signatureBase64 - User's Ed25519 signature
   * @param {string} signedBy - Public key fingerprint
   * @param {string|number} hashingSchemeVersion - From prepare response
   * @param {object} cancelMeta - { orderContractId, orderId, tradingPair, orderDetails }
   * @returns {Object} Cancellation result
   */
  async executeOrderCancel(preparedTransaction, partyId, signatureBase64, signedBy, hashingSchemeVersion, cancelMeta = {}) {
    const token = await tokenProvider.getServiceToken();
    const operatorPartyId = config.canton.operatorPartyId;
    
    try {
      console.log(`[OrderService] EXECUTE order cancel for ${partyId.substring(0, 30)}...`);
      
      const partySignatures = {
        signatures: [
          {
            party: partyId,
            signatures: [{
              format: 'SIGNATURE_FORMAT_RAW',
              signature: signatureBase64,
              signedBy: signedBy,
              signingAlgorithmSpec: 'SIGNING_ALGORITHM_SPEC_ED25519'
            }]
          }
        ]
      };
      
      const result = await cantonService.executeInteractiveSubmission({
        preparedTransaction,
        partySignatures,
        hashingSchemeVersion,
      }, token);
      
      console.log(`[OrderService] ‚úÖ Order cancelled via interactive submission: ${cancelMeta.orderContractId?.substring(0, 20)}...`);
      
      // Release balance reservation
      if (cancelMeta.orderId) {
        releaseReservation(cancelMeta.orderId);
      }
      
      // Remove from tracking
      const readModel = getReadModelService();
      if (readModel) {
        readModel.removeOrder(cancelMeta.orderContractId);
      }
      
      // Unregister from global registry
      if (cancelMeta.orderContractId) {
        _globalOpenOrders.delete(cancelMeta.orderContractId);
      }
      
      // Broadcast via WebSocket
      if (global.broadcastWebSocket && cancelMeta.tradingPair) {
        global.broadcastWebSocket(`orderbook:${cancelMeta.tradingPair}`, {
          type: 'ORDER_CANCELLED',
          contractId: cancelMeta.orderContractId,
          orderId: cancelMeta.orderId,
          tradingPair: cancelMeta.tradingPair,
          timestamp: new Date().toISOString()
        });
      }
      
      return {
        success: true,
        usedInteractiveSubmission: true,
        cancelled: true,
        orderContractId: cancelMeta.orderContractId,
        orderId: cancelMeta.orderId,
        tradingPair: cancelMeta.tradingPair,
      };
      
    } catch (error) {
      console.error('[OrderService] Failed to execute order cancel:', error.message);
      throw error;
    }
  }

  /**
   * Get user's orders DIRECTLY from Canton API
   * NO CACHE - always queries Canton
   */
  async getUserOrders(partyId, status = 'OPEN', limit = 100) {
    if (!partyId) {
      throw new ValidationError('Party ID is required');
    }

    console.log(`[OrderService] Querying Canton DIRECTLY for party: ${partyId.substring(0, 30)}...`);
    
    const token = await tokenProvider.getServiceToken();
    const packageId = config.canton.packageIds.clobExchange;

    if (!packageId) {
      throw new Error('CLOB_EXCHANGE_PACKAGE_ID is not configured');
    }

    try {
      const legacyPackageId = config.canton.packageIds?.legacy;
      const templateIdsToQuery = [`${packageId}:Order:Order`];
      if (legacyPackageId && legacyPackageId !== packageId) {
        templateIdsToQuery.push(`${legacyPackageId}:Order:Order`);
      }
      const contracts = await cantonService.queryActiveContracts({
        party: partyId,
        templateIds: templateIdsToQuery,
        pageSize: limit
      }, token);

      const orders = (Array.isArray(contracts) ? contracts : [])
        .filter(c => {
          const templateId = c.templateId;
          if (!templateId?.includes(':Order:Order')) {
            return false;
          }
          const payload = c.payload || c.createArgument || {};
          if (payload.owner !== partyId) return false;
          return status === 'ALL' || payload.status === status;
        })
        .map(c => {
          const payload = c.payload || c.createArgument || {};
          const contractId = c.contractId;
          
          let extractedPrice = null;
          if (payload.price) {
            if (payload.price.Some !== undefined) {
              extractedPrice = payload.price.Some;
            } else if (typeof payload.price === 'string' || typeof payload.price === 'number') {
              extractedPrice = payload.price;
            } else if (payload.price === null) {
              extractedPrice = null;
            }
          }
          
          return {
            contractId: contractId,
            orderId: payload.orderId,
            owner: payload.owner,
            tradingPair: payload.tradingPair,
            orderType: payload.orderType,
            orderMode: payload.orderMode,
            price: extractedPrice,
            quantity: payload.quantity,
            filled: payload.filled || '0',
            status: payload.status,
            timestamp: payload.timestamp,
            allocationCid: payload.allocationCid || null
          };
        });

      console.log(`[OrderService] Found ${orders.length} orders from Canton for ${partyId.substring(0, 30)}...`);
      
      // Register OPEN orders in the global registry so the OrderBookService can see them
      // (handles orders placed through other backend instances where operator is not a stakeholder)
      registerOpenOrders(orders);
      
      return orders;
    } catch (error) {
      if (error.message?.includes('200') || error.message?.includes('MAXIMUM_LIST')) {
        console.log('[OrderService] 200+ contracts, using operator party query');
        try {
          const operatorPartyId = config.canton.operatorPartyId;
          const contracts = await cantonService.queryActiveContracts({
            party: operatorPartyId,
            templateIds: [`${packageId}:Order:Order`],
            pageSize: 50
          }, token);
          
          const orders = (Array.isArray(contracts) ? contracts : [])
            .filter(c => {
              const payload = c.payload || c.createArgument || {};
              return payload.owner === partyId && 
                     (status === 'ALL' || payload.status === status);
            })
            .map(c => {
              const payload = c.payload || c.createArgument || {};
              return {
                contractId: c.contractId,
                orderId: payload.orderId,
                owner: payload.owner,
                tradingPair: payload.tradingPair,
                orderType: payload.orderType,
                orderMode: payload.orderMode,
                price: payload.price?.Some || payload.price,
                quantity: payload.quantity,
                filled: payload.filled || '0',
                status: payload.status,
                timestamp: payload.timestamp
              };
            });
          return orders;
        } catch (fallbackError) {
          console.error('[OrderService] Fallback query also failed:', fallbackError.message);
          return [];
        }
      }
      console.error('[OrderService] Error getting user orders from Canton:', error.message);
      return [];
    }
  }

  /**
   * Get all open orders for a trading pair (Global Order Book)
   */
  async getOrdersForPair(tradingPair, limit = 200) {
    console.log(`[OrderService] Getting all orders for pair: ${tradingPair}`);

    const token = await tokenProvider.getServiceToken();
    const packageId = config.canton.packageIds.clobExchange;
    const operatorPartyId = config.canton.operatorPartyId;

    if (!packageId) {
      throw new Error('CLOB_EXCHANGE_PACKAGE_ID is not configured');
    }

    try {
      const contracts = await cantonService.queryActiveContracts({
        party: operatorPartyId,
        templateIds: [`${packageId}:Order:Order`],
        pageSize: limit
      }, token);

      // Filter by trading pair and OPEN status (exclude PENDING_TRIGGER stop-loss orders)
      const orders = (Array.isArray(contracts) ? contracts : [])
        .filter(c => {
          const payload = c.payload || c.createArgument || {};
          return payload.tradingPair === tradingPair && payload.status === 'OPEN';
        })
        .map(c => {
          const payload = c.payload || c.createArgument || {};
          return {
            contractId: c.contractId,
            orderId: payload.orderId,
            owner: payload.owner,
            tradingPair: payload.tradingPair,
            orderType: payload.orderType,
            orderMode: payload.orderMode,
            price: payload.price?.Some || payload.price,
            quantity: payload.quantity,
            filled: payload.filled || '0',
            remaining: (parseFloat(payload.quantity) - parseFloat(payload.filled || 0)).toString(),
            status: payload.status,
            timestamp: payload.timestamp,
            allocationCid: payload.allocationCid || null,
          };
        });

      const buyOrders = orders
        .filter(o => o.orderType === 'BUY')
        .sort((a, b) => {
          const priceA = parseFloat(a.price) || Infinity;
          const priceB = parseFloat(b.price) || Infinity;
          if (priceA !== priceB) return priceB - priceA;
          return new Date(a.timestamp) - new Date(b.timestamp);
        });

      const sellOrders = orders
        .filter(o => o.orderType === 'SELL')
        .sort((a, b) => {
          const priceA = parseFloat(a.price) || 0;
          const priceB = parseFloat(b.price) || 0;
          if (priceA !== priceB) return priceA - priceB;
          return new Date(a.timestamp) - new Date(b.timestamp);
        });

      console.log(`[OrderService] Found ${buyOrders.length} buys, ${sellOrders.length} sells for ${tradingPair}`);

      return {
        tradingPair,
        buyOrders,
        sellOrders,
        timestamp: new Date().toISOString()
      };
    } catch (error) {
      console.error('[OrderService] Error getting orders for pair:', error.message);
      return {
        tradingPair,
        buyOrders: [],
        sellOrders: [],
        timestamp: new Date().toISOString()
      };
    }
  }

  /**
   * Get order by contract ID
   */
  async getOrder(orderContractId) {
    if (!orderContractId) {
      throw new ValidationError('Order contract ID is required');
    }

    console.log(`[OrderService] Getting order: ${orderContractId}`);

    const token = await tokenProvider.getServiceToken();
    
    try {
      const contract = await cantonService.lookupContract(orderContractId, token);
      
      if (!contract) {
        throw new NotFoundError(`Order not found: ${orderContractId}`);
      }

      const payload = contract.payload || contract.createArgument || {};

      return {
        contractId: orderContractId,
        orderId: payload.orderId,
        owner: payload.owner,
        tradingPair: payload.tradingPair,
        orderType: payload.orderType,
        orderMode: payload.orderMode,
        price: payload.price?.Some || payload.price,
        quantity: payload.quantity,
        filled: payload.filled || '0',
        status: payload.status,
        timestamp: payload.timestamp,
        allocationCid: payload.allocationCid || null
      };
    } catch (error) {
      console.error('[OrderService] Error getting order:', error.message);
      throw error;
    }
  }
}

module.exports = OrderService;

// Export reservation helpers for use by the matching engine
module.exports.releaseReservation = releaseReservation;
module.exports.releasePartialReservation = releasePartialReservation;
module.exports.getReservedBalance = getReservedBalance;
module.exports.getAllocationContractIdForOrder = getAllocationContractIdForOrder;
module.exports.setAllocationContractIdForOrder = setAllocationContractIdForOrder;
module.exports.getGlobalOpenOrders = getGlobalOpenOrders;
